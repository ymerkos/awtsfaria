//B"H
/**
 * @fileoverview This module provides functions for hashing and verifying passwords using Node.js's built-in crypto library.
 * 
 * @module passwordHashing
 * @requires crypto
 */

 const crypto = require('crypto');

 /**
  * Generate a random salt for password hashing.
  * 
  * @function
  * @name generateSalt
  * @param {number} length - The length of the salt string to generate.
  * @returns {string} A random salt string of the specified length.
  * 
  * @example
  * const salt = generateSalt(16);
  * // generates a 16 character hexadecimal salt
  * 
  * The salt is generated by creating random bytes (half of the desired length, because each byte is 2 hexadecimal characters)
  * and then converting them to a hexadecimal string. If the salt is longer than needed, it is sliced to the correct length.
  * 
  * The salt is used in the hashPassword and verifyPassword functions to add additional security to the hashed password.
  * Even if two users have the same password, their hashed passwords will be different because the salt is unique.
  */
 function generateSalt(length) {
     return crypto.randomBytes(Math.ceil(length/2))
         .toString('hex')  // convert to hexadecimal format
         .slice(0,length); // return required number of characters
 }
 
 /**
  * Hash a password using the HMAC-SHA256 algorithm.
  * 
  * @function
  * @name hashPassword
  * @param {string} password - The plaintext password to hash.
  * @param {string} salt - The salt to use when hashing.
  * @returns {string} The hashed password.
  * 
  * @example
  * const hashedPassword = hashPassword('password123', 'abcdefg');
  * 
  * The hashPassword function uses the crypto library's createHmac method to create an HMAC (Hash-based Message Authentication Code).
  * The HMAC algorithm combines the password and the salt in a way that is secure against certain types of attacks.
  * The output of the HMAC algorithm is then converted to a hexadecimal string to create the hashed password.
  */
 function hashPassword(password, salt) {
     return crypto.createHmac('sha256', salt)
         .update(password)
         .digest('hex');
 }
 
 /**
  * Verify a password against a hashed password.
  * 
  * @function
  * @name verifyPassword
  * @param {string} password - The plaintext password to check.
  * @param {string} hashedPassword - The hashed password to check against.
  * @param {string} salt - The salt that was used when hashing the password.
  * @returns {boolean} True if the password matches the hashed password, false otherwise.
  * 
  * @example
  * const passwordsMatch = verifyPassword('password123', hashedPassword, 'abcdefg');
  * 
  * The verifyPassword function hashes the input password using the same salt that was used when the original password was hashed.
  * It then compares the newly hashed password to the original hashed password. If they match, that means the input password is correct.
  */
 function verifyPassword(password, hashedPassword, salt) {
     const newHashedPassword = crypto.createHmac('sha256', salt)
         .update(password)
         .digest('hex');
     return newHashedPassword === hashedPassword;
 }
 

 
function createToken(userId, secret, extra={}) {
    // Combine the user's ID and the current timestamp to form the token data
    const data = Buffer.from(JSON.stringify({
     userId, 
     zman:Date.now(),
     hosuhfuh:extra 
    })).toString("base64");
  
    // Create a HMAC (hash-based message authentication code) of the data, using the secret key
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(data);
  
    // Return the token as the HMAC digest
    return "B\"H."+data+"."+hmac.digest('hex');
  }
  
  function validateToken(token, secret) {
    // To validate a token, we need to recreate it using the same data and secret,
    // then compare it to the provided token.
  
    // Split the token into the original data and the provided HMAC digest
    const [
     BH, 
     data, 
     providedHmac
    ] = token.split('.');
  
    // Recreate the HMAC from the data and secret
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(data);
  
    // If the recreated HMAC matches the provided HMAC, the token is valid
    return hmac.digest('hex') === providedHmac;
  }


 module.exports = {
    validateToken,
    createToken,
     generateSalt,
     hashPassword,
     verifyPassword
 };
 
