//B"H
const __vite__fileDeps = ["assets/Introduction-CZHuZ-rG.js", "assets/Introduction-W6Hs4Bp2.css", "assets/Tutorial-DmabWX4a.js", "assets/texturing_panel-BJFucmzL.js", "assets/Tutorial-DnsfOC5U.css", "assets/Geometry-DBfkJt5W.js", "assets/Geometry-DL2HtKnc.css", "assets/GrowthInfluence-pOi3bAVv.js", "assets/GrowthInfluence-DHQKS4PK.css", "assets/Branch-vZEzLl-k.js", "assets/Branch-Bzbolqel.css", "assets/Foliage-CWqnDO8c.js", "assets/Foliage-QMbqfsyf.css", "assets/Fruit-D9AFu9Ov.js", "assets/Fruit-Qk5o8h0z.css", "assets/ChangesOverAge-B8pQzDq4.js", "assets/ChangesOverAge-BN8WxphL.css", "assets/Texturing-DD_9CI-z.js", "assets/Texturing-DpzHLAlC.css"],
    __vite__mapDeps = i => i.map(i => __vite__fileDeps[i]);
var B_ = Object.defineProperty;
var k_ = (n, e, t) => e in n ? B_(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var _t = (n, e, t) => (k_(n, typeof e != "symbol" ? e + "" : e, t), t);
(function () {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
    new MutationObserver(r => {
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function i(r) {
        if (r.ep) return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
})();

function Tu(n, e) {
    const t = new Set(n.split(","));
    return e ? i => t.has(i.toLowerCase()) : i => t.has(i)
}
const yt = {},
    is = [],
    An = () => {},
    z_ = () => !1,
    ol = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97),
    wu = n => n.startsWith("onUpdate:"),
    Gt = Object.assign,
    Eu = (n, e) => {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1)
    },
    G_ = Object.prototype.hasOwnProperty,
    it = (n, e) => G_.call(n, e),
    Xe = Array.isArray,
    rs = n => al(n) === "[object Map]",
    am = n => al(n) === "[object Set]",
    $e = n => typeof n == "function",
    Dt = n => typeof n == "string",
    xs = n => typeof n == "symbol",
    bt = n => n !== null && typeof n == "object",
    lm = n => (bt(n) || $e(n)) && $e(n.then) && $e(n.catch),
    cm = Object.prototype.toString,
    al = n => cm.call(n),
    V_ = n => al(n).slice(8, -1),
    $s = n => al(n) === "[object Object]",
    Au = n => Dt(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n,
    Ca = Tu(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    ll = n => {
        const e = Object.create(null);
        return t => e[t] || (e[t] = n(t))
    },
    H_ = /-(\w)/g,
    Jn = ll(n => n.replace(H_, (e, t) => t ? t.toUpperCase() : "")),
    W_ = /\B([A-Z])/g,
    _r = ll(n => n.replace(W_, "-$1").toLowerCase()),
    cl = ll(n => n.charAt(0).toUpperCase() + n.slice(1)),
    Vl = ll(n => n ? `on${cl(n)}` : ""),
    Bi = (n, e) => !Object.is(n, e),
    Hl = (n, e) => {
        for (let t = 0; t < n.length; t++) n[t](e)
    },
    Ba = (n, e, t) => {
        Object.defineProperty(n, e, {
            configurable: !0,
            enumerable: !1,
            value: t
        })
    },
    $_ = n => {
        const e = parseFloat(n);
        return isNaN(e) ? n : e
    };
let Hh;
const um = () => Hh || (Hh = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function Ru(n) {
    if (Xe(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
            const i = n[t],
                r = Dt(i) ? K_(i) : Ru(i);
            if (r)
                for (const s in r) e[s] = r[s]
        }
        return e
    } else if (Dt(n) || bt(n)) return n
}
const X_ = /;(?![^(]*\))/g,
    q_ = /:([^]+)/,
    Y_ = /\/\*[^]*?\*\//g;

function K_(n) {
    const e = {};
    return n.replace(Y_, "").split(X_).forEach(t => {
        if (t) {
            const i = t.split(q_);
            i.length > 1 && (e[i[0].trim()] = i[1].trim())
        }
    }), e
}

function Un(n) {
    let e = "";
    if (Dt(n)) e = n;
    else if (Xe(n))
        for (let t = 0; t < n.length; t++) {
            const i = Un(n[t]);
            i && (e += i + " ")
        } else if (bt(n))
            for (const t in n) n[t] && (e += t + " ");
    return e.trim()
}
const j_ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    J_ = Tu(j_);

function hm(n) {
    return !!n || n === ""
}
const jt = n => Dt(n) ? n : n == null ? "" : Xe(n) || bt(n) && (n.toString === cm || !$e(n.toString)) ? JSON.stringify(n, fm, 2) : String(n),
    fm = (n, e) => e && e.__v_isRef ? fm(n, e.value) : rs(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((t, [i, r], s) => (t[Wl(i, s) + " =>"] = r, t), {})
    } : am(e) ? {
        [`Set(${e.size})`]: [...e.values()].map(t => Wl(t))
    } : xs(e) ? Wl(e) : bt(e) && !Xe(e) && !$s(e) ? String(e) : e,
    Wl = (n, e = "") => {
        var t;
        return xs(n) ? `Symbol(${(t=n.description)!=null?t:e})` : n
    };
let Dn;
class Z_ {
    constructor(e = !1) {
        this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Dn, !e && Dn && (this.index = (Dn.scopes || (Dn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const t = Dn;
            try {
                return Dn = this, e()
            } finally {
                Dn = t
            }
        }
    }
    on() {
        Dn = this
    }
    off() {
        Dn = this.parent
    }
    stop(e) {
        if (this._active) {
            let t, i;
            for (t = 0, i = this.effects.length; t < i; t++) this.effects[t].stop();
            for (t = 0, i = this.cleanups.length; t < i; t++) this.cleanups[t]();
            if (this.scopes)
                for (t = 0, i = this.scopes.length; t < i; t++) this.scopes[t].stop(!0);
            if (!this.detached && this.parent && !e) {
                const r = this.parent.scopes.pop();
                r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function Q_(n, e = Dn) {
    e && e.active && e.effects.push(n)
}

function e0() {
    return Dn
}
let rr;
class Cu {
    constructor(e, t, i, r) {
        this.fn = e, this.trigger = t, this.scheduler = i, this.active = !0, this.deps = [], this._dirtyLevel = 2, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, Q_(this, r)
    }
    get dirty() {
        if (this._dirtyLevel === 1) {
            vr();
            for (let e = 0; e < this._depsLength; e++) {
                const t = this.deps[e];
                if (t.computed && (t0(t.computed), this._dirtyLevel >= 2)) break
            }
            this._dirtyLevel < 2 && (this._dirtyLevel = 0), yr()
        }
        return this._dirtyLevel >= 2
    }
    set dirty(e) {
        this._dirtyLevel = e ? 2 : 0
    }
    run() {
        if (this._dirtyLevel = 0, !this.active) return this.fn();
        let e = Ii,
            t = rr;
        try {
            return Ii = !0, rr = this, this._runnings++, Wh(this), this.fn()
        } finally {
            $h(this), this._runnings--, rr = t, Ii = e
        }
    }
    stop() {
        var e;
        this.active && (Wh(this), $h(this), (e = this.onStop) == null || e.call(this), this.active = !1)
    }
}

function t0(n) {
    return n.value
}

function Wh(n) {
    n._trackId++, n._depsLength = 0
}

function $h(n) {
    if (n.deps && n.deps.length > n._depsLength) {
        for (let e = n._depsLength; e < n.deps.length; e++) dm(n.deps[e], n);
        n.deps.length = n._depsLength
    }
}

function dm(n, e) {
    const t = n.get(e);
    t !== void 0 && e._trackId !== t && (n.delete(e), n.size === 0 && n.cleanup())
}
let Ii = !0,
    qc = 0;
const pm = [];

function vr() {
    pm.push(Ii), Ii = !1
}

function yr() {
    const n = pm.pop();
    Ii = n === void 0 ? !0 : n
}

function Pu() {
    qc++
}

function Lu() {
    for (qc--; !qc && Yc.length;) Yc.shift()()
}

function mm(n, e, t) {
    if (e.get(n) !== n._trackId) {
        e.set(n, n._trackId);
        const i = n.deps[n._depsLength];
        i !== e ? (i && dm(i, n), n.deps[n._depsLength++] = e) : n._depsLength++
    }
}
const Yc = [];

function gm(n, e, t) {
    Pu();
    for (const i of n.keys())
        if (i._dirtyLevel < e && n.get(i) === i._trackId) {
            const r = i._dirtyLevel;
            i._dirtyLevel = e, r === 0 && (i._shouldSchedule = !0, i.trigger())
        } _m(n), Lu()
}

function _m(n) {
    for (const e of n.keys()) e.scheduler && e._shouldSchedule && (!e._runnings || e.allowRecurse) && n.get(e) === e._trackId && (e._shouldSchedule = !1, Yc.push(e.scheduler))
}
const vm = (n, e) => {
        const t = new Map;
        return t.cleanup = n, t.computed = e, t
    },
    Kc = new WeakMap,
    sr = Symbol(""),
    jc = Symbol("");

function hn(n, e, t) {
    if (Ii && rr) {
        let i = Kc.get(n);
        i || Kc.set(n, i = new Map);
        let r = i.get(t);
        r || i.set(t, r = vm(() => i.delete(t))), mm(rr, r)
    }
}

function di(n, e, t, i, r, s) {
    const o = Kc.get(n);
    if (!o) return;
    let a = [];
    if (e === "clear") a = [...o.values()];
    else if (t === "length" && Xe(n)) {
        const l = Number(i);
        o.forEach((c, u) => {
            (u === "length" || !xs(u) && u >= l) && a.push(c)
        })
    } else switch (t !== void 0 && a.push(o.get(t)), e) {
    case "add":
        Xe(n) ? Au(t) && a.push(o.get("length")) : (a.push(o.get(sr)), rs(n) && a.push(o.get(jc)));
        break;
    case "delete":
        Xe(n) || (a.push(o.get(sr)), rs(n) && a.push(o.get(jc)));
        break;
    case "set":
        rs(n) && a.push(o.get(sr));
        break
    }
    Pu();
    for (const l of a) l && gm(l, 2);
    Lu()
}
const n0 = Tu("__proto__,__v_isRef,__isVue"),
    ym = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(xs)),
    Xh = i0();

function i0() {
    const n = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        n[e] = function (...t) {
            const i = lt(this);
            for (let s = 0, o = this.length; s < o; s++) hn(i, "get", s + "");
            const r = i[e](...t);
            return r === -1 || r === !1 ? i[e](...t.map(lt)) : r
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        n[e] = function (...t) {
            vr(), Pu();
            const i = lt(this)[e].apply(this, t);
            return Lu(), yr(), i
        }
    }), n
}

function r0(n) {
    const e = lt(this);
    return hn(e, "has", n), e.hasOwnProperty(n)
}
class xm {
    constructor(e = !1, t = !1) {
        this._isReadonly = e, this._shallow = t
    }
    get(e, t, i) {
        const r = this._isReadonly,
            s = this._shallow;
        if (t === "__v_isReactive") return !r;
        if (t === "__v_isReadonly") return r;
        if (t === "__v_isShallow") return s;
        if (t === "__v_raw") return i === (r ? s ? _0 : Tm : s ? Sm : bm).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
        const o = Xe(e);
        if (!r) {
            if (o && it(Xh, t)) return Reflect.get(Xh, t, i);
            if (t === "hasOwnProperty") return r0
        }
        const a = Reflect.get(e, t, i);
        return (xs(t) ? ym.has(t) : n0(t)) || (r || hn(e, "get", t), s) ? a : fn(a) ? o && Au(t) ? a : a.value : bt(a) ? r ? Em(a) : hl(a) : a
    }
}
class Mm extends xm {
    constructor(e = !1) {
        super(!1, e)
    }
    set(e, t, i, r) {
        let s = e[t];
        if (!this._shallow) {
            const l = hs(s);
            if (!ka(i) && !hs(i) && (s = lt(s), i = lt(i)), !Xe(e) && fn(s) && !fn(i)) return l ? !1 : (s.value = i, !0)
        }
        const o = Xe(e) && Au(t) ? Number(t) < e.length : it(e, t),
            a = Reflect.set(e, t, i, r);
        return e === lt(r) && (o ? Bi(i, s) && di(e, "set", t, i) : di(e, "add", t, i)), a
    }
    deleteProperty(e, t) {
        const i = it(e, t);
        e[t];
        const r = Reflect.deleteProperty(e, t);
        return r && i && di(e, "delete", t, void 0), r
    }
    has(e, t) {
        const i = Reflect.has(e, t);
        return (!xs(t) || !ym.has(t)) && hn(e, "has", t), i
    }
    ownKeys(e) {
        return hn(e, "iterate", Xe(e) ? "length" : sr), Reflect.ownKeys(e)
    }
}
class s0 extends xm {
    constructor(e = !1) {
        super(!0, e)
    }
    set(e, t) {
        return !0
    }
    deleteProperty(e, t) {
        return !0
    }
}
const o0 = new Mm,
    a0 = new s0,
    l0 = new Mm(!0),
    Iu = n => n,
    ul = n => Reflect.getPrototypeOf(n);

function Do(n, e, t = !1, i = !1) {
    n = n.__v_raw;
    const r = lt(n),
        s = lt(e);
    t || (Bi(e, s) && hn(r, "get", e), hn(r, "get", s));
    const {
        has: o
    } = ul(r), a = i ? Iu : t ? Nu : ro;
    if (o.call(r, e)) return a(n.get(e));
    if (o.call(r, s)) return a(n.get(s));
    n !== r && n.get(e)
}

function Oo(n, e = !1) {
    const t = this.__v_raw,
        i = lt(t),
        r = lt(n);
    return e || (Bi(n, r) && hn(i, "has", n), hn(i, "has", r)), n === r ? t.has(n) : t.has(n) || t.has(r)
}

function No(n, e = !1) {
    return n = n.__v_raw, !e && hn(lt(n), "iterate", sr), Reflect.get(n, "size", n)
}

function qh(n) {
    n = lt(n);
    const e = lt(this);
    return ul(e).has.call(e, n) || (e.add(n), di(e, "add", n, n)), this
}

function Yh(n, e) {
    e = lt(e);
    const t = lt(this),
        {
            has: i,
            get: r
        } = ul(t);
    let s = i.call(t, n);
    s || (n = lt(n), s = i.call(t, n));
    const o = r.call(t, n);
    return t.set(n, e), s ? Bi(e, o) && di(t, "set", n, e) : di(t, "add", n, e), this
}

function Kh(n) {
    const e = lt(this),
        {
            has: t,
            get: i
        } = ul(e);
    let r = t.call(e, n);
    r || (n = lt(n), r = t.call(e, n)), i && i.call(e, n);
    const s = e.delete(n);
    return r && di(e, "delete", n, void 0), s
}

function jh() {
    const n = lt(this),
        e = n.size !== 0,
        t = n.clear();
    return e && di(n, "clear", void 0, void 0), t
}

function Uo(n, e) {
    return function (i, r) {
        const s = this,
            o = s.__v_raw,
            a = lt(o),
            l = e ? Iu : n ? Nu : ro;
        return !n && hn(a, "iterate", sr), o.forEach((c, u) => i.call(r, l(c), l(u), s))
    }
}

function Fo(n, e, t) {
    return function (...i) {
        const r = this.__v_raw,
            s = lt(r),
            o = rs(s),
            a = n === "entries" || n === Symbol.iterator && o,
            l = n === "keys" && o,
            c = r[n](...i),
            u = t ? Iu : e ? Nu : ro;
        return !e && hn(s, "iterate", l ? jc : sr), {
            next() {
                const {
                    value: h,
                    done: f
                } = c.next();
                return f ? {
                    value: h,
                    done: f
                } : {
                    value: a ? [u(h[0]), u(h[1])] : u(h),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function _i(n) {
    return function (...e) {
        return n === "delete" ? !1 : n === "clear" ? void 0 : this
    }
}

function c0() {
    const n = {
            get(s) {
                return Do(this, s)
            },
            get size() {
                return No(this)
            },
            has: Oo,
            add: qh,
            set: Yh,
            delete: Kh,
            clear: jh,
            forEach: Uo(!1, !1)
        },
        e = {
            get(s) {
                return Do(this, s, !1, !0)
            },
            get size() {
                return No(this)
            },
            has: Oo,
            add: qh,
            set: Yh,
            delete: Kh,
            clear: jh,
            forEach: Uo(!1, !0)
        },
        t = {
            get(s) {
                return Do(this, s, !0)
            },
            get size() {
                return No(this, !0)
            },
            has(s) {
                return Oo.call(this, s, !0)
            },
            add: _i("add"),
            set: _i("set"),
            delete: _i("delete"),
            clear: _i("clear"),
            forEach: Uo(!0, !1)
        },
        i = {
            get(s) {
                return Do(this, s, !0, !0)
            },
            get size() {
                return No(this, !0)
            },
            has(s) {
                return Oo.call(this, s, !0)
            },
            add: _i("add"),
            set: _i("set"),
            delete: _i("delete"),
            clear: _i("clear"),
            forEach: Uo(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        n[s] = Fo(s, !1, !1), t[s] = Fo(s, !0, !1), e[s] = Fo(s, !1, !0), i[s] = Fo(s, !0, !0)
    }), [n, t, e, i]
}
const [u0, h0, f0, d0] = c0();

function Du(n, e) {
    const t = e ? n ? d0 : f0 : n ? h0 : u0;
    return (i, r, s) => r === "__v_isReactive" ? !n : r === "__v_isReadonly" ? n : r === "__v_raw" ? i : Reflect.get(it(t, r) && r in i ? t : i, r, s)
}
const p0 = {
        get: Du(!1, !1)
    },
    m0 = {
        get: Du(!1, !0)
    },
    g0 = {
        get: Du(!0, !1)
    },
    bm = new WeakMap,
    Sm = new WeakMap,
    Tm = new WeakMap,
    _0 = new WeakMap;

function v0(n) {
    switch (n) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}

function y0(n) {
    return n.__v_skip || !Object.isExtensible(n) ? 0 : v0(V_(n))
}

function hl(n) {
    return hs(n) ? n : Ou(n, !1, o0, p0, bm)
}

function wm(n) {
    return Ou(n, !1, l0, m0, Sm)
}

function Em(n) {
    return Ou(n, !0, a0, g0, Tm)
}

function Ou(n, e, t, i, r) {
    if (!bt(n) || n.__v_raw && !(e && n.__v_isReactive)) return n;
    const s = r.get(n);
    if (s) return s;
    const o = y0(n);
    if (o === 0) return n;
    const a = new Proxy(n, o === 2 ? i : t);
    return r.set(n, a), a
}

function ss(n) {
    return hs(n) ? ss(n.__v_raw) : !!(n && n.__v_isReactive)
}

function hs(n) {
    return !!(n && n.__v_isReadonly)
}

function ka(n) {
    return !!(n && n.__v_isShallow)
}

function Am(n) {
    return ss(n) || hs(n)
}

function lt(n) {
    const e = n && n.__v_raw;
    return e ? lt(e) : n
}

function Rm(n) {
    return Ba(n, "__v_skip", !0), n
}
const ro = n => bt(n) ? hl(n) : n,
    Nu = n => bt(n) ? Em(n) : n;
class Cm {
    constructor(e, t, i, r) {
        this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Cu(() => e(this._value), () => Pa(this, 1), () => this.dep && _m(this.dep)), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = i
    }
    get value() {
        const e = lt(this);
        return (!e._cacheable || e.effect.dirty) && Bi(e._value, e._value = e.effect.run()) && Pa(e, 2), Pm(e), e.effect._dirtyLevel >= 1 && Pa(e, 1), e._value
    }
    set value(e) {
        this._setter(e)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(e) {
        this.effect.dirty = e
    }
}

function x0(n, e, t = !1) {
    let i, r;
    const s = $e(n);
    return s ? (i = n, r = An) : (i = n.get, r = n.set), new Cm(i, r, s || !r, t)
}

function Pm(n) {
    Ii && rr && (n = lt(n), mm(rr, n.dep || (n.dep = vm(() => n.dep = void 0, n instanceof Cm ? n : void 0))))
}

function Pa(n, e = 2, t) {
    n = lt(n);
    const i = n.dep;
    i && gm(i, e)
}

function fn(n) {
    return !!(n && n.__v_isRef === !0)
}

function M0(n) {
    return Lm(n, !1)
}

function b0(n) {
    return Lm(n, !0)
}

function Lm(n, e) {
    return fn(n) ? n : new S0(n, e)
}
class S0 {
    constructor(e, t) {
        this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : lt(e), this._value = t ? e : ro(e)
    }
    get value() {
        return Pm(this), this._value
    }
    set value(e) {
        const t = this.__v_isShallow || ka(e) || hs(e);
        e = t ? e : lt(e), Bi(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : ro(e), Pa(this, 2))
    }
}

function or(n) {
    return fn(n) ? n.value : n
}
const T0 = {
    get: (n, e, t) => or(Reflect.get(n, e, t)),
    set: (n, e, t, i) => {
        const r = n[e];
        return fn(r) && !fn(t) ? (r.value = t, !0) : Reflect.set(n, e, t, i)
    }
};

function Im(n) {
    return ss(n) ? n : new Proxy(n, T0)
}

function Di(n, e, t, i) {
    let r;
    try {
        r = i ? n(...i) : n()
    } catch (s) {
        fl(s, e, t)
    }
    return r
}

function Bn(n, e, t, i) {
    if ($e(n)) {
        const s = Di(n, e, t, i);
        return s && lm(s) && s.catch(o => {
            fl(o, e, t)
        }), s
    }
    const r = [];
    for (let s = 0; s < n.length; s++) r.push(Bn(n[s], e, t, i));
    return r
}

function fl(n, e, t, i = !0) {
    const r = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const o = e.proxy,
            a = `https://vuejs.org/error-reference/#runtime-${t}`;
        for (; s;) {
            const c = s.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](n, o, a) === !1) return
            }
            s = s.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            Di(l, null, 10, [n, o, a]);
            return
        }
    }
    w0(n, t, r, i)
}

function w0(n, e, t, i = !0) {
    console.error(n)
}
let so = !1,
    Jc = !1;
const Yt = [];
let $n = 0;
const os = [];
let wi = null,
    Zi = 0;
const Dm = Promise.resolve();
let Uu = null;

function za(n) {
    const e = Uu || Dm;
    return n ? e.then(this ? n.bind(this) : n) : e
}

function E0(n) {
    let e = $n + 1,
        t = Yt.length;
    for (; e < t;) {
        const i = e + t >>> 1,
            r = Yt[i],
            s = oo(r);
        s < n || s === n && r.pre ? e = i + 1 : t = i
    }
    return e
}

function Fu(n) {
    (!Yt.length || !Yt.includes(n, so && n.allowRecurse ? $n + 1 : $n)) && (n.id == null ? Yt.push(n) : Yt.splice(E0(n.id), 0, n), Om())
}

function Om() {
    !so && !Jc && (Jc = !0, Uu = Dm.then(Um))
}

function A0(n) {
    const e = Yt.indexOf(n);
    e > $n && Yt.splice(e, 1)
}

function R0(n) {
    Xe(n) ? os.push(...n) : (!wi || !wi.includes(n, n.allowRecurse ? Zi + 1 : Zi)) && os.push(n), Om()
}

function Jh(n, e, t = so ? $n + 1 : 0) {
    for (; t < Yt.length; t++) {
        const i = Yt[t];
        if (i && i.pre) {
            if (n && i.id !== n.uid) continue;
            Yt.splice(t, 1), t--, i()
        }
    }
}

function Nm(n) {
    if (os.length) {
        const e = [...new Set(os)].sort((t, i) => oo(t) - oo(i));
        if (os.length = 0, wi) {
            wi.push(...e);
            return
        }
        for (wi = e, Zi = 0; Zi < wi.length; Zi++) wi[Zi]();
        wi = null, Zi = 0
    }
}
const oo = n => n.id == null ? 1 / 0 : n.id,
    C0 = (n, e) => {
        const t = oo(n) - oo(e);
        if (t === 0) {
            if (n.pre && !e.pre) return -1;
            if (e.pre && !n.pre) return 1
        }
        return t
    };

function Um(n) {
    Jc = !1, so = !0, Yt.sort(C0);
    try {
        for ($n = 0; $n < Yt.length; $n++) {
            const e = Yt[$n];
            e && e.active !== !1 && Di(e, null, 14)
        }
    } finally {
        $n = 0, Yt.length = 0, Nm(), so = !1, Uu = null, (Yt.length || os.length) && Um()
    }
}

function P0(n, e, ...t) {
    if (n.isUnmounted) return;
    const i = n.vnode.props || yt;
    let r = t;
    const s = e.startsWith("update:"),
        o = s && e.slice(7);
    if (o && o in i) {
        const u = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: h,
                trim: f
            } = i[u] || yt;
        f && (r = t.map(d => Dt(d) ? d.trim() : d)), h && (r = t.map($_))
    }
    let a, l = i[a = Vl(e)] || i[a = Vl(Jn(e))];
    !l && s && (l = i[a = Vl(_r(e))]), l && Bn(l, n, 6, r);
    const c = i[a + "Once"];
    if (c) {
        if (!n.emitted) n.emitted = {};
        else if (n.emitted[a]) return;
        n.emitted[a] = !0, Bn(c, n, 6, r)
    }
}

function Fm(n, e, t = !1) {
    const i = e.emitsCache,
        r = i.get(n);
    if (r !== void 0) return r;
    const s = n.emits;
    let o = {},
        a = !1;
    if (!$e(n)) {
        const l = c => {
            const u = Fm(c, e, !0);
            u && (a = !0, Gt(o, u))
        };
        !t && e.mixins.length && e.mixins.forEach(l), n.extends && l(n.extends), n.mixins && n.mixins.forEach(l)
    }
    return !s && !a ? (bt(n) && i.set(n, null), null) : (Xe(s) ? s.forEach(l => o[l] = null) : Gt(o, s), bt(n) && i.set(n, o), o)
}

function dl(n, e) {
    return !n || !ol(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), it(n, e[0].toLowerCase() + e.slice(1)) || it(n, _r(e)) || it(n, e))
}
let kt = null,
    pl = null;

function Ga(n) {
    const e = kt;
    return kt = n, pl = n && n.type.__scopeId || null, e
}

function Zt(n) {
    pl = n
}

function Qt() {
    pl = null
}

function Kn(n, e = kt, t) {
    if (!e || n._n) return n;
    const i = (...r) => {
        i._d && cf(-1);
        const s = Ga(e);
        let o;
        try {
            o = n(...r)
        } finally {
            Ga(s), i._d && cf(1)
        }
        return o
    };
    return i._n = !0, i._c = !0, i._d = !0, i
}

function $l(n) {
    const {
        type: e,
        vnode: t,
        proxy: i,
        withProxy: r,
        props: s,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: u,
        renderCache: h,
        data: f,
        setupState: d,
        ctx: p,
        inheritAttrs: _
    } = n;
    let g, m;
    const y = Ga(n);
    try {
        if (t.shapeFlag & 4) {
            const x = r || i,
                C = x;
            g = Hn(u.call(C, x, h, s, d, f, p)), m = l
        } else {
            const x = e;
            g = Hn(x.length > 1 ? x(s, {
                attrs: l,
                slots: a,
                emit: c
            }) : x(s, null)), m = e.props ? l : L0(l)
        }
    } catch (x) {
        Ys.length = 0, fl(x, n, 1), g = ve(ki)
    }
    let v = g;
    if (m && _ !== !1) {
        const x = Object.keys(m),
            {
                shapeFlag: C
            } = v;
        x.length && C & 7 && (o && x.some(wu) && (m = I0(m, o)), v = fs(v, m))
    }
    return t.dirs && (v = fs(v), v.dirs = v.dirs ? v.dirs.concat(t.dirs) : t.dirs), t.transition && (v.transition = t.transition), g = v, Ga(y), g
}
const L0 = n => {
        let e;
        for (const t in n)(t === "class" || t === "style" || ol(t)) && ((e || (e = {}))[t] = n[t]);
        return e
    },
    I0 = (n, e) => {
        const t = {};
        for (const i in n)(!wu(i) || !(i.slice(9) in e)) && (t[i] = n[i]);
        return t
    };

function D0(n, e, t) {
    const {
        props: i,
        children: r,
        component: s
    } = n, {
        props: o,
        children: a,
        patchFlag: l
    } = e, c = s.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (t && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return i ? Zh(i, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                const f = u[h];
                if (o[f] !== i[f] && !dl(c, f)) return !0
            }
        }
    } else return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? o ? Zh(i, o, c) : !0 : !!o;
    return !1
}

function Zh(n, e, t) {
    const i = Object.keys(e);
    if (i.length !== Object.keys(n).length) return !0;
    for (let r = 0; r < i.length; r++) {
        const s = i[r];
        if (e[s] !== n[s] && !dl(t, s)) return !0
    }
    return !1
}

function O0({
    vnode: n,
    parent: e
}, t) {
    for (; e;) {
        const i = e.subTree;
        if (i.suspense && i.suspense.activeBranch === n && (i.el = n.el), i === n)(n = e.vnode).el = t, e = e.parent;
        else break
    }
}
const Bm = "components";

function He(n, e) {
    return U0(Bm, n, !0, e) || n
}
const N0 = Symbol.for("v-ndc");

function U0(n, e, t = !0, i = !1) {
    const r = kt || Kt;
    if (r) {
        const s = r.type;
        if (n === Bm) {
            const a = Lv(s, !1);
            if (a && (a === e || a === Jn(e) || a === cl(Jn(e)))) return s
        }
        const o = Qh(r[n] || s[n], e) || Qh(r.appContext[n], e);
        return !o && i ? s : o
    }
}

function Qh(n, e) {
    return n && (n[e] || n[Jn(e)] || n[cl(Jn(e))])
}
const F0 = n => n.__isSuspense;

function B0(n, e) {
    e && e.pendingBranch ? Xe(n) ? e.effects.push(...n) : e.effects.push(n) : R0(n)
}
const k0 = Symbol.for("v-scx"),
    z0 = () => pi(k0),
    Bo = {};

function La(n, e, t) {
    return km(n, e, t)
}

function km(n, e, {
    immediate: t,
    deep: i,
    flush: r,
    once: s,
    onTrack: o,
    onTrigger: a
} = yt) {
    if (e && s) {
        const S = e;
        e = (...R) => {
            S(...R), C()
        }
    }
    const l = Kt,
        c = S => i === !0 ? S : nr(S, i === !1 ? 1 : void 0);
    let u, h = !1,
        f = !1;
    if (fn(n) ? (u = () => n.value, h = ka(n)) : ss(n) ? (u = () => c(n), h = !0) : Xe(n) ? (f = !0, h = n.some(S => ss(S) || ka(S)), u = () => n.map(S => {
            if (fn(S)) return S.value;
            if (ss(S)) return c(S);
            if ($e(S)) return Di(S, l, 2)
        })) : $e(n) ? e ? u = () => Di(n, l, 2) : u = () => (d && d(), Bn(n, l, 3, [p])) : u = An, e && i) {
        const S = u;
        u = () => nr(S())
    }
    let d, p = S => {
            d = v.onStop = () => {
                Di(S, l, 4), d = v.onStop = void 0
            }
        },
        _;
    if (vl)
        if (p = An, e ? t && Bn(e, l, 3, [u(), f ? [] : void 0, p]) : u(), r === "sync") {
            const S = z0();
            _ = S.__watcherHandles || (S.__watcherHandles = [])
        } else return An;
    let g = f ? new Array(n.length).fill(Bo) : Bo;
    const m = () => {
        if (!(!v.active || !v.dirty))
            if (e) {
                const S = v.run();
                (i || h || (f ? S.some((R, F) => Bi(R, g[F])) : Bi(S, g))) && (d && d(), Bn(e, l, 3, [S, g === Bo ? void 0 : f && g[0] === Bo ? [] : g, p]), g = S)
            } else v.run()
    };
    m.allowRecurse = !!e;
    let y;
    r === "sync" ? y = m : r === "post" ? y = () => ln(m, l && l.suspense) : (m.pre = !0, l && (m.id = l.uid), y = () => Fu(m));
    const v = new Cu(u, An, y),
        x = e0(),
        C = () => {
            v.stop(), x && Eu(x.effects, v)
        };
    return e ? t ? m() : g = v.run() : r === "post" ? ln(v.run.bind(v), l && l.suspense) : v.run(), _ && _.push(C), C
}

function G0(n, e, t) {
    const i = this.proxy,
        r = Dt(n) ? n.includes(".") ? zm(i, n) : () => i[n] : n.bind(i, i);
    let s;
    $e(e) ? s = e : (s = e.handler, t = e);
    const o = To(this),
        a = km(r, s.bind(i), t);
    return o(), a
}

function zm(n, e) {
    const t = e.split(".");
    return () => {
        let i = n;
        for (let r = 0; r < t.length && i; r++) i = i[t[r]];
        return i
    }
}

function nr(n, e, t = 0, i) {
    if (!bt(n) || n.__v_skip) return n;
    if (e && e > 0) {
        if (t >= e) return n;
        t++
    }
    if (i = i || new Set, i.has(n)) return n;
    if (i.add(n), fn(n)) nr(n.value, e, t, i);
    else if (Xe(n))
        for (let r = 0; r < n.length; r++) nr(n[r], e, t, i);
    else if (am(n) || rs(n)) n.forEach(r => {
        nr(r, e, t, i)
    });
    else if ($s(n))
        for (const r in n) nr(n[r], e, t, i);
    return n
}

function V0(n, e) {
    if (kt === null) return n;
    const t = yl(kt) || kt.proxy,
        i = n.dirs || (n.dirs = []);
    for (let r = 0; r < e.length; r++) {
        let [s, o, a, l = yt] = e[r];
        s && ($e(s) && (s = {
            mounted: s,
            updated: s
        }), s.deep && nr(o), i.push({
            dir: s,
            instance: t,
            value: o,
            oldValue: void 0,
            arg: a,
            modifiers: l
        }))
    }
    return n
}

function Wi(n, e, t, i) {
    const r = n.dirs,
        s = e && e.dirs;
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[i];
        l && (vr(), Bn(l, t, 8, [n.el, a, n, e]), yr())
    }
}

function Gm(n, e) {
    return $e(n) ? Gt({
        name: n.name
    }, e, {
        setup: n
    }) : n
}
const Xs = n => !!n.type.__asyncLoader,
    Vm = n => n.type.__isKeepAlive;

function H0(n, e) {
    Hm(n, "a", e)
}

function W0(n, e) {
    Hm(n, "da", e)
}

function Hm(n, e, t = Kt) {
    const i = n.__wdc || (n.__wdc = () => {
        let r = t;
        for (; r;) {
            if (r.isDeactivated) return;
            r = r.parent
        }
        return n()
    });
    if (ml(e, i, t), t) {
        let r = t.parent;
        for (; r && r.parent;) Vm(r.parent.vnode) && $0(i, e, t, r), r = r.parent
    }
}

function $0(n, e, t, i) {
    const r = ml(e, n, i, !0);
    Wm(() => {
        Eu(i[e], r)
    }, t)
}

function ml(n, e, t = Kt, i = !1) {
    if (t) {
        const r = t[n] || (t[n] = []),
            s = e.__weh || (e.__weh = (...o) => {
                if (t.isUnmounted) return;
                vr();
                const a = To(t),
                    l = Bn(e, t, n, o);
                return a(), yr(), l
            });
        return i ? r.unshift(s) : r.push(s), s
    }
}
const gi = n => (e, t = Kt) => (!vl || n === "sp") && ml(n, (...i) => e(...i), t),
    X0 = gi("bm"),
    q0 = gi("m"),
    Y0 = gi("bu"),
    K0 = gi("u"),
    j0 = gi("bum"),
    Wm = gi("um"),
    J0 = gi("sp"),
    Z0 = gi("rtg"),
    Q0 = gi("rtc");

function ev(n, e = Kt) {
    ml("ec", n, e)
}

function jn(n, e, t, i) {
    let r;
    const s = t && t[i];
    if (Xe(n) || Dt(n)) {
        r = new Array(n.length);
        for (let o = 0, a = n.length; o < a; o++) r[o] = e(n[o], o, void 0, s && s[o])
    } else if (typeof n == "number") {
        r = new Array(n);
        for (let o = 0; o < n; o++) r[o] = e(o + 1, o, void 0, s && s[o])
    } else if (bt(n))
        if (n[Symbol.iterator]) r = Array.from(n, (o, a) => e(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(n);
            r = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                r[a] = e(n[c], c, a, s && s[a])
            }
        }
    else r = [];
    return t && (t[i] = r), r
}

function Bu(n, e, t = {}, i, r) {
    if (kt.isCE || kt.parent && Xs(kt.parent) && kt.parent.isCE) return e !== "default" && (t.name = e), ve("slot", t, i && i());
    let s = n[e];
    s && s._c && (s._d = !1), be();
    const o = s && $m(s(t)),
        a = Jt(Et, {
            key: t.key || o && o.key || `_${e}`
        }, o || (i ? i() : []), o && n._ === 1 ? 64 : -2);
    return !r && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a
}

function $m(n) {
    return n.some(e => Wa(e) ? !(e.type === ki || e.type === Et && !$m(e.children)) : !0) ? n : null
}
const Zc = n => n ? ig(n) ? yl(n) || n.proxy : Zc(n.parent) : null,
    qs = Gt(Object.create(null), {
        $: n => n,
        $el: n => n.vnode.el,
        $data: n => n.data,
        $props: n => n.props,
        $attrs: n => n.attrs,
        $slots: n => n.slots,
        $refs: n => n.refs,
        $parent: n => Zc(n.parent),
        $root: n => Zc(n.root),
        $emit: n => n.emit,
        $options: n => ku(n),
        $forceUpdate: n => n.f || (n.f = () => {
            n.effect.dirty = !0, Fu(n.update)
        }),
        $nextTick: n => n.n || (n.n = za.bind(n.proxy)),
        $watch: n => G0.bind(n)
    }),
    Xl = (n, e) => n !== yt && !n.__isScriptSetup && it(n, e),
    tv = {
        get({
            _: n
        }, e) {
            const {
                ctx: t,
                setupState: i,
                data: r,
                props: s,
                accessCache: o,
                type: a,
                appContext: l
            } = n;
            let c;
            if (e[0] !== "$") {
                const d = o[e];
                if (d !== void 0) switch (d) {
                case 1:
                    return i[e];
                case 2:
                    return r[e];
                case 4:
                    return t[e];
                case 3:
                    return s[e]
                } else {
                    if (Xl(i, e)) return o[e] = 1, i[e];
                    if (r !== yt && it(r, e)) return o[e] = 2, r[e];
                    if ((c = n.propsOptions[0]) && it(c, e)) return o[e] = 3, s[e];
                    if (t !== yt && it(t, e)) return o[e] = 4, t[e];
                    Qc && (o[e] = 0)
                }
            }
            const u = qs[e];
            let h, f;
            if (u) return e === "$attrs" && hn(n, "get", e), u(n);
            if ((h = a.__cssModules) && (h = h[e])) return h;
            if (t !== yt && it(t, e)) return o[e] = 4, t[e];
            if (f = l.config.globalProperties, it(f, e)) return f[e]
        },
        set({
            _: n
        }, e, t) {
            const {
                data: i,
                setupState: r,
                ctx: s
            } = n;
            return Xl(r, e) ? (r[e] = t, !0) : i !== yt && it(i, e) ? (i[e] = t, !0) : it(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (s[e] = t, !0)
        },
        has({
            _: {
                data: n,
                setupState: e,
                accessCache: t,
                ctx: i,
                appContext: r,
                propsOptions: s
            }
        }, o) {
            let a;
            return !!t[o] || n !== yt && it(n, o) || Xl(e, o) || (a = s[0]) && it(a, o) || it(i, o) || it(qs, o) || it(r.config.globalProperties, o)
        },
        defineProperty(n, e, t) {
            return t.get != null ? n._.accessCache[e] = 0 : it(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t)
        }
    };

function ef(n) {
    return Xe(n) ? n.reduce((e, t) => (e[t] = null, e), {}) : n
}
let Qc = !0;

function nv(n) {
    const e = ku(n),
        t = n.proxy,
        i = n.ctx;
    Qc = !1, e.beforeCreate && tf(e.beforeCreate, n, "bc");
    const {
        data: r,
        computed: s,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: u,
        beforeMount: h,
        mounted: f,
        beforeUpdate: d,
        updated: p,
        activated: _,
        deactivated: g,
        beforeDestroy: m,
        beforeUnmount: y,
        destroyed: v,
        unmounted: x,
        render: C,
        renderTracked: S,
        renderTriggered: R,
        errorCaptured: F,
        serverPrefetch: T,
        expose: A,
        inheritAttrs: G,
        components: ee,
        directives: he,
        filters: B
    } = e;
    if (c && iv(c, i, null), o)
        for (const j in o) {
            const J = o[j];
            $e(J) && (i[j] = J.bind(t))
        }
    if (r) {
        const j = r.call(t, t);
        bt(j) && (n.data = hl(j))
    }
    if (Qc = !0, s)
        for (const j in s) {
            const J = s[j],
                ie = $e(J) ? J.bind(t, t) : $e(J.get) ? J.get.bind(t, t) : An,
                pe = !$e(J) && $e(J.set) ? J.set.bind(t) : An,
                de = Nn({
                    get: ie,
                    set: pe
                });
            Object.defineProperty(i, j, {
                enumerable: !0,
                configurable: !0,
                get: () => de.value,
                set: xe => de.value = xe
            })
        }
    if (a)
        for (const j in a) Xm(a[j], i, t, j);
    if (l) {
        const j = $e(l) ? l.call(t) : l;
        Reflect.ownKeys(j).forEach(J => {
            Ia(J, j[J])
        })
    }
    u && tf(u, n, "c");

    function q(j, J) {
        Xe(J) ? J.forEach(ie => j(ie.bind(t))) : J && j(J.bind(t))
    }
    if (q(X0, h), q(q0, f), q(Y0, d), q(K0, p), q(H0, _), q(W0, g), q(ev, F), q(Q0, S), q(Z0, R), q(j0, y), q(Wm, x), q(J0, T), Xe(A))
        if (A.length) {
            const j = n.exposed || (n.exposed = {});
            A.forEach(J => {
                Object.defineProperty(j, J, {
                    get: () => t[J],
                    set: ie => t[J] = ie
                })
            })
        } else n.exposed || (n.exposed = {});
    C && n.render === An && (n.render = C), G != null && (n.inheritAttrs = G), ee && (n.components = ee), he && (n.directives = he)
}

function iv(n, e, t = An) {
    Xe(n) && (n = eu(n));
    for (const i in n) {
        const r = n[i];
        let s;
        bt(r) ? "default" in r ? s = pi(r.from || i, r.default, !0) : s = pi(r.from || i) : s = pi(r), fn(s) ? Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : e[i] = s
    }
}

function tf(n, e, t) {
    Bn(Xe(n) ? n.map(i => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}

function Xm(n, e, t, i) {
    const r = i.includes(".") ? zm(t, i) : () => t[i];
    if (Dt(n)) {
        const s = e[n];
        $e(s) && La(r, s)
    } else if ($e(n)) La(r, n.bind(t));
    else if (bt(n))
        if (Xe(n)) n.forEach(s => Xm(s, e, t, i));
        else {
            const s = $e(n.handler) ? n.handler.bind(t) : e[n.handler];
            $e(s) && La(r, s, n)
        }
}

function ku(n) {
    const e = n.type,
        {
            mixins: t,
            extends: i
        } = e,
        {
            mixins: r,
            optionsCache: s,
            config: {
                optionMergeStrategies: o
            }
        } = n.appContext,
        a = s.get(e);
    let l;
    return a ? l = a : !r.length && !t && !i ? l = e : (l = {}, r.length && r.forEach(c => Va(l, c, o, !0)), Va(l, e, o)), bt(e) && s.set(e, l), l
}

function Va(n, e, t, i = !1) {
    const {
        mixins: r,
        extends: s
    } = e;
    s && Va(n, s, t, !0), r && r.forEach(o => Va(n, o, t, !0));
    for (const o in e)
        if (!(i && o === "expose")) {
            const a = rv[o] || t && t[o];
            n[o] = a ? a(n[o], e[o]) : e[o]
        } return n
}
const rv = {
    data: nf,
    props: rf,
    emits: rf,
    methods: Hs,
    computed: Hs,
    beforeCreate: rn,
    created: rn,
    beforeMount: rn,
    mounted: rn,
    beforeUpdate: rn,
    updated: rn,
    beforeDestroy: rn,
    beforeUnmount: rn,
    destroyed: rn,
    unmounted: rn,
    activated: rn,
    deactivated: rn,
    errorCaptured: rn,
    serverPrefetch: rn,
    components: Hs,
    directives: Hs,
    watch: ov,
    provide: nf,
    inject: sv
};

function nf(n, e) {
    return e ? n ? function () {
        return Gt($e(n) ? n.call(this, this) : n, $e(e) ? e.call(this, this) : e)
    } : e : n
}

function sv(n, e) {
    return Hs(eu(n), eu(e))
}

function eu(n) {
    if (Xe(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++) e[n[t]] = n[t];
        return e
    }
    return n
}

function rn(n, e) {
    return n ? [...new Set([].concat(n, e))] : e
}

function Hs(n, e) {
    return n ? Gt(Object.create(null), n, e) : e
}

function rf(n, e) {
    return n ? Xe(n) && Xe(e) ? [...new Set([...n, ...e])] : Gt(Object.create(null), ef(n), ef(e ?? {})) : e
}

function ov(n, e) {
    if (!n) return e;
    if (!e) return n;
    const t = Gt(Object.create(null), n);
    for (const i in e) t[i] = rn(n[i], e[i]);
    return t
}

function qm() {
    return {
        app: null,
        config: {
            isNativeTag: z_,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let av = 0;

function lv(n, e) {
    return function (i, r = null) {
        $e(i) || (i = Gt({}, i)), r != null && !bt(r) && (r = null);
        const s = qm(),
            o = new WeakSet;
        let a = !1;
        const l = s.app = {
            _uid: av++,
            _component: i,
            _props: r,
            _container: null,
            _context: s,
            _instance: null,
            version: Dv,
            get config() {
                return s.config
            },
            set config(c) {},
            use(c, ...u) {
                return o.has(c) || (c && $e(c.install) ? (o.add(c), c.install(l, ...u)) : $e(c) && (o.add(c), c(l, ...u))), l
            },
            mixin(c) {
                return s.mixins.includes(c) || s.mixins.push(c), l
            },
            component(c, u) {
                return u ? (s.components[c] = u, l) : s.components[c]
            },
            directive(c, u) {
                return u ? (s.directives[c] = u, l) : s.directives[c]
            },
            mount(c, u, h) {
                if (!a) {
                    const f = ve(i, r);
                    return f.appContext = s, h === !0 ? h = "svg" : h === !1 && (h = void 0), u && e ? e(f, c) : n(f, c, h), a = !0, l._container = c, c.__vue_app__ = l, yl(f.component) || f.component.proxy
                }
            },
            unmount() {
                a && (n(null, l._container), delete l._container.__vue_app__)
            },
            provide(c, u) {
                return s.provides[c] = u, l
            },
            runWithContext(c) {
                Ha = l;
                try {
                    return c()
                } finally {
                    Ha = null
                }
            }
        };
        return l
    }
}
let Ha = null;

function Ia(n, e) {
    if (Kt) {
        let t = Kt.provides;
        const i = Kt.parent && Kt.parent.provides;
        i === t && (t = Kt.provides = Object.create(i)), t[n] = e
    }
}

function pi(n, e, t = !1) {
    const i = Kt || kt;
    if (i || Ha) {
        const r = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : Ha._context.provides;
        if (r && n in r) return r[n];
        if (arguments.length > 1) return t && $e(e) ? e.call(i && i.proxy) : e
    }
}

function cv(n, e, t, i = !1) {
    const r = {},
        s = {};
    Ba(s, _l, 1), n.propsDefaults = Object.create(null), Ym(n, e, r, s);
    for (const o in n.propsOptions[0]) o in r || (r[o] = void 0);
    t ? n.props = i ? r : wm(r) : n.type.props ? n.props = r : n.props = s, n.attrs = s
}

function uv(n, e, t, i) {
    const {
        props: r,
        attrs: s,
        vnode: {
            patchFlag: o
        }
    } = n, a = lt(r), [l] = n.propsOptions;
    let c = !1;
    if ((i || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = n.vnode.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                let f = u[h];
                if (dl(n.emitsOptions, f)) continue;
                const d = e[f];
                if (l)
                    if (it(s, f)) d !== s[f] && (s[f] = d, c = !0);
                    else {
                        const p = Jn(f);
                        r[p] = tu(l, a, p, d, n, !1)
                    }
                else d !== s[f] && (s[f] = d, c = !0)
            }
        }
    } else {
        Ym(n, e, r, s) && (c = !0);
        let u;
        for (const h in a)(!e || !it(e, h) && ((u = _r(h)) === h || !it(e, u))) && (l ? t && (t[h] !== void 0 || t[u] !== void 0) && (r[h] = tu(l, a, h, void 0, n, !0)) : delete r[h]);
        if (s !== a)
            for (const h in s)(!e || !it(e, h)) && (delete s[h], c = !0)
    }
    c && di(n, "set", "$attrs")
}

function Ym(n, e, t, i) {
    const [r, s] = n.propsOptions;
    let o = !1,
        a;
    if (e)
        for (let l in e) {
            if (Ca(l)) continue;
            const c = e[l];
            let u;
            r && it(r, u = Jn(l)) ? !s || !s.includes(u) ? t[u] = c : (a || (a = {}))[u] = c : dl(n.emitsOptions, l) || (!(l in i) || c !== i[l]) && (i[l] = c, o = !0)
        }
    if (s) {
        const l = lt(t),
            c = a || yt;
        for (let u = 0; u < s.length; u++) {
            const h = s[u];
            t[h] = tu(r, l, h, c[h], n, !it(c, h))
        }
    }
    return o
}

function tu(n, e, t, i, r, s) {
    const o = n[t];
    if (o != null) {
        const a = it(o, "default");
        if (a && i === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && $e(l)) {
                const {
                    propsDefaults: c
                } = r;
                if (t in c) i = c[t];
                else {
                    const u = To(r);
                    i = c[t] = l.call(null, e), u()
                }
            } else i = l
        }
        o[0] && (s && !a ? i = !1 : o[1] && (i === "" || i === _r(t)) && (i = !0))
    }
    return i
}

function Km(n, e, t = !1) {
    const i = e.propsCache,
        r = i.get(n);
    if (r) return r;
    const s = n.props,
        o = {},
        a = [];
    let l = !1;
    if (!$e(n)) {
        const u = h => {
            l = !0;
            const [f, d] = Km(h, e, !0);
            Gt(o, f), d && a.push(...d)
        };
        !t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u)
    }
    if (!s && !l) return bt(n) && i.set(n, is), is;
    if (Xe(s))
        for (let u = 0; u < s.length; u++) {
            const h = Jn(s[u]);
            sf(h) && (o[h] = yt)
        } else if (s)
            for (const u in s) {
                const h = Jn(u);
                if (sf(h)) {
                    const f = s[u],
                        d = o[h] = Xe(f) || $e(f) ? {
                            type: f
                        } : Gt({}, f);
                    if (d) {
                        const p = lf(Boolean, d.type),
                            _ = lf(String, d.type);
                        d[0] = p > -1, d[1] = _ < 0 || p < _, (p > -1 || it(d, "default")) && a.push(h)
                    }
                }
            }
    const c = [o, a];
    return bt(n) && i.set(n, c), c
}

function sf(n) {
    return n[0] !== "$"
}

function of (n) {
    const e = n && n.toString().match(/^\s*(function|class) (\w+)/);
    return e ? e[2] : n === null ? "null" : ""
}

function af(n, e) {
    return of(n) === of (e)
}

function lf(n, e) {
    return Xe(e) ? e.findIndex(t => af(t, n)) : $e(e) && af(e, n) ? 0 : -1
}
const jm = n => n[0] === "_" || n === "$stable",
    zu = n => Xe(n) ? n.map(Hn) : [Hn(n)],
    hv = (n, e, t) => {
        if (e._n) return e;
        const i = Kn((...r) => zu(e(...r)), t);
        return i._c = !1, i
    },
    Jm = (n, e, t) => {
        const i = n._ctx;
        for (const r in n) {
            if (jm(r)) continue;
            const s = n[r];
            if ($e(s)) e[r] = hv(r, s, i);
            else if (s != null) {
                const o = zu(s);
                e[r] = () => o
            }
        }
    },
    Zm = (n, e) => {
        const t = zu(e);
        n.slots.default = () => t
    },
    fv = (n, e) => {
        if (n.vnode.shapeFlag & 32) {
            const t = e._;
            t ? (n.slots = lt(e), Ba(e, "_", t)) : Jm(e, n.slots = {})
        } else n.slots = {}, e && Zm(n, e);
        Ba(n.slots, _l, 1)
    },
    dv = (n, e, t) => {
        const {
            vnode: i,
            slots: r
        } = n;
        let s = !0,
            o = yt;
        if (i.shapeFlag & 32) {
            const a = e._;
            a ? t && a === 1 ? s = !1 : (Gt(r, e), !t && a === 1 && delete r._) : (s = !e.$stable, Jm(e, r)), o = e
        } else e && (Zm(n, e), o = {
            default: 1
        });
        if (s)
            for (const a in r) !jm(a) && o[a] == null && delete r[a]
    };

function nu(n, e, t, i, r = !1) {
    if (Xe(n)) {
        n.forEach((f, d) => nu(f, e && (Xe(e) ? e[d] : e), t, i, r));
        return
    }
    if (Xs(i) && !r) return;
    const s = i.shapeFlag & 4 ? yl(i.component) || i.component.proxy : i.el,
        o = r ? null : s,
        {
            i: a,
            r: l
        } = n,
        c = e && e.r,
        u = a.refs === yt ? a.refs = {} : a.refs,
        h = a.setupState;
    if (c != null && c !== l && (Dt(c) ? (u[c] = null, it(h, c) && (h[c] = null)) : fn(c) && (c.value = null)), $e(l)) Di(l, a, 12, [o, u]);
    else {
        const f = Dt(l),
            d = fn(l),
            p = n.f;
        if (f || d) {
            const _ = () => {
                if (p) {
                    const g = f ? it(h, l) ? h[l] : u[l] : l.value;
                    r ? Xe(g) && Eu(g, s) : Xe(g) ? g.includes(s) || g.push(s) : f ? (u[l] = [s], it(h, l) && (h[l] = u[l])) : (l.value = [s], n.k && (u[n.k] = l.value))
                } else f ? (u[l] = o, it(h, l) && (h[l] = o)) : d && (l.value = o, n.k && (u[n.k] = o))
            };
            r || p ? _() : (_.id = -1, ln(_, t))
        }
    }
}
const ln = B0;

function pv(n) {
    return mv(n)
}

function mv(n, e) {
    const t = um();
    t.__VUE__ = !0;
    const {
        insert: i,
        remove: r,
        patchProp: s,
        createElement: o,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: h,
        nextSibling: f,
        setScopeId: d = An,
        insertStaticContent: p
    } = n, _ = (w, E, N, U = null, W = null, Y = null, b = void 0, M = null, D = !!E.dynamicChildren) => {
        if (w === E) return;
        w && !Rs(w, E) && (U = H(w), xe(w, W, Y, !0), w = null), E.patchFlag === -2 && (D = !1, E.dynamicChildren = null);
        const {
            type: z,
            ref: $,
            shapeFlag: K
        } = E;
        switch (z) {
        case gl:
            g(w, E, N, U);
            break;
        case ki:
            m(w, E, N, U);
            break;
        case Da:
            w == null && y(E, N, U, b);
            break;
        case Et:
            ee(w, E, N, U, W, Y, b, M, D);
            break;
        default:
            K & 1 ? C(w, E, N, U, W, Y, b, M, D) : K & 6 ? he(w, E, N, U, W, Y, b, M, D) : (K & 64 || K & 128) && z.process(w, E, N, U, W, Y, b, M, D, le)
        }
        $ != null && W && nu($, w && w.ref, Y, E || w, !E)
    }, g = (w, E, N, U) => {
        if (w == null) i(E.el = a(E.children), N, U);
        else {
            const W = E.el = w.el;
            E.children !== w.children && c(W, E.children)
        }
    }, m = (w, E, N, U) => {
        w == null ? i(E.el = l(E.children || ""), N, U) : E.el = w.el
    }, y = (w, E, N, U) => {
        [w.el, w.anchor] = p(w.children, E, N, U, w.el, w.anchor)
    }, v = ({
        el: w,
        anchor: E
    }, N, U) => {
        let W;
        for (; w && w !== E;) W = f(w), i(w, N, U), w = W;
        i(E, N, U)
    }, x = ({
        el: w,
        anchor: E
    }) => {
        let N;
        for (; w && w !== E;) N = f(w), r(w), w = N;
        r(E)
    }, C = (w, E, N, U, W, Y, b, M, D) => {
        E.type === "svg" ? b = "svg" : E.type === "math" && (b = "mathml"), w == null ? S(E, N, U, W, Y, b, M, D) : T(w, E, W, Y, b, M, D)
    }, S = (w, E, N, U, W, Y, b, M) => {
        let D, z;
        const {
            props: $,
            shapeFlag: K,
            transition: fe,
            dirs: se
        } = w;
        if (D = w.el = o(w.type, Y, $ && $.is, $), K & 8 ? u(D, w.children) : K & 16 && F(w.children, D, null, U, W, ql(w, Y), b, M), se && Wi(w, null, U, "created"), R(D, w, w.scopeId, b, U), $) {
            for (const Ee in $) Ee !== "value" && !Ca(Ee) && s(D, Ee, null, $[Ee], Y, w.children, U, W, Pe);
            "value" in $ && s(D, "value", null, $.value, Y), (z = $.onVnodeBeforeMount) && Gn(z, U, w)
        }
        se && Wi(w, null, U, "beforeMount");
        const ge = gv(W, fe);
        ge && fe.beforeEnter(D), i(D, E, N), ((z = $ && $.onVnodeMounted) || ge || se) && ln(() => {
            z && Gn(z, U, w), ge && fe.enter(D), se && Wi(w, null, U, "mounted")
        }, W)
    }, R = (w, E, N, U, W) => {
        if (N && d(w, N), U)
            for (let Y = 0; Y < U.length; Y++) d(w, U[Y]);
        if (W) {
            let Y = W.subTree;
            if (E === Y) {
                const b = W.vnode;
                R(w, b, b.scopeId, b.slotScopeIds, W.parent)
            }
        }
    }, F = (w, E, N, U, W, Y, b, M, D = 0) => {
        for (let z = D; z < w.length; z++) {
            const $ = w[z] = M ? Ei(w[z]) : Hn(w[z]);
            _(null, $, E, N, U, W, Y, b, M)
        }
    }, T = (w, E, N, U, W, Y, b) => {
        const M = E.el = w.el;
        let {
            patchFlag: D,
            dynamicChildren: z,
            dirs: $
        } = E;
        D |= w.patchFlag & 16;
        const K = w.props || yt,
            fe = E.props || yt;
        let se;
        if (N && $i(N, !1), (se = fe.onVnodeBeforeUpdate) && Gn(se, N, E, w), $ && Wi(E, w, N, "beforeUpdate"), N && $i(N, !0), z ? A(w.dynamicChildren, z, M, N, U, ql(E, W), Y) : b || J(w, E, M, null, N, U, ql(E, W), Y, !1), D > 0) {
            if (D & 16) G(M, E, K, fe, N, U, W);
            else if (D & 2 && K.class !== fe.class && s(M, "class", null, fe.class, W), D & 4 && s(M, "style", K.style, fe.style, W), D & 8) {
                const ge = E.dynamicProps;
                for (let Ee = 0; Ee < ge.length; Ee++) {
                    const De = ge[Ee],
                        oe = K[De],
                        Be = fe[De];
                    (Be !== oe || De === "value") && s(M, De, oe, Be, W, w.children, N, U, Pe)
                }
            }
            D & 1 && w.children !== E.children && u(M, E.children)
        } else !b && z == null && G(M, E, K, fe, N, U, W);
        ((se = fe.onVnodeUpdated) || $) && ln(() => {
            se && Gn(se, N, E, w), $ && Wi(E, w, N, "updated")
        }, U)
    }, A = (w, E, N, U, W, Y, b) => {
        for (let M = 0; M < E.length; M++) {
            const D = w[M],
                z = E[M],
                $ = D.el && (D.type === Et || !Rs(D, z) || D.shapeFlag & 70) ? h(D.el) : N;
            _(D, z, $, null, U, W, Y, b, !0)
        }
    }, G = (w, E, N, U, W, Y, b) => {
        if (N !== U) {
            if (N !== yt)
                for (const M in N) !Ca(M) && !(M in U) && s(w, M, N[M], null, b, E.children, W, Y, Pe);
            for (const M in U) {
                if (Ca(M)) continue;
                const D = U[M],
                    z = N[M];
                D !== z && M !== "value" && s(w, M, z, D, b, E.children, W, Y, Pe)
            }
            "value" in U && s(w, "value", N.value, U.value, b)
        }
    }, ee = (w, E, N, U, W, Y, b, M, D) => {
        const z = E.el = w ? w.el : a(""),
            $ = E.anchor = w ? w.anchor : a("");
        let {
            patchFlag: K,
            dynamicChildren: fe,
            slotScopeIds: se
        } = E;
        se && (M = M ? M.concat(se) : se), w == null ? (i(z, N, U), i($, N, U), F(E.children || [], N, $, W, Y, b, M, D)) : K > 0 && K & 64 && fe && w.dynamicChildren ? (A(w.dynamicChildren, fe, N, W, Y, b, M), (E.key != null || W && E === W.subTree) && Qm(w, E, !0)) : J(w, E, N, $, W, Y, b, M, D)
    }, he = (w, E, N, U, W, Y, b, M, D) => {
        E.slotScopeIds = M, w == null ? E.shapeFlag & 512 ? W.ctx.activate(E, N, U, b, D) : B(E, N, U, W, Y, b, D) : V(w, E, D)
    }, B = (w, E, N, U, W, Y, b) => {
        const M = w.component = Ev(w, U, W);
        if (Vm(w) && (M.ctx.renderer = le), Av(M), M.asyncDep) {
            if (W && W.registerDep(M, q), !w.el) {
                const D = M.subTree = ve(ki);
                m(null, D, E, N)
            }
        } else q(M, w, E, N, W, Y, b)
    }, V = (w, E, N) => {
        const U = E.component = w.component;
        if (D0(w, E, N))
            if (U.asyncDep && !U.asyncResolved) {
                j(U, E, N);
                return
            } else U.next = E, A0(U.update), U.effect.dirty = !0, U.update();
        else E.el = w.el, U.vnode = E
    }, q = (w, E, N, U, W, Y, b) => {
        const M = () => {
                if (w.isMounted) {
                    let {
                        next: $,
                        bu: K,
                        u: fe,
                        parent: se,
                        vnode: ge
                    } = w; {
                        const O = eg(w);
                        if (O) {
                            $ && ($.el = ge.el, j(w, $, b)), O.asyncDep.then(() => {
                                w.isUnmounted || M()
                            });
                            return
                        }
                    }
                    let Ee = $,
                        De;
                    $i(w, !1), $ ? ($.el = ge.el, j(w, $, b)) : $ = ge, K && Hl(K), (De = $.props && $.props.onVnodeBeforeUpdate) && Gn(De, se, $, ge), $i(w, !0);
                    const oe = $l(w),
                        Be = w.subTree;
                    w.subTree = oe, _(Be, oe, h(Be.el), H(Be), w, W, Y), $.el = oe.el, Ee === null && O0(w, oe.el), fe && ln(fe, W), (De = $.props && $.props.onVnodeUpdated) && ln(() => Gn(De, se, $, ge), W)
                } else {
                    let $;
                    const {
                        el: K,
                        props: fe
                    } = E, {
                        bm: se,
                        m: ge,
                        parent: Ee
                    } = w, De = Xs(E);
                    if ($i(w, !1), se && Hl(se), !De && ($ = fe && fe.onVnodeBeforeMount) && Gn($, Ee, E), $i(w, !0), K && I) {
                        const oe = () => {
                            w.subTree = $l(w), I(K, w.subTree, w, W, null)
                        };
                        De ? E.type.__asyncLoader().then(() => !w.isUnmounted && oe()) : oe()
                    } else {
                        const oe = w.subTree = $l(w);
                        _(null, oe, N, U, w, W, Y), E.el = oe.el
                    }
                    if (ge && ln(ge, W), !De && ($ = fe && fe.onVnodeMounted)) {
                        const oe = E;
                        ln(() => Gn($, Ee, oe), W)
                    }(E.shapeFlag & 256 || Ee && Xs(Ee.vnode) && Ee.vnode.shapeFlag & 256) && w.a && ln(w.a, W), w.isMounted = !0, E = N = U = null
                }
            },
            D = w.effect = new Cu(M, An, () => Fu(z), w.scope),
            z = w.update = () => {
                D.dirty && D.run()
            };
        z.id = w.uid, $i(w, !0), z()
    }, j = (w, E, N) => {
        E.component = w;
        const U = w.vnode.props;
        w.vnode = E, w.next = null, uv(w, E.props, U, N), dv(w, E.children, N), vr(), Jh(w), yr()
    }, J = (w, E, N, U, W, Y, b, M, D = !1) => {
        const z = w && w.children,
            $ = w ? w.shapeFlag : 0,
            K = E.children,
            {
                patchFlag: fe,
                shapeFlag: se
            } = E;
        if (fe > 0) {
            if (fe & 128) {
                pe(z, K, N, U, W, Y, b, M, D);
                return
            } else if (fe & 256) {
                ie(z, K, N, U, W, Y, b, M, D);
                return
            }
        }
        se & 8 ? ($ & 16 && Pe(z, W, Y), K !== z && u(N, K)) : $ & 16 ? se & 16 ? pe(z, K, N, U, W, Y, b, M, D) : Pe(z, W, Y, !0) : ($ & 8 && u(N, ""), se & 16 && F(K, N, U, W, Y, b, M, D))
    }, ie = (w, E, N, U, W, Y, b, M, D) => {
        w = w || is, E = E || is;
        const z = w.length,
            $ = E.length,
            K = Math.min(z, $);
        let fe;
        for (fe = 0; fe < K; fe++) {
            const se = E[fe] = D ? Ei(E[fe]) : Hn(E[fe]);
            _(w[fe], se, N, null, W, Y, b, M, D)
        }
        z > $ ? Pe(w, W, Y, !0, !1, K) : F(E, N, U, W, Y, b, M, D, K)
    }, pe = (w, E, N, U, W, Y, b, M, D) => {
        let z = 0;
        const $ = E.length;
        let K = w.length - 1,
            fe = $ - 1;
        for (; z <= K && z <= fe;) {
            const se = w[z],
                ge = E[z] = D ? Ei(E[z]) : Hn(E[z]);
            if (Rs(se, ge)) _(se, ge, N, null, W, Y, b, M, D);
            else break;
            z++
        }
        for (; z <= K && z <= fe;) {
            const se = w[K],
                ge = E[fe] = D ? Ei(E[fe]) : Hn(E[fe]);
            if (Rs(se, ge)) _(se, ge, N, null, W, Y, b, M, D);
            else break;
            K--, fe--
        }
        if (z > K) {
            if (z <= fe) {
                const se = fe + 1,
                    ge = se < $ ? E[se].el : U;
                for (; z <= fe;) _(null, E[z] = D ? Ei(E[z]) : Hn(E[z]), N, ge, W, Y, b, M, D), z++
            }
        } else if (z > fe)
            for (; z <= K;) xe(w[z], W, Y, !0), z++;
        else {
            const se = z,
                ge = z,
                Ee = new Map;
            for (z = ge; z <= fe; z++) {
                const Le = E[z] = D ? Ei(E[z]) : Hn(E[z]);
                Le.key != null && Ee.set(Le.key, z)
            }
            let De, oe = 0;
            const Be = fe - ge + 1;
            let O = !1,
                _e = 0;
            const Me = new Array(Be);
            for (z = 0; z < Be; z++) Me[z] = 0;
            for (z = se; z <= K; z++) {
                const Le = w[z];
                if (oe >= Be) {
                    xe(Le, W, Y, !0);
                    continue
                }
                let ze;
                if (Le.key != null) ze = Ee.get(Le.key);
                else
                    for (De = ge; De <= fe; De++)
                        if (Me[De - ge] === 0 && Rs(Le, E[De])) {
                            ze = De;
                            break
                        } ze === void 0 ? xe(Le, W, Y, !0) : (Me[ze - ge] = z + 1, ze >= _e ? _e = ze : O = !0, _(Le, E[ze], N, null, W, Y, b, M, D), oe++)
            }
            const ye = O ? _v(Me) : is;
            for (De = ye.length - 1, z = Be - 1; z >= 0; z--) {
                const Le = ge + z,
                    ze = E[Le],
                    et = Le + 1 < $ ? E[Le + 1].el : U;
                Me[z] === 0 ? _(null, ze, N, et, W, Y, b, M, D) : O && (De < 0 || z !== ye[De] ? de(ze, N, et, 2) : De--)
            }
        }
    }, de = (w, E, N, U, W = null) => {
        const {
            el: Y,
            type: b,
            transition: M,
            children: D,
            shapeFlag: z
        } = w;
        if (z & 6) {
            de(w.component.subTree, E, N, U);
            return
        }
        if (z & 128) {
            w.suspense.move(E, N, U);
            return
        }
        if (z & 64) {
            b.move(w, E, N, le);
            return
        }
        if (b === Et) {
            i(Y, E, N);
            for (let K = 0; K < D.length; K++) de(D[K], E, N, U);
            i(w.anchor, E, N);
            return
        }
        if (b === Da) {
            v(w, E, N);
            return
        }
        if (U !== 2 && z & 1 && M)
            if (U === 0) M.beforeEnter(Y), i(Y, E, N), ln(() => M.enter(Y), W);
            else {
                const {
                    leave: K,
                    delayLeave: fe,
                    afterLeave: se
                } = M, ge = () => i(Y, E, N), Ee = () => {
                    K(Y, () => {
                        ge(), se && se()
                    })
                };
                fe ? fe(Y, ge, Ee) : Ee()
            }
        else i(Y, E, N)
    }, xe = (w, E, N, U = !1, W = !1) => {
        const {
            type: Y,
            props: b,
            ref: M,
            children: D,
            dynamicChildren: z,
            shapeFlag: $,
            patchFlag: K,
            dirs: fe
        } = w;
        if (M != null && nu(M, null, N, w, !0), $ & 256) {
            E.ctx.deactivate(w);
            return
        }
        const se = $ & 1 && fe,
            ge = !Xs(w);
        let Ee;
        if (ge && (Ee = b && b.onVnodeBeforeUnmount) && Gn(Ee, E, w), $ & 6) Re(w.component, N, U);
        else {
            if ($ & 128) {
                w.suspense.unmount(N, U);
                return
            }
            se && Wi(w, null, E, "beforeUnmount"), $ & 64 ? w.type.remove(w, E, N, W, le, U) : z && (Y !== Et || K > 0 && K & 64) ? Pe(z, E, N, !1, !0) : (Y === Et && K & 384 || !W && $ & 16) && Pe(D, E, N), U && te(w)
        }(ge && (Ee = b && b.onVnodeUnmounted) || se) && ln(() => {
            Ee && Gn(Ee, E, w), se && Wi(w, null, E, "unmounted")
        }, N)
    }, te = w => {
        const {
            type: E,
            el: N,
            anchor: U,
            transition: W
        } = w;
        if (E === Et) {
            me(N, U);
            return
        }
        if (E === Da) {
            x(w);
            return
        }
        const Y = () => {
            r(N), W && !W.persisted && W.afterLeave && W.afterLeave()
        };
        if (w.shapeFlag & 1 && W && !W.persisted) {
            const {
                leave: b,
                delayLeave: M
            } = W, D = () => b(N, Y);
            M ? M(w.el, Y, D) : D()
        } else Y()
    }, me = (w, E) => {
        let N;
        for (; w !== E;) N = f(w), r(w), w = N;
        r(E)
    }, Re = (w, E, N) => {
        const {
            bum: U,
            scope: W,
            update: Y,
            subTree: b,
            um: M
        } = w;
        U && Hl(U), W.stop(), Y && (Y.active = !1, xe(b, w, E, N)), M && ln(M, E), ln(() => {
            w.isUnmounted = !0
        }, E), E && E.pendingBranch && !E.isUnmounted && w.asyncDep && !w.asyncResolved && w.suspenseId === E.pendingId && (E.deps--, E.deps === 0 && E.resolve())
    }, Pe = (w, E, N, U = !1, W = !1, Y = 0) => {
        for (let b = Y; b < w.length; b++) xe(w[b], E, N, U, W)
    }, H = w => w.shapeFlag & 6 ? H(w.component.subTree) : w.shapeFlag & 128 ? w.suspense.next() : f(w.anchor || w.el);
    let ce = !1;
    const ae = (w, E, N) => {
            w == null ? E._vnode && xe(E._vnode, null, null, !0) : _(E._vnode || null, w, E, null, null, null, N), ce || (ce = !0, Jh(), Nm(), ce = !1), E._vnode = w
        },
        le = {
            p: _,
            um: xe,
            m: de,
            r: te,
            mt: B,
            mc: F,
            pc: J,
            pbc: A,
            n: H,
            o: n
        };
    let Ce, I;
    return e && ([Ce, I] = e(le)), {
        render: ae,
        hydrate: Ce,
        createApp: lv(ae, Ce)
    }
}

function ql({
    type: n,
    props: e
}, t) {
    return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t
}

function $i({
    effect: n,
    update: e
}, t) {
    n.allowRecurse = e.allowRecurse = t
}

function gv(n, e) {
    return (!n || n && !n.pendingBranch) && e && !e.persisted
}

function Qm(n, e, t = !1) {
    const i = n.children,
        r = e.children;
    if (Xe(i) && Xe(r))
        for (let s = 0; s < i.length; s++) {
            const o = i[s];
            let a = r[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = Ei(r[s]), a.el = o.el), t || Qm(o, a)), a.type === gl && (a.el = o.el)
        }
}

function _v(n) {
    const e = n.slice(),
        t = [0];
    let i, r, s, o, a;
    const l = n.length;
    for (i = 0; i < l; i++) {
        const c = n[i];
        if (c !== 0) {
            if (r = t[t.length - 1], n[r] < c) {
                e[i] = r, t.push(i);
                continue
            }
            for (s = 0, o = t.length - 1; s < o;) a = s + o >> 1, n[t[a]] < c ? s = a + 1 : o = a;
            c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]), t[s] = i)
        }
    }
    for (s = t.length, o = t[s - 1]; s-- > 0;) t[s] = o, o = e[o];
    return t
}

function eg(n) {
    const e = n.subTree.component;
    if (e) return e.asyncDep && !e.asyncResolved ? e : eg(e)
}
const vv = n => n.__isTeleport,
    Et = Symbol.for("v-fgt"),
    gl = Symbol.for("v-txt"),
    ki = Symbol.for("v-cmt"),
    Da = Symbol.for("v-stc"),
    Ys = [];
let Fn = null;

function be(n = !1) {
    Ys.push(Fn = n ? null : [])
}

function yv() {
    Ys.pop(), Fn = Ys[Ys.length - 1] || null
}
let ao = 1;

function cf(n) {
    ao += n
}

function tg(n) {
    return n.dynamicChildren = ao > 0 ? Fn || is : null, yv(), ao > 0 && Fn && Fn.push(n), n
}

function Ie(n, e, t, i, r, s) {
    return tg(re(n, e, t, i, r, s, !0))
}

function Jt(n, e, t, i, r) {
    return tg(ve(n, e, t, i, r, !0))
}

function Wa(n) {
    return n ? n.__v_isVNode === !0 : !1
}

function Rs(n, e) {
    return n.type === e.type && n.key === e.key
}
const _l = "__vInternal",
    ng = ({
        key: n
    }) => n ?? null,
    Oa = ({
        ref: n,
        ref_key: e,
        ref_for: t
    }) => (typeof n == "number" && (n = "" + n), n != null ? Dt(n) || fn(n) || $e(n) ? {
        i: kt,
        r: n,
        k: e,
        f: !!t
    } : n : null);

function re(n, e = null, t = null, i = 0, r = null, s = n === Et ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n,
        props: e,
        key: e && ng(e),
        ref: e && Oa(e),
        scopeId: pl,
        slotScopeIds: null,
        children: t,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: i,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: kt
    };
    return a ? (Gu(l, t), s & 128 && n.normalize(l)) : t && (l.shapeFlag |= Dt(t) ? 8 : 16), ao > 0 && !o && Fn && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Fn.push(l), l
}
const ve = xv;

function xv(n, e = null, t = null, i = 0, r = null, s = !1) {
    if ((!n || n === N0) && (n = ki), Wa(n)) {
        const a = fs(n, e, !0);
        return t && Gu(a, t), ao > 0 && !s && Fn && (a.shapeFlag & 6 ? Fn[Fn.indexOf(n)] = a : Fn.push(a)), a.patchFlag |= -2, a
    }
    if (Iv(n) && (n = n.__vccOpts), e) {
        e = Mv(e);
        let {
            class: a,
            style: l
        } = e;
        a && !Dt(a) && (e.class = Un(a)), bt(l) && (Am(l) && !Xe(l) && (l = Gt({}, l)), e.style = Ru(l))
    }
    const o = Dt(n) ? 1 : F0(n) ? 128 : vv(n) ? 64 : bt(n) ? 4 : $e(n) ? 2 : 0;
    return re(n, e, t, i, r, o, s, !0)
}

function Mv(n) {
    return n ? Am(n) || _l in n ? Gt({}, n) : n : null
}

function fs(n, e, t = !1) {
    const {
        props: i,
        ref: r,
        patchFlag: s,
        children: o
    } = n, a = e ? Sv(i || {}, e) : i;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n.type,
        props: a,
        key: a && ng(a),
        ref: e && e.ref ? t && r ? Xe(r) ? r.concat(Oa(e)) : [r, Oa(e)] : Oa(e) : r,
        scopeId: n.scopeId,
        slotScopeIds: n.slotScopeIds,
        children: o,
        target: n.target,
        targetAnchor: n.targetAnchor,
        staticCount: n.staticCount,
        shapeFlag: n.shapeFlag,
        patchFlag: e && n.type !== Et ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: n.dynamicProps,
        dynamicChildren: n.dynamicChildren,
        appContext: n.appContext,
        dirs: n.dirs,
        transition: n.transition,
        component: n.component,
        suspense: n.suspense,
        ssContent: n.ssContent && fs(n.ssContent),
        ssFallback: n.ssFallback && fs(n.ssFallback),
        el: n.el,
        anchor: n.anchor,
        ctx: n.ctx,
        ce: n.ce
    }
}

function ar(n = " ", e = 0) {
    return ve(gl, null, n, e)
}

function bv(n, e) {
    const t = ve(Da, null, n);
    return t.staticCount = e, t
}

function rt(n = "", e = !1) {
    return e ? (be(), Jt(ki, null, n)) : ve(ki, null, n)
}

function Hn(n) {
    return n == null || typeof n == "boolean" ? ve(ki) : Xe(n) ? ve(Et, null, n.slice()) : typeof n == "object" ? Ei(n) : ve(gl, null, String(n))
}

function Ei(n) {
    return n.el === null && n.patchFlag !== -1 || n.memo ? n : fs(n)
}

function Gu(n, e) {
    let t = 0;
    const {
        shapeFlag: i
    } = n;
    if (e == null) e = null;
    else if (Xe(e)) t = 16;
    else if (typeof e == "object")
        if (i & 65) {
            const r = e.default;
            r && (r._c && (r._d = !1), Gu(n, r()), r._c && (r._d = !0));
            return
        } else {
            t = 32;
            const r = e._;
            !r && !(_l in e) ? e._ctx = kt : r === 3 && kt && (kt.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024))
        }
    else $e(e) ? (e = {
        default: e,
        _ctx: kt
    }, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [ar(e)]) : t = 8);
    n.children = e, n.shapeFlag |= t
}

function Sv(...n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = n[t];
        for (const r in i)
            if (r === "class") e.class !== i.class && (e.class = Un([e.class, i.class]));
            else if (r === "style") e.style = Ru([e.style, i.style]);
        else if (ol(r)) {
            const s = e[r],
                o = i[r];
            o && s !== o && !(Xe(s) && s.includes(o)) && (e[r] = s ? [].concat(s, o) : o)
        } else r !== "" && (e[r] = i[r])
    }
    return e
}

function Gn(n, e, t, i = null) {
    Bn(n, e, 7, [t, i])
}
const Tv = qm();
let wv = 0;

function Ev(n, e, t) {
    const i = n.type,
        r = (e ? e.appContext : n.appContext) || Tv,
        s = {
            uid: wv++,
            vnode: n,
            type: i,
            parent: e,
            appContext: r,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new Z_(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(r.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Km(i, r),
            emitsOptions: Fm(i, r),
            emit: null,
            emitted: null,
            propsDefaults: yt,
            inheritAttrs: i.inheritAttrs,
            ctx: yt,
            data: yt,
            props: yt,
            attrs: yt,
            slots: yt,
            refs: yt,
            setupState: yt,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: t,
            suspenseId: t ? t.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = {
        _: s
    }, s.root = e ? e.root : s, s.emit = P0.bind(null, s), n.ce && n.ce(s), s
}
let Kt = null,
    $a, iu; {
    const n = um(),
        e = (t, i) => {
            let r;
            return (r = n[t]) || (r = n[t] = []), r.push(i), s => {
                r.length > 1 ? r.forEach(o => o(s)) : r[0](s)
            }
        };
    $a = e("__VUE_INSTANCE_SETTERS__", t => Kt = t), iu = e("__VUE_SSR_SETTERS__", t => vl = t)
}
const To = n => {
        const e = Kt;
        return $a(n), n.scope.on(), () => {
            n.scope.off(), $a(e)
        }
    },
    uf = () => {
        Kt && Kt.scope.off(), $a(null)
    };

function ig(n) {
    return n.vnode.shapeFlag & 4
}
let vl = !1;

function Av(n, e = !1) {
    e && iu(e);
    const {
        props: t,
        children: i
    } = n.vnode, r = ig(n);
    cv(n, t, r, e), fv(n, i);
    const s = r ? Rv(n, e) : void 0;
    return e && iu(!1), s
}

function Rv(n, e) {
    const t = n.type;
    n.accessCache = Object.create(null), n.proxy = Rm(new Proxy(n.ctx, tv));
    const {
        setup: i
    } = t;
    if (i) {
        const r = n.setupContext = i.length > 1 ? Pv(n) : null,
            s = To(n);
        vr();
        const o = Di(i, n, 0, [n.props, r]);
        if (yr(), s(), lm(o)) {
            if (o.then(uf, uf), e) return o.then(a => {
                hf(n, a, e)
            }).catch(a => {
                fl(a, n, 0)
            });
            n.asyncDep = o
        } else hf(n, o, e)
    } else rg(n, e)
}

function hf(n, e, t) {
    $e(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : bt(e) && (n.setupState = Im(e)), rg(n, t)
}
let ff;

function rg(n, e, t) {
    const i = n.type;
    if (!n.render) {
        if (!e && ff && !i.render) {
            const r = i.template || ku(n).template;
            if (r) {
                const {
                    isCustomElement: s,
                    compilerOptions: o
                } = n.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = i, c = Gt(Gt({
                    isCustomElement: s,
                    delimiters: a
                }, o), l);
                i.render = ff(r, c)
            }
        }
        n.render = i.render || An
    } {
        const r = To(n);
        vr();
        try {
            nv(n)
        } finally {
            yr(), r()
        }
    }
}

function Cv(n) {
    return n.attrsProxy || (n.attrsProxy = new Proxy(n.attrs, {
        get(e, t) {
            return hn(n, "get", "$attrs"), e[t]
        }
    }))
}

function Pv(n) {
    const e = t => {
        n.exposed = t || {}
    };
    return {
        get attrs() {
            return Cv(n)
        },
        slots: n.slots,
        emit: n.emit,
        expose: e
    }
}

function yl(n) {
    if (n.exposed) return n.exposeProxy || (n.exposeProxy = new Proxy(Im(Rm(n.exposed)), {
        get(e, t) {
            if (t in e) return e[t];
            if (t in qs) return qs[t](n)
        },
        has(e, t) {
            return t in e || t in qs
        }
    }))
}

function Lv(n, e = !0) {
    return $e(n) ? n.displayName || n.name : n.name || e && n.__name
}

function Iv(n) {
    return $e(n) && "__vccOpts" in n
}
const Nn = (n, e) => x0(n, e, vl);

function sg(n, e, t) {
    const i = arguments.length;
    return i === 2 ? bt(e) && !Xe(e) ? Wa(e) ? ve(n, null, [e]) : ve(n, e) : ve(n, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && Wa(t) && (t = [t]), ve(n, e, t))
}
const Dv = "3.4.15";
const Ov = "http://www.w3.org/2000/svg",
    Nv = "http://www.w3.org/1998/Math/MathML",
    Ai = typeof document < "u" ? document : null,
    df = Ai && Ai.createElement("template"),
    Uv = {
        insert: (n, e, t) => {
            e.insertBefore(n, t || null)
        },
        remove: n => {
            const e = n.parentNode;
            e && e.removeChild(n)
        },
        createElement: (n, e, t, i) => {
            const r = e === "svg" ? Ai.createElementNS(Ov, n) : e === "mathml" ? Ai.createElementNS(Nv, n) : Ai.createElement(n, t ? {
                is: t
            } : void 0);
            return n === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r
        },
        createText: n => Ai.createTextNode(n),
        createComment: n => Ai.createComment(n),
        setText: (n, e) => {
            n.nodeValue = e
        },
        setElementText: (n, e) => {
            n.textContent = e
        },
        parentNode: n => n.parentNode,
        nextSibling: n => n.nextSibling,
        querySelector: n => Ai.querySelector(n),
        setScopeId(n, e) {
            n.setAttribute(e, "")
        },
        insertStaticContent(n, e, t, i, r, s) {
            const o = t ? t.previousSibling : e.lastChild;
            if (r && (r === s || r.nextSibling))
                for (; e.insertBefore(r.cloneNode(!0), t), !(r === s || !(r = r.nextSibling)););
            else {
                df.innerHTML = i === "svg" ? `<svg>${n}</svg>` : i === "mathml" ? `<math>${n}</math>` : n;
                const a = df.content;
                if (i === "svg" || i === "mathml") {
                    const l = a.firstChild;
                    for (; l.firstChild;) a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                e.insertBefore(a, t)
            }
            return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
        }
    },
    Fv = Symbol("_vtc");

function Bv(n, e, t) {
    const i = n[Fv];
    i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e
}
const Vu = Symbol("_vod"),
    kv = {
        beforeMount(n, {
            value: e
        }, {
            transition: t
        }) {
            n[Vu] = n.style.display === "none" ? "" : n.style.display, t && e ? t.beforeEnter(n) : Cs(n, e)
        },
        mounted(n, {
            value: e
        }, {
            transition: t
        }) {
            t && e && t.enter(n)
        },
        updated(n, {
            value: e,
            oldValue: t
        }, {
            transition: i
        }) {
            !e != !t && (i ? e ? (i.beforeEnter(n), Cs(n, !0), i.enter(n)) : i.leave(n, () => {
                Cs(n, !1)
            }) : Cs(n, e))
        },
        beforeUnmount(n, {
            value: e
        }) {
            Cs(n, e)
        }
    };

function Cs(n, e) {
    n.style.display = e ? n[Vu] : "none"
}
const zv = Symbol("");

function Gv(n, e, t) {
    const i = n.style,
        r = i.display,
        s = Dt(t);
    if (t && !s) {
        if (e && !Dt(e))
            for (const o in e) t[o] == null && ru(i, o, "");
        for (const o in t) ru(i, o, t[o])
    } else if (s) {
        if (e !== t) {
            const o = i[zv];
            o && (t += ";" + o), i.cssText = t
        }
    } else e && n.removeAttribute("style");
    Vu in n && (i.display = r)
}
const pf = /\s*!important$/;

function ru(n, e, t) {
    if (Xe(t)) t.forEach(i => ru(n, e, i));
    else if (t == null && (t = ""), e.startsWith("--")) n.setProperty(e, t);
    else {
        const i = Vv(n, e);
        pf.test(t) ? n.setProperty(_r(i), t.replace(pf, ""), "important") : n[i] = t
    }
}
const mf = ["Webkit", "Moz", "ms"],
    Yl = {};

function Vv(n, e) {
    const t = Yl[e];
    if (t) return t;
    let i = Jn(e);
    if (i !== "filter" && i in n) return Yl[e] = i;
    i = cl(i);
    for (let r = 0; r < mf.length; r++) {
        const s = mf[r] + i;
        if (s in n) return Yl[e] = s
    }
    return e
}
const gf = "http://www.w3.org/1999/xlink";

function Hv(n, e, t, i, r) {
    if (i && e.startsWith("xlink:")) t == null ? n.removeAttributeNS(gf, e.slice(6, e.length)) : n.setAttributeNS(gf, e, t);
    else {
        const s = J_(e);
        t == null || s && !hm(t) ? n.removeAttribute(e) : n.setAttribute(e, s ? "" : t)
    }
}

function Wv(n, e, t, i, r, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        i && o(i, r, s), n[e] = t ?? "";
        return
    }
    const a = n.tagName;
    if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
        n._value = t;
        const c = a === "OPTION" ? n.getAttribute("value") : n.value,
            u = t ?? "";
        c !== u && (n.value = u), t == null && n.removeAttribute(e);
        return
    }
    let l = !1;
    if (t === "" || t == null) {
        const c = typeof n[e];
        c === "boolean" ? t = hm(t) : t == null && c === "string" ? (t = "", l = !0) : c === "number" && (t = 0, l = !0)
    }
    try {
        n[e] = t
    } catch {}
    l && n.removeAttribute(e)
}

function $v(n, e, t, i) {
    n.addEventListener(e, t, i)
}

function Xv(n, e, t, i) {
    n.removeEventListener(e, t, i)
}
const _f = Symbol("_vei");

function qv(n, e, t, i, r = null) {
    const s = n[_f] || (n[_f] = {}),
        o = s[e];
    if (i && o) o.value = i;
    else {
        const [a, l] = Yv(e);
        if (i) {
            const c = s[e] = Jv(i, r);
            $v(n, a, c, l)
        } else o && (Xv(n, a, o, l), s[e] = void 0)
    }
}
const vf = /(?:Once|Passive|Capture)$/;

function Yv(n) {
    let e;
    if (vf.test(n)) {
        e = {};
        let i;
        for (; i = n.match(vf);) n = n.slice(0, n.length - i[0].length), e[i[0].toLowerCase()] = !0
    }
    return [n[2] === ":" ? n.slice(3) : _r(n.slice(2)), e]
}
let Kl = 0;
const Kv = Promise.resolve(),
    jv = () => Kl || (Kv.then(() => Kl = 0), Kl = Date.now());

function Jv(n, e) {
    const t = i => {
        if (!i._vts) i._vts = Date.now();
        else if (i._vts <= t.attached) return;
        Bn(Zv(i, t.value), e, 5, [i])
    };
    return t.value = n, t.attached = jv(), t
}

function Zv(n, e) {
    if (Xe(e)) {
        const t = n.stopImmediatePropagation;
        return n.stopImmediatePropagation = () => {
            t.call(n), n._stopped = !0
        }, e.map(i => r => !r._stopped && i && i(r))
    } else return e
}
const yf = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123,
    Qv = (n, e, t, i, r, s, o, a, l) => {
        const c = r === "svg";
        e === "class" ? Bv(n, i, c) : e === "style" ? Gv(n, t, i) : ol(e) ? wu(e) || qv(n, e, t, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : ey(n, e, i, c)) ? Wv(n, e, i, s, o, a, l) : (e === "true-value" ? n._trueValue = i : e === "false-value" && (n._falseValue = i), Hv(n, e, i, c))
    };

function ey(n, e, t, i) {
    if (i) return !!(e === "innerHTML" || e === "textContent" || e in n && yf(e) && $e(t));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA") return !1;
    if (e === "width" || e === "height") {
        const r = n.tagName;
        if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1
    }
    return yf(e) && Dt(t) ? !1 : e in n
}
const ty = ["ctrl", "shift", "alt", "meta"],
    ny = {
        stop: n => n.stopPropagation(),
        prevent: n => n.preventDefault(),
        self: n => n.target !== n.currentTarget,
        ctrl: n => !n.ctrlKey,
        shift: n => !n.shiftKey,
        alt: n => !n.altKey,
        meta: n => !n.metaKey,
        left: n => "button" in n && n.button !== 0,
        middle: n => "button" in n && n.button !== 1,
        right: n => "button" in n && n.button !== 2,
        exact: (n, e) => ty.some(t => n[`${t}Key`] && !e.includes(t))
    },
    xl = (n, e) => {
        const t = n._withMods || (n._withMods = {}),
            i = e.join(".");
        return t[i] || (t[i] = (r, ...s) => {
            for (let o = 0; o < e.length; o++) {
                const a = ny[e[o]];
                if (a && a(r, e)) return
            }
            return n(r, ...s)
        })
    },
    iy = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    ry = (n, e) => {
        const t = n._withKeys || (n._withKeys = {}),
            i = e.join(".");
        return t[i] || (t[i] = r => {
            if (!("key" in r)) return;
            const s = _r(r.key);
            if (e.some(o => o === s || iy[o] === s)) return n(r)
        })
    },
    sy = Gt({
        patchProp: Qv
    }, Uv);
let xf;

function oy() {
    return xf || (xf = pv(sy))
}
const ay = (...n) => {
    const e = oy().createApp(...n),
        {
            mount: t
        } = e;
    return e.mount = i => {
        const r = cy(i);
        if (!r) return;
        const s = e._component;
        !$e(s) && !s.render && !s.template && (s.template = r.innerHTML), r.innerHTML = "";
        const o = t(r, !1, ly(r));
        return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o
    }, e
};

function ly(n) {
    if (n instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && n instanceof MathMLElement) return "mathml"
}

function cy(n) {
    return Dt(n) ? document.querySelector(n) : n
}
const jr = typeof window < "u";

function uy(n) {
    return n.__esModule || n[Symbol.toStringTag] === "Module"
}
const ct = Object.assign;

function jl(n, e) {
    const t = {};
    for (const i in e) {
        const r = e[i];
        t[i] = kn(r) ? r.map(n) : n(r)
    }
    return t
}
const Ks = () => {},
    kn = Array.isArray,
    hy = /\/$/,
    fy = n => n.replace(hy, "");

function Jl(n, e, t = "/") {
    let i, r = {},
        s = "",
        o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1), l > -1 && (i = e.slice(0, l), s = e.slice(l + 1, a > -1 ? a : e.length), r = n(s)), a > -1 && (i = i || e.slice(0, a), o = e.slice(a, e.length)), i = gy(i ?? e, t), {
        fullPath: i + (s && "?") + s + o,
        path: i,
        query: r,
        hash: o
    }
}

function dy(n, e) {
    const t = e.query ? n(e.query) : "";
    return e.path + (t && "?") + t + (e.hash || "")
}

function Mf(n, e) {
    return !e || !n.toLowerCase().startsWith(e.toLowerCase()) ? n : n.slice(e.length) || "/"
}

function py(n, e, t) {
    const i = e.matched.length - 1,
        r = t.matched.length - 1;
    return i > -1 && i === r && ds(e.matched[i], t.matched[r]) && og(e.params, t.params) && n(e.query) === n(t.query) && e.hash === t.hash
}

function ds(n, e) {
    return (n.aliasOf || n) === (e.aliasOf || e)
}

function og(n, e) {
    if (Object.keys(n).length !== Object.keys(e).length) return !1;
    for (const t in n)
        if (!my(n[t], e[t])) return !1;
    return !0
}

function my(n, e) {
    return kn(n) ? bf(n, e) : kn(e) ? bf(e, n) : n === e
}

function bf(n, e) {
    return kn(e) ? n.length === e.length && n.every((t, i) => t === e[i]) : n.length === 1 && n[0] === e
}

function gy(n, e) {
    if (n.startsWith("/")) return n;
    if (!n) return e;
    const t = e.split("/"),
        i = n.split("/"),
        r = i[i.length - 1];
    (r === ".." || r === ".") && i.push("");
    let s = t.length - 1,
        o, a;
    for (o = 0; o < i.length; o++)
        if (a = i[o], a !== ".")
            if (a === "..") s > 1 && s--;
            else break;
    return t.slice(0, s).join("/") + "/" + i.slice(o - (o === i.length ? 1 : 0)).join("/")
}
var lo;
(function (n) {
    n.pop = "pop", n.push = "push"
})(lo || (lo = {}));
var js;
(function (n) {
    n.back = "back", n.forward = "forward", n.unknown = ""
})(js || (js = {}));

function _y(n) {
    if (!n)
        if (jr) {
            const e = document.querySelector("base");
            n = e && e.getAttribute("href") || "/", n = n.replace(/^\w+:\/\/[^\/]+/, "")
        } else n = "/";
    return n[0] !== "/" && n[0] !== "#" && (n = "/" + n), fy(n)
}
const vy = /^[^#]+#/;

function yy(n, e) {
    return n.replace(vy, "#") + e
}

function xy(n, e) {
    const t = document.documentElement.getBoundingClientRect(),
        i = n.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: i.left - t.left - (e.left || 0),
        top: i.top - t.top - (e.top || 0)
    }
}
const Ml = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});

function My(n) {
    let e;
    if ("el" in n) {
        const t = n.el,
            i = typeof t == "string" && t.startsWith("#"),
            r = typeof t == "string" ? i ? document.getElementById(t.slice(1)) : document.querySelector(t) : t;
        if (!r) return;
        e = xy(r, n)
    } else e = n;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}

function Sf(n, e) {
    return (history.state ? history.state.position - e : -1) + n
}
const su = new Map;

function by(n, e) {
    su.set(n, e)
}

function Sy(n) {
    const e = su.get(n);
    return su.delete(n), e
}
let Ty = () => location.protocol + "//" + location.host;

function ag(n, e) {
    const {
        pathname: t,
        search: i,
        hash: r
    } = e, s = n.indexOf("#");
    if (s > -1) {
        let a = r.includes(n.slice(s)) ? n.slice(s).length : 1,
            l = r.slice(a);
        return l[0] !== "/" && (l = "/" + l), Mf(l, "")
    }
    return Mf(t, n) + i + r
}

function wy(n, e, t, i) {
    let r = [],
        s = [],
        o = null;
    const a = ({
        state: f
    }) => {
        const d = ag(n, location),
            p = t.value,
            _ = e.value;
        let g = 0;
        if (f) {
            if (t.value = d, e.value = f, o && o === p) {
                o = null;
                return
            }
            g = _ ? f.position - _.position : 0
        } else i(d);
        r.forEach(m => {
            m(t.value, p, {
                delta: g,
                type: lo.pop,
                direction: g ? g > 0 ? js.forward : js.back : js.unknown
            })
        })
    };

    function l() {
        o = t.value
    }

    function c(f) {
        r.push(f);
        const d = () => {
            const p = r.indexOf(f);
            p > -1 && r.splice(p, 1)
        };
        return s.push(d), d
    }

    function u() {
        const {
            history: f
        } = window;
        f.state && f.replaceState(ct({}, f.state, {
            scroll: Ml()
        }), "")
    }

    function h() {
        for (const f of s) f();
        s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u, {
        passive: !0
    }), {
        pauseListeners: l,
        listen: c,
        destroy: h
    }
}

function Tf(n, e, t, i = !1, r = !1) {
    return {
        back: n,
        current: e,
        forward: t,
        replaced: i,
        position: window.history.length,
        scroll: r ? Ml() : null
    }
}

function Ey(n) {
    const {
        history: e,
        location: t
    } = window, i = {
        value: ag(n, t)
    }, r = {
        value: e.state
    };
    r.value || s(i.value, {
        back: null,
        current: i.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function s(l, c, u) {
        const h = n.indexOf("#"),
            f = h > -1 ? (t.host && document.querySelector("base") ? n : n.slice(h)) + l : Ty() + n + l;
        try {
            e[u ? "replaceState" : "pushState"](c, "", f), r.value = c
        } catch (d) {
            console.error(d), t[u ? "replace" : "assign"](f)
        }
    }

    function o(l, c) {
        const u = ct({}, e.state, Tf(r.value.back, l, r.value.forward, !0), c, {
            position: r.value.position
        });
        s(l, u, !0), i.value = l
    }

    function a(l, c) {
        const u = ct({}, r.value, e.state, {
            forward: l,
            scroll: Ml()
        });
        s(u.current, u, !0);
        const h = ct({}, Tf(i.value, l, null), {
            position: u.position + 1
        }, c);
        s(l, h, !1), i.value = l
    }
    return {
        location: i,
        state: r,
        push: a,
        replace: o
    }
}

function Ay(n) {
    n = _y(n);
    const e = Ey(n),
        t = wy(n, e.state, e.location, e.replace);

    function i(s, o = !0) {
        o || t.pauseListeners(), history.go(s)
    }
    const r = ct({
        location: "",
        base: n,
        go: i,
        createHref: yy.bind(null, n)
    }, e, t);
    return Object.defineProperty(r, "location", {
        enumerable: !0,
        get: () => e.location.value
    }), Object.defineProperty(r, "state", {
        enumerable: !0,
        get: () => e.state.value
    }), r
}

function Ry(n) {
    return typeof n == "string" || n && typeof n == "object"
}

function lg(n) {
    return typeof n == "string" || typeof n == "symbol"
}
const vi = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
    },
    cg = Symbol("");
var wf;
(function (n) {
    n[n.aborted = 4] = "aborted", n[n.cancelled = 8] = "cancelled", n[n.duplicated = 16] = "duplicated"
})(wf || (wf = {}));

function ps(n, e) {
    return ct(new Error, {
        type: n,
        [cg]: !0
    }, e)
}

function ii(n, e) {
    return n instanceof Error && cg in n && (e == null || !!(n.type & e))
}
const Ef = "[^/]+?",
    Cy = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    Py = /[.+*?^${}()[\]/\\]/g;

function Ly(n, e) {
    const t = ct({}, Cy, e),
        i = [];
    let r = t.start ? "^" : "";
    const s = [];
    for (const c of n) {
        const u = c.length ? [] : [90];
        t.strict && !c.length && (r += "/");
        for (let h = 0; h < c.length; h++) {
            const f = c[h];
            let d = 40 + (t.sensitive ? .25 : 0);
            if (f.type === 0) h || (r += "/"), r += f.value.replace(Py, "\\$&"), d += 40;
            else if (f.type === 1) {
                const {
                    value: p,
                    repeatable: _,
                    optional: g,
                    regexp: m
                } = f;
                s.push({
                    name: p,
                    repeatable: _,
                    optional: g
                });
                const y = m || Ef;
                if (y !== Ef) {
                    d += 10;
                    try {
                        new RegExp(`(${y})`)
                    } catch (x) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${y}): ` + x.message)
                    }
                }
                let v = _ ? `((?:${y})(?:/(?:${y}))*)` : `(${y})`;
                h || (v = g && c.length < 2 ? `(?:/${v})` : "/" + v), g && (v += "?"), r += v, d += 20, g && (d += -8), _ && (d += -20), y === ".*" && (d += -50)
            }
            u.push(d)
        }
        i.push(u)
    }
    if (t.strict && t.end) {
        const c = i.length - 1;
        i[c][i[c].length - 1] += .7000000000000001
    }
    t.strict || (r += "/?"), t.end ? r += "$" : t.strict && (r += "(?:/|$)");
    const o = new RegExp(r, t.sensitive ? "" : "i");

    function a(c) {
        const u = c.match(o),
            h = {};
        if (!u) return null;
        for (let f = 1; f < u.length; f++) {
            const d = u[f] || "",
                p = s[f - 1];
            h[p.name] = d && p.repeatable ? d.split("/") : d
        }
        return h
    }

    function l(c) {
        let u = "",
            h = !1;
        for (const f of n) {
            (!h || !u.endsWith("/")) && (u += "/"), h = !1;
            for (const d of f)
                if (d.type === 0) u += d.value;
                else if (d.type === 1) {
                const {
                    value: p,
                    repeatable: _,
                    optional: g
                } = d, m = p in c ? c[p] : "";
                if (kn(m) && !_) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                const y = kn(m) ? m.join("/") : m;
                if (!y)
                    if (g) f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : h = !0);
                    else throw new Error(`Missing required param "${p}"`);
                u += y
            }
        }
        return u || "/"
    }
    return {
        re: o,
        score: i,
        keys: s,
        parse: a,
        stringify: l
    }
}

function Iy(n, e) {
    let t = 0;
    for (; t < n.length && t < e.length;) {
        const i = e[t] - n[t];
        if (i) return i;
        t++
    }
    return n.length < e.length ? n.length === 1 && n[0] === 80 ? -1 : 1 : n.length > e.length ? e.length === 1 && e[0] === 80 ? 1 : -1 : 0
}

function Dy(n, e) {
    let t = 0;
    const i = n.score,
        r = e.score;
    for (; t < i.length && t < r.length;) {
        const s = Iy(i[t], r[t]);
        if (s) return s;
        t++
    }
    if (Math.abs(r.length - i.length) === 1) {
        if (Af(i)) return 1;
        if (Af(r)) return -1
    }
    return r.length - i.length
}

function Af(n) {
    const e = n[n.length - 1];
    return n.length > 0 && e[e.length - 1] < 0
}
const Oy = {
        type: 0,
        value: ""
    },
    Ny = /[a-zA-Z0-9_]/;

function Uy(n) {
    if (!n) return [
        []
    ];
    if (n === "/") return [
        [Oy]
    ];
    if (!n.startsWith("/")) throw new Error(`Invalid path "${n}"`);

    function e(d) {
        throw new Error(`ERR (${t})/"${c}": ${d}`)
    }
    let t = 0,
        i = t;
    const r = [];
    let s;

    function o() {
        s && r.push(s), s = []
    }
    let a = 0,
        l, c = "",
        u = "";

    function h() {
        c && (t === 0 ? s.push({
            type: 0,
            value: c
        }) : t === 1 || t === 2 || t === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"), c = "")
    }

    function f() {
        c += l
    }
    for (; a < n.length;) {
        if (l = n[a++], l === "\\" && t !== 2) {
            i = t, t = 4;
            continue
        }
        switch (t) {
        case 0:
            l === "/" ? (c && h(), o()) : l === ":" ? (h(), t = 1) : f();
            break;
        case 4:
            f(), t = i;
            break;
        case 1:
            l === "(" ? t = 2 : Ny.test(l) ? f() : (h(), t = 0, l !== "*" && l !== "?" && l !== "+" && a--);
            break;
        case 2:
            l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : t = 3 : u += l;
            break;
        case 3:
            h(), t = 0, l !== "*" && l !== "?" && l !== "+" && a--, u = "";
            break;
        default:
            e("Unknown state");
            break
        }
    }
    return t === 2 && e(`Unfinished custom RegExp for param "${c}"`), h(), o(), r
}

function Fy(n, e, t) {
    const i = Ly(Uy(n.path), t),
        r = ct(i, {
            record: n,
            parent: e,
            children: [],
            alias: []
        });
    return e && !r.record.aliasOf == !e.record.aliasOf && e.children.push(r), r
}

function By(n, e) {
    const t = [],
        i = new Map;
    e = Pf({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);

    function r(u) {
        return i.get(u)
    }

    function s(u, h, f) {
        const d = !f,
            p = ky(u);
        p.aliasOf = f && f.record;
        const _ = Pf(e, u),
            g = [p];
        if ("alias" in u) {
            const v = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const x of v) g.push(ct({}, p, {
                components: f ? f.record.components : p.components,
                path: x,
                aliasOf: f ? f.record : p
            }))
        }
        let m, y;
        for (const v of g) {
            const {
                path: x
            } = v;
            if (h && x[0] !== "/") {
                const C = h.record.path,
                    S = C[C.length - 1] === "/" ? "" : "/";
                v.path = h.record.path + (x && S + x)
            }
            if (m = Fy(v, h, _), f ? f.alias.push(m) : (y = y || m, y !== m && y.alias.push(m), d && u.name && !Cf(m) && o(u.name)), p.children) {
                const C = p.children;
                for (let S = 0; S < C.length; S++) s(C[S], m, f && f.children[S])
            }
            f = f || m, (m.record.components && Object.keys(m.record.components).length || m.record.name || m.record.redirect) && l(m)
        }
        return y ? () => {
            o(y)
        } : Ks
    }

    function o(u) {
        if (lg(u)) {
            const h = i.get(u);
            h && (i.delete(u), t.splice(t.indexOf(h), 1), h.children.forEach(o), h.alias.forEach(o))
        } else {
            const h = t.indexOf(u);
            h > -1 && (t.splice(h, 1), u.record.name && i.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
        }
    }

    function a() {
        return t
    }

    function l(u) {
        let h = 0;
        for (; h < t.length && Dy(u, t[h]) >= 0 && (u.record.path !== t[h].record.path || !ug(u, t[h]));) h++;
        t.splice(h, 0, u), u.record.name && !Cf(u) && i.set(u.record.name, u)
    }

    function c(u, h) {
        let f, d = {},
            p, _;
        if ("name" in u && u.name) {
            if (f = i.get(u.name), !f) throw ps(1, {
                location: u
            });
            _ = f.record.name, d = ct(Rf(h.params, f.keys.filter(y => !y.optional).map(y => y.name)), u.params && Rf(u.params, f.keys.map(y => y.name))), p = f.stringify(d)
        } else if ("path" in u) p = u.path, f = t.find(y => y.re.test(p)), f && (d = f.parse(p), _ = f.record.name);
        else {
            if (f = h.name ? i.get(h.name) : t.find(y => y.re.test(h.path)), !f) throw ps(1, {
                location: u,
                currentLocation: h
            });
            _ = f.record.name, d = ct({}, h.params, u.params), p = f.stringify(d)
        }
        const g = [];
        let m = f;
        for (; m;) g.unshift(m.record), m = m.parent;
        return {
            name: _,
            path: p,
            params: d,
            matched: g,
            meta: Gy(g)
        }
    }
    return n.forEach(u => s(u)), {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: r
    }
}

function Rf(n, e) {
    const t = {};
    for (const i of e) i in n && (t[i] = n[i]);
    return t
}

function ky(n) {
    return {
        path: n.path,
        redirect: n.redirect,
        name: n.name,
        meta: n.meta || {},
        aliasOf: void 0,
        beforeEnter: n.beforeEnter,
        props: zy(n),
        children: n.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in n ? n.components || null : n.component && {
            default: n.component
        }
    }
}

function zy(n) {
    const e = {},
        t = n.props || !1;
    if ("component" in n) e.default = t;
    else
        for (const i in n.components) e[i] = typeof t == "object" ? t[i] : t;
    return e
}

function Cf(n) {
    for (; n;) {
        if (n.record.aliasOf) return !0;
        n = n.parent
    }
    return !1
}

function Gy(n) {
    return n.reduce((e, t) => ct(e, t.meta), {})
}

function Pf(n, e) {
    const t = {};
    for (const i in n) t[i] = i in e ? e[i] : n[i];
    return t
}

function ug(n, e) {
    return e.children.some(t => t === n || ug(n, t))
}
const hg = /#/g,
    Vy = /&/g,
    Hy = /\//g,
    Wy = /=/g,
    $y = /\?/g,
    fg = /\+/g,
    Xy = /%5B/g,
    qy = /%5D/g,
    dg = /%5E/g,
    Yy = /%60/g,
    pg = /%7B/g,
    Ky = /%7C/g,
    mg = /%7D/g,
    jy = /%20/g;

function Hu(n) {
    return encodeURI("" + n).replace(Ky, "|").replace(Xy, "[").replace(qy, "]")
}

function Jy(n) {
    return Hu(n).replace(pg, "{").replace(mg, "}").replace(dg, "^")
}

function ou(n) {
    return Hu(n).replace(fg, "%2B").replace(jy, "+").replace(hg, "%23").replace(Vy, "%26").replace(Yy, "`").replace(pg, "{").replace(mg, "}").replace(dg, "^")
}

function Zy(n) {
    return ou(n).replace(Wy, "%3D")
}

function Qy(n) {
    return Hu(n).replace(hg, "%23").replace($y, "%3F")
}

function ex(n) {
    return n == null ? "" : Qy(n).replace(Hy, "%2F")
}

function Xa(n) {
    try {
        return decodeURIComponent("" + n)
    } catch {}
    return "" + n
}

function tx(n) {
    const e = {};
    if (n === "" || n === "?") return e;
    const i = (n[0] === "?" ? n.slice(1) : n).split("&");
    for (let r = 0; r < i.length; ++r) {
        const s = i[r].replace(fg, " "),
            o = s.indexOf("="),
            a = Xa(o < 0 ? s : s.slice(0, o)),
            l = o < 0 ? null : Xa(s.slice(o + 1));
        if (a in e) {
            let c = e[a];
            kn(c) || (c = e[a] = [c]), c.push(l)
        } else e[a] = l
    }
    return e
}

function Lf(n) {
    let e = "";
    for (let t in n) {
        const i = n[t];
        if (t = Zy(t), i == null) {
            i !== void 0 && (e += (e.length ? "&" : "") + t);
            continue
        }(kn(i) ? i.map(s => s && ou(s)) : [i && ou(i)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + t, s != null && (e += "=" + s))
        })
    }
    return e
}

function nx(n) {
    const e = {};
    for (const t in n) {
        const i = n[t];
        i !== void 0 && (e[t] = kn(i) ? i.map(r => r == null ? null : "" + r) : i == null ? i : "" + i)
    }
    return e
}
const ix = Symbol(""),
    If = Symbol(""),
    Wu = Symbol(""),
    gg = Symbol(""),
    au = Symbol("");

function Ps() {
    let n = [];

    function e(i) {
        return n.push(i), () => {
            const r = n.indexOf(i);
            r > -1 && n.splice(r, 1)
        }
    }

    function t() {
        n = []
    }
    return {
        add: e,
        list: () => n.slice(),
        reset: t
    }
}

function Ri(n, e, t, i, r) {
    const s = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || []);
    return () => new Promise((o, a) => {
        const l = h => {
                h === !1 ? a(ps(4, {
                    from: t,
                    to: e
                })) : h instanceof Error ? a(h) : Ry(h) ? a(ps(2, {
                    from: e,
                    to: h
                })) : (s && i.enterCallbacks[r] === s && typeof h == "function" && s.push(h), o())
            },
            c = n.call(i && i.instances[r], e, t, l);
        let u = Promise.resolve(c);
        n.length < 3 && (u = u.then(l)), u.catch(h => a(h))
    })
}

function Zl(n, e, t, i) {
    const r = [];
    for (const s of n)
        for (const o in s.components) {
            let a = s.components[o];
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (rx(a)) {
                    const c = (a.__vccOpts || a)[e];
                    c && r.push(Ri(c, t, i, s, o))
                } else {
                    let l = a();
                    r.push(() => l.then(c => {
                        if (!c) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                        const u = uy(c) ? c.default : c;
                        s.components[o] = u;
                        const f = (u.__vccOpts || u)[e];
                        return f && Ri(f, t, i, s, o)()
                    }))
                }
        }
    return r
}

function rx(n) {
    return typeof n == "object" || "displayName" in n || "props" in n || "__vccOpts" in n
}

function Df(n) {
    const e = pi(Wu),
        t = pi(gg),
        i = Nn(() => e.resolve(or(n.to))),
        r = Nn(() => {
            const {
                matched: l
            } = i.value, {
                length: c
            } = l, u = l[c - 1], h = t.matched;
            if (!u || !h.length) return -1;
            const f = h.findIndex(ds.bind(null, u));
            if (f > -1) return f;
            const d = Of(l[c - 2]);
            return c > 1 && Of(u) === d && h[h.length - 1].path !== d ? h.findIndex(ds.bind(null, l[c - 2])) : f
        }),
        s = Nn(() => r.value > -1 && lx(t.params, i.value.params)),
        o = Nn(() => r.value > -1 && r.value === t.matched.length - 1 && og(t.params, i.value.params));

    function a(l = {}) {
        return ax(l) ? e[or(n.replace) ? "replace" : "push"](or(n.to)).catch(Ks) : Promise.resolve()
    }
    return {
        route: i,
        href: Nn(() => i.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const sx = Gm({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: Df,
        setup(n, {
            slots: e
        }) {
            const t = hl(Df(n)),
                {
                    options: i
                } = pi(Wu),
                r = Nn(() => ({
                    [Nf(n.activeClass, i.linkActiveClass, "router-link-active")]: t.isActive,
                    [Nf(n.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive
                }));
            return () => {
                const s = e.default && e.default(t);
                return n.custom ? s : sg("a", {
                    "aria-current": t.isExactActive ? n.ariaCurrentValue : null,
                    href: t.href,
                    onClick: t.navigate,
                    class: r.value
                }, s)
            }
        }
    }),
    ox = sx;

function ax(n) {
    if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) && !n.defaultPrevented && !(n.button !== void 0 && n.button !== 0)) {
        if (n.currentTarget && n.currentTarget.getAttribute) {
            const e = n.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return
        }
        return n.preventDefault && n.preventDefault(), !0
    }
}

function lx(n, e) {
    for (const t in e) {
        const i = e[t],
            r = n[t];
        if (typeof i == "string") {
            if (i !== r) return !1
        } else if (!kn(r) || r.length !== i.length || i.some((s, o) => s !== r[o])) return !1
    }
    return !0
}

function Of(n) {
    return n ? n.aliasOf ? n.aliasOf.path : n.path : ""
}
const Nf = (n, e, t) => n ?? e ?? t,
    cx = Gm({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(n, {
            attrs: e,
            slots: t
        }) {
            const i = pi(au),
                r = Nn(() => n.route || i.value),
                s = pi(If, 0),
                o = Nn(() => {
                    let c = or(s);
                    const {
                        matched: u
                    } = r.value;
                    let h;
                    for (;
                        (h = u[c]) && !h.components;) c++;
                    return c
                }),
                a = Nn(() => r.value.matched[o.value]);
            Ia(If, Nn(() => o.value + 1)), Ia(ix, a), Ia(au, r);
            const l = M0();
            return La(() => [l.value, a.value, n.name], ([c, u, h], [f, d, p]) => {
                u && (u.instances[h] = c, d && d !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = d.leaveGuards), u.updateGuards.size || (u.updateGuards = d.updateGuards))), c && u && (!d || !ds(u, d) || !f) && (u.enterCallbacks[h] || []).forEach(_ => _(c))
            }, {
                flush: "post"
            }), () => {
                const c = r.value,
                    u = n.name,
                    h = a.value,
                    f = h && h.components[u];
                if (!f) return Uf(t.default, {
                    Component: f,
                    route: c
                });
                const d = h.props[u],
                    p = d ? d === !0 ? c.params : typeof d == "function" ? d(c) : d : null,
                    g = sg(f, ct({}, p, e, {
                        onVnodeUnmounted: m => {
                            m.component.isUnmounted && (h.instances[u] = null)
                        },
                        ref: l
                    }));
                return Uf(t.default, {
                    Component: g,
                    route: c
                }) || g
            }
        }
    });

function Uf(n, e) {
    if (!n) return null;
    const t = n(e);
    return t.length === 1 ? t[0] : t
}
const _g = cx;

function ux(n) {
    const e = By(n.routes, n),
        t = n.parseQuery || tx,
        i = n.stringifyQuery || Lf,
        r = n.history,
        s = Ps(),
        o = Ps(),
        a = Ps(),
        l = b0(vi);
    let c = vi;
    jr && n.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = jl.bind(null, H => "" + H),
        h = jl.bind(null, ex),
        f = jl.bind(null, Xa);

    function d(H, ce) {
        let ae, le;
        return lg(H) ? (ae = e.getRecordMatcher(H), le = ce) : le = H, e.addRoute(le, ae)
    }

    function p(H) {
        const ce = e.getRecordMatcher(H);
        ce && e.removeRoute(ce)
    }

    function _() {
        return e.getRoutes().map(H => H.record)
    }

    function g(H) {
        return !!e.getRecordMatcher(H)
    }

    function m(H, ce) {
        if (ce = ct({}, ce || l.value), typeof H == "string") {
            const E = Jl(t, H, ce.path),
                N = e.resolve({
                    path: E.path
                }, ce),
                U = r.createHref(E.fullPath);
            return ct(E, N, {
                params: f(N.params),
                hash: Xa(E.hash),
                redirectedFrom: void 0,
                href: U
            })
        }
        let ae;
        if ("path" in H) ae = ct({}, H, {
            path: Jl(t, H.path, ce.path).path
        });
        else {
            const E = ct({}, H.params);
            for (const N in E) E[N] == null && delete E[N];
            ae = ct({}, H, {
                params: h(E)
            }), ce.params = h(ce.params)
        }
        const le = e.resolve(ae, ce),
            Ce = H.hash || "";
        le.params = u(f(le.params));
        const I = dy(i, ct({}, H, {
                hash: Jy(Ce),
                path: le.path
            })),
            w = r.createHref(I);
        return ct({
            fullPath: I,
            hash: Ce,
            query: i === Lf ? nx(H.query) : H.query || {}
        }, le, {
            redirectedFrom: void 0,
            href: w
        })
    }

    function y(H) {
        return typeof H == "string" ? Jl(t, H, l.value.path) : ct({}, H)
    }

    function v(H, ce) {
        if (c !== H) return ps(8, {
            from: ce,
            to: H
        })
    }

    function x(H) {
        return R(H)
    }

    function C(H) {
        return x(ct(y(H), {
            replace: !0
        }))
    }

    function S(H) {
        const ce = H.matched[H.matched.length - 1];
        if (ce && ce.redirect) {
            const {
                redirect: ae
            } = ce;
            let le = typeof ae == "function" ? ae(H) : ae;
            return typeof le == "string" && (le = le.includes("?") || le.includes("#") ? le = y(le) : {
                path: le
            }, le.params = {}), ct({
                query: H.query,
                hash: H.hash,
                params: "path" in le ? {} : H.params
            }, le)
        }
    }

    function R(H, ce) {
        const ae = c = m(H),
            le = l.value,
            Ce = H.state,
            I = H.force,
            w = H.replace === !0,
            E = S(ae);
        if (E) return R(ct(y(E), {
            state: typeof E == "object" ? ct({}, Ce, E.state) : Ce,
            force: I,
            replace: w
        }), ce || ae);
        const N = ae;
        N.redirectedFrom = ce;
        let U;
        return !I && py(i, le, ae) && (U = ps(16, {
            to: N,
            from: le
        }), de(le, le, !0, !1)), (U ? Promise.resolve(U) : A(N, le)).catch(W => ii(W) ? ii(W, 2) ? W : pe(W) : J(W, N, le)).then(W => {
            if (W) {
                if (ii(W, 2)) return R(ct({
                    replace: w
                }, y(W.to), {
                    state: typeof W.to == "object" ? ct({}, Ce, W.to.state) : Ce,
                    force: I
                }), ce || N)
            } else W = ee(N, le, !0, w, Ce);
            return G(N, le, W), W
        })
    }

    function F(H, ce) {
        const ae = v(H, ce);
        return ae ? Promise.reject(ae) : Promise.resolve()
    }

    function T(H) {
        const ce = me.values().next().value;
        return ce && typeof ce.runWithContext == "function" ? ce.runWithContext(H) : H()
    }

    function A(H, ce) {
        let ae;
        const [le, Ce, I] = hx(H, ce);
        ae = Zl(le.reverse(), "beforeRouteLeave", H, ce);
        for (const E of le) E.leaveGuards.forEach(N => {
            ae.push(Ri(N, H, ce))
        });
        const w = F.bind(null, H, ce);
        return ae.push(w), Pe(ae).then(() => {
            ae = [];
            for (const E of s.list()) ae.push(Ri(E, H, ce));
            return ae.push(w), Pe(ae)
        }).then(() => {
            ae = Zl(Ce, "beforeRouteUpdate", H, ce);
            for (const E of Ce) E.updateGuards.forEach(N => {
                ae.push(Ri(N, H, ce))
            });
            return ae.push(w), Pe(ae)
        }).then(() => {
            ae = [];
            for (const E of I)
                if (E.beforeEnter)
                    if (kn(E.beforeEnter))
                        for (const N of E.beforeEnter) ae.push(Ri(N, H, ce));
                    else ae.push(Ri(E.beforeEnter, H, ce));
            return ae.push(w), Pe(ae)
        }).then(() => (H.matched.forEach(E => E.enterCallbacks = {}), ae = Zl(I, "beforeRouteEnter", H, ce), ae.push(w), Pe(ae))).then(() => {
            ae = [];
            for (const E of o.list()) ae.push(Ri(E, H, ce));
            return ae.push(w), Pe(ae)
        }).catch(E => ii(E, 8) ? E : Promise.reject(E))
    }

    function G(H, ce, ae) {
        a.list().forEach(le => T(() => le(H, ce, ae)))
    }

    function ee(H, ce, ae, le, Ce) {
        const I = v(H, ce);
        if (I) return I;
        const w = ce === vi,
            E = jr ? history.state : {};
        ae && (le || w ? r.replace(H.fullPath, ct({
            scroll: w && E && E.scroll
        }, Ce)) : r.push(H.fullPath, Ce)), l.value = H, de(H, ce, ae, w), pe()
    }
    let he;

    function B() {
        he || (he = r.listen((H, ce, ae) => {
            if (!Re.listening) return;
            const le = m(H),
                Ce = S(le);
            if (Ce) {
                R(ct(Ce, {
                    replace: !0
                }), le).catch(Ks);
                return
            }
            c = le;
            const I = l.value;
            jr && by(Sf(I.fullPath, ae.delta), Ml()), A(le, I).catch(w => ii(w, 12) ? w : ii(w, 2) ? (R(w.to, le).then(E => {
                ii(E, 20) && !ae.delta && ae.type === lo.pop && r.go(-1, !1)
            }).catch(Ks), Promise.reject()) : (ae.delta && r.go(-ae.delta, !1), J(w, le, I))).then(w => {
                w = w || ee(le, I, !1), w && (ae.delta && !ii(w, 8) ? r.go(-ae.delta, !1) : ae.type === lo.pop && ii(w, 20) && r.go(-1, !1)), G(le, I, w)
            }).catch(Ks)
        }))
    }
    let V = Ps(),
        q = Ps(),
        j;

    function J(H, ce, ae) {
        pe(H);
        const le = q.list();
        return le.length ? le.forEach(Ce => Ce(H, ce, ae)) : console.error(H), Promise.reject(H)
    }

    function ie() {
        return j && l.value !== vi ? Promise.resolve() : new Promise((H, ce) => {
            V.add([H, ce])
        })
    }

    function pe(H) {
        return j || (j = !H, B(), V.list().forEach(([ce, ae]) => H ? ae(H) : ce()), V.reset()), H
    }

    function de(H, ce, ae, le) {
        const {
            scrollBehavior: Ce
        } = n;
        if (!jr || !Ce) return Promise.resolve();
        const I = !ae && Sy(Sf(H.fullPath, 0)) || (le || !ae) && history.state && history.state.scroll || null;
        return za().then(() => Ce(H, ce, I)).then(w => w && My(w)).catch(w => J(w, H, ce))
    }
    const xe = H => r.go(H);
    let te;
    const me = new Set,
        Re = {
            currentRoute: l,
            listening: !0,
            addRoute: d,
            removeRoute: p,
            hasRoute: g,
            getRoutes: _,
            resolve: m,
            options: n,
            push: x,
            replace: C,
            go: xe,
            back: () => xe(-1),
            forward: () => xe(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: a.add,
            onError: q.add,
            isReady: ie,
            install(H) {
                const ce = this;
                H.component("RouterLink", ox), H.component("RouterView", _g), H.config.globalProperties.$router = ce, Object.defineProperty(H.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => or(l)
                }), jr && !te && l.value === vi && (te = !0, x(r.location).catch(Ce => {}));
                const ae = {};
                for (const Ce in vi) Object.defineProperty(ae, Ce, {
                    get: () => l.value[Ce],
                    enumerable: !0
                });
                H.provide(Wu, ce), H.provide(gg, wm(ae)), H.provide(au, l);
                const le = H.unmount;
                me.add(H), H.unmount = function () {
                    me.delete(H), me.size < 1 && (c = vi, he && he(), he = null, l.value = vi, te = !1, j = !1), le()
                }
            }
        };

    function Pe(H) {
        return H.reduce((ce, ae) => ce.then(() => T(ae)), Promise.resolve())
    }
    return Re
}

function hx(n, e) {
    const t = [],
        i = [],
        r = [],
        s = Math.max(e.matched.length, n.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (n.matched.find(c => ds(c, a)) ? i.push(a) : t.push(a));
        const l = n.matched[o];
        l && (e.matched.find(c => ds(c, l)) || r.push(l))
    }
    return [t, i, r]
}
const fx = {
        __name: "App",
        setup(n) {
            return (e, t) => (be(), Jt(or(_g)))
        }
    },
    dx = "modulepreload",
    px = function (n) {
        return "/" + n
    },
    Ff = {},
    ri = function (e, t, i) {
        let r = Promise.resolve();
        if (t && t.length > 0) {
            const s = document.getElementsByTagName("link"),
                o = document.querySelector("meta[property=csp-nonce]"),
                a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
            r = Promise.all(t.map(l => {
                if (l = px(l), l in Ff) return;
                Ff[l] = !0;
                const c = l.endsWith(".css"),
                    u = c ? '[rel="stylesheet"]' : "";
                if (!!i)
                    for (let d = s.length - 1; d >= 0; d--) {
                        const p = s[d];
                        if (p.href === l && (!c || p.rel === "stylesheet")) return
                    } else if (document.querySelector(`link[href="${l}"]${u}`)) return;
                const f = document.createElement("link");
                if (f.rel = c ? "stylesheet" : dx, c || (f.as = "script", f.crossOrigin = ""), f.href = l, a && f.setAttribute("nonce", a), document.head.appendChild(f), c) return new Promise((d, p) => {
                    f.addEventListener("load", d), f.addEventListener("error", () => p(new Error(`Unable to preload CSS for ${l}`)))
                })
            }))
        }
        return r.then(() => e()).catch(s => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s
        })
    };
const $u = "160",
    wr = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    Er = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    mx = 0,
    Bf = 1,
    gx = 2,
    vg = 1,
    _x = 2,
    hi = 3,
    zi = 0,
    un = 1,
    En = 2,
    Oi = 0,
    as = 1,
    kf = 2,
    zf = 3,
    Gf = 4,
    vx = 5,
    Qi = 100,
    yx = 101,
    xx = 102,
    Vf = 103,
    Hf = 104,
    Mx = 200,
    bx = 201,
    Sx = 202,
    Tx = 203,
    lu = 204,
    cu = 205,
    wx = 206,
    Ex = 207,
    Ax = 208,
    Rx = 209,
    Cx = 210,
    Px = 211,
    Lx = 212,
    Ix = 213,
    Dx = 214,
    Ox = 0,
    Nx = 1,
    Ux = 2,
    qa = 3,
    Fx = 4,
    Bx = 5,
    kx = 6,
    zx = 7,
    bl = 0,
    Gx = 1,
    Vx = 2,
    Ni = 0,
    Hx = 1,
    Wx = 2,
    $x = 3,
    yg = 4,
    Xx = 5,
    qx = 6,
    Wf = "attached",
    Yx = "detached",
    Xu = 300,
    hr = 301,
    fr = 302,
    Ya = 303,
    Ka = 304,
    wo = 306,
    co = 1e3,
    _n = 1001,
    uo = 1002,
    It = 1003,
    ja = 1004,
    Js = 1005,
    cn = 1006,
    qu = 1007,
    dr = 1008,
    Ui = 1009,
    Kx = 1010,
    jx = 1011,
    Yu = 1012,
    xg = 1013,
    Pi = 1014,
    qn = 1015,
    ho = 1016,
    Mg = 1017,
    bg = 1018,
    lr = 1020,
    Jx = 1021,
    on = 1023,
    Zx = 1024,
    Qx = 1025,
    cr = 1026,
    ms = 1027,
    eM = 1028,
    Sg = 1029,
    tM = 1030,
    Tg = 1031,
    wg = 1033,
    Ql = 33776,
    ec = 33777,
    tc = 33778,
    nc = 33779,
    $f = 35840,
    Xf = 35841,
    qf = 35842,
    Yf = 35843,
    Eg = 36196,
    Kf = 37492,
    jf = 37496,
    Jf = 37808,
    Zf = 37809,
    Qf = 37810,
    ed = 37811,
    td = 37812,
    nd = 37813,
    id = 37814,
    rd = 37815,
    sd = 37816,
    od = 37817,
    ad = 37818,
    ld = 37819,
    cd = 37820,
    ud = 37821,
    ic = 36492,
    hd = 36494,
    fd = 36495,
    nM = 36283,
    dd = 36284,
    pd = 36285,
    md = 36286,
    fo = 2300,
    po = 2301,
    rc = 2302,
    gd = 2400,
    _d = 2401,
    vd = 2402,
    iM = 2500,
    Ag = 3e3,
    ur = 3001,
    rM = 3200,
    sM = 3201,
    xr = 0,
    oM = 1,
    vn = "",
    Pt = "srgb",
    mi = "srgb-linear",
    Ku = "display-p3",
    Sl = "display-p3-linear",
    Ja = "linear",
    vt = "srgb",
    Za = "rec709",
    Qa = "p3",
    Ar = 7680,
    yd = 519,
    aM = 512,
    lM = 513,
    cM = 514,
    Rg = 515,
    uM = 516,
    hM = 517,
    fM = 518,
    dM = 519,
    uu = 35044,
    xd = "300 es",
    hu = 1035,
    Yn = 2e3,
    mo = 2001;
class Mr {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
            e.target = null
        }
    }
}
const Wt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Md = 1234567;
const ls = Math.PI / 180,
    gs = 180 / Math.PI;

function Rn() {
    const n = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        i = Math.random() * 4294967295 | 0;
    return (Wt[n & 255] + Wt[n >> 8 & 255] + Wt[n >> 16 & 255] + Wt[n >> 24 & 255] + "-" + Wt[e & 255] + Wt[e >> 8 & 255] + "-" + Wt[e >> 16 & 15 | 64] + Wt[e >> 24 & 255] + "-" + Wt[t & 63 | 128] + Wt[t >> 8 & 255] + "-" + Wt[t >> 16 & 255] + Wt[t >> 24 & 255] + Wt[i & 255] + Wt[i >> 8 & 255] + Wt[i >> 16 & 255] + Wt[i >> 24 & 255]).toLowerCase()
}

function Lt(n, e, t) {
    return Math.max(e, Math.min(t, n))
}

function ju(n, e) {
    return (n % e + e) % e
}

function pM(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}

function mM(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}

function Zs(n, e, t) {
    return (1 - t) * n + t * e
}

function gM(n, e, t, i) {
    return Zs(n, e, 1 - Math.exp(-t * i))
}

function _M(n, e = 1) {
    return e - Math.abs(ju(n, e * 2) - e)
}

function vM(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n))
}

function yM(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10))
}

function xM(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}

function MM(n, e) {
    return n + Math.random() * (e - n)
}

function bM(n) {
    return n * (.5 - Math.random())
}

function SM(n) {
    n !== void 0 && (Md = n);
    let e = Md += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function TM(n) {
    return n * ls
}

function wM(n) {
    return n * gs
}

function fu(n) {
    return (n & n - 1) === 0 && n !== 0
}

function EM(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}

function el(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}

function AM(n, e, t, i, r) {
    const s = Math.cos,
        o = Math.sin,
        a = s(t / 2),
        l = o(t / 2),
        c = s((e + i) / 2),
        u = o((e + i) / 2),
        h = s((e - i) / 2),
        f = o((e - i) / 2),
        d = s((i - e) / 2),
        p = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(a * u, l * h, l * f, a * c);
        break;
    case "YZY":
        n.set(l * f, a * u, l * h, a * c);
        break;
    case "ZXZ":
        n.set(l * h, l * f, a * u, a * c);
        break;
    case "XZX":
        n.set(a * u, l * p, l * d, a * c);
        break;
    case "YXY":
        n.set(l * d, a * u, l * p, a * c);
        break;
    case "ZYZ":
        n.set(l * p, l * d, a * u, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}

function Xn(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}

function ft(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const tl = {
    DEG2RAD: ls,
    RAD2DEG: gs,
    generateUUID: Rn,
    clamp: Lt,
    euclideanModulo: ju,
    mapLinear: pM,
    inverseLerp: mM,
    lerp: Zs,
    damp: gM,
    pingpong: _M,
    smoothstep: vM,
    smootherstep: yM,
    randInt: xM,
    randFloat: MM,
    randFloatSpread: bM,
    seededRandom: SM,
    degToRad: TM,
    radToDeg: wM,
    isPowerOfTwo: fu,
    ceilPowerOfTwo: EM,
    floorPowerOfTwo: el,
    setQuaternionFromProperEuler: AM,
    normalize: ft,
    denormalize: Xn
};
class ue {
    constructor(e = 0, t = 0) {
        ue.prototype.isVector2 = !0, this.x = e, this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e, this.y = t, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(Lt(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this
    }
    rotateAround(e, t) {
        const i = Math.cos(t),
            r = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
        return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
class Qe {
    constructor(e, t, i, r, s, o, a, l, c) {
        Qe.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, l, c)
    }
    set(e, t, i, r, s, o, a, l, c) {
        const u = this.elements;
        return u[0] = e, u[1] = r, u[2] = a, u[3] = t, u[4] = s, u[5] = l, u[6] = i, u[7] = o, u[8] = c, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[3],
            l = i[6],
            c = i[1],
            u = i[4],
            h = i[7],
            f = i[2],
            d = i[5],
            p = i[8],
            _ = r[0],
            g = r[3],
            m = r[6],
            y = r[1],
            v = r[4],
            x = r[7],
            C = r[2],
            S = r[5],
            R = r[8];
        return s[0] = o * _ + a * y + l * C, s[3] = o * g + a * v + l * S, s[6] = o * m + a * x + l * R, s[1] = c * _ + u * y + h * C, s[4] = c * g + u * v + h * S, s[7] = c * m + u * x + h * R, s[2] = f * _ + d * y + p * C, s[5] = f * g + d * v + p * S, s[8] = f * m + d * x + p * R, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8];
        return t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = u * o - a * c,
            f = a * l - u * s,
            d = c * s - o * l,
            p = t * h + i * f + r * d;
        if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const _ = 1 / p;
        return e[0] = h * _, e[1] = (r * c - u * i) * _, e[2] = (a * i - r * o) * _, e[3] = f * _, e[4] = (u * t - r * l) * _, e[5] = (r * s - a * t) * _, e[6] = d * _, e[7] = (i * l - c * t) * _, e[8] = (o * t - i * s) * _, this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s),
            c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1), this
    }
    scale(e, t) {
        return this.premultiply(sc.makeScale(e, t)), this
    }
    rotate(e) {
        return this.premultiply(sc.makeRotation(-e)), this
    }
    translate(e, t) {
        return this.premultiply(sc.makeTranslation(e, t)), this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
    }
    makeRotation(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const sc = new Qe;

function Cg(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535) return !0;
    return !1
}
const RM = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};

function Jr(n, e) {
    return new RM[n](e)
}

function go(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}

function CM() {
    const n = go("canvas");
    return n.style.display = "block", n
}
const bd = {};

function Qs(n) {
    n in bd || (bd[n] = !0, console.warn(n))
}
const Sd = new Qe().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
    Td = new Qe().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
    ko = {
        [mi]: {
            transfer: Ja,
            primaries: Za,
            toReference: n => n,
            fromReference: n => n
        },
        [Pt]: {
            transfer: vt,
            primaries: Za,
            toReference: n => n.convertSRGBToLinear(),
            fromReference: n => n.convertLinearToSRGB()
        },
        [Sl]: {
            transfer: Ja,
            primaries: Qa,
            toReference: n => n.applyMatrix3(Td),
            fromReference: n => n.applyMatrix3(Sd)
        },
        [Ku]: {
            transfer: vt,
            primaries: Qa,
            toReference: n => n.convertSRGBToLinear().applyMatrix3(Td),
            fromReference: n => n.applyMatrix3(Sd).convertLinearToSRGB()
        }
    },
    PM = new Set([mi, Sl]),
    dt = {
        enabled: !0,
        _workingColorSpace: mi,
        get workingColorSpace() {
            return this._workingColorSpace
        },
        set workingColorSpace(n) {
            if (!PM.has(n)) throw new Error(`Unsupported working color space, "${n}".`);
            this._workingColorSpace = n
        },
        convert: function (n, e, t) {
            if (this.enabled === !1 || e === t || !e || !t) return n;
            const i = ko[e].toReference,
                r = ko[t].fromReference;
            return r(i(n))
        },
        fromWorkingColorSpace: function (n, e) {
            return this.convert(n, this._workingColorSpace, e)
        },
        toWorkingColorSpace: function (n, e) {
            return this.convert(n, e, this._workingColorSpace)
        },
        getPrimaries: function (n) {
            return ko[n].primaries
        },
        getTransfer: function (n) {
            return n === vn ? Ja : ko[n].transfer
        }
    };

function cs(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}

function oc(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Rr;
class Pg {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            Rr === void 0 && (Rr = go("canvas")), Rr.width = e.width, Rr.height = e.height;
            const i = Rr.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Rr
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = go("canvas");
            t.width = e.width, t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height),
                s = r.data;
            for (let o = 0; o < s.length; o++) s[o] = cs(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0), t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(cs(t[i] / 255) * 255) : t[i] = cs(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
    }
}
let LM = 0;
class ir {
    constructor(e = null) {
        this.isSource = !0, Object.defineProperty(this, "id", {
            value: LM++
        }), this.uuid = Rn(), this.data = e, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const i = {
                uuid: this.uuid,
                url: ""
            },
            r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++) r[o].isDataTexture ? s.push(ac(r[o].image)) : s.push(ac(r[o]))
            } else s = ac(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i), i
    }
}

function ac(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? Pg.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let IM = 0;
class zt extends Mr {
    constructor(e = zt.DEFAULT_IMAGE, t = zt.DEFAULT_MAPPING, i = _n, r = _n, s = cn, o = dr, a = on, l = Ui, c = zt.DEFAULT_ANISOTROPY, u = vn) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: IM++
        }), this.uuid = Rn(), this.name = "", this.source = new ir(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new ue(0, 0), this.repeat = new ue(1, 1), this.center = new ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Qe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof u == "string" ? this.colorSpace = u : (Qs("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = u === ur ? Pt : vn), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e = null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Xu) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case co:
            e.x = e.x - Math.floor(e.x);
            break;
        case _n:
            e.x = e.x < 0 ? 0 : 1;
            break;
        case uo:
            Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
            break
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case co:
            e.y = e.y - Math.floor(e.y);
            break;
        case _n:
            e.y = e.y < 0 ? 0 : 1;
            break;
        case uo:
            Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
            break
        }
        return this.flipY && (e.y = 1 - e.y), e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, this.source.needsUpdate = !0)
    }
    get encoding() {
        return Qs("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Pt ? ur : Ag
    }
    set encoding(e) {
        Qs("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === ur ? Pt : vn
    }
}
zt.DEFAULT_IMAGE = null;
zt.DEFAULT_MAPPING = Xu;
zt.DEFAULT_ANISOTROPY = 1;
class pt {
    constructor(e = 0, t = 0, i = 0, r = 1) {
        pt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e, this.y = t, this.z = i, this.w = r, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setW(e) {
        return this.w = e, this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = this.w,
            o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements,
            c = l[0],
            u = l[4],
            h = l[8],
            f = l[1],
            d = l[5],
            p = l[9],
            _ = l[2],
            g = l[6],
            m = l[10];
        if (Math.abs(u - f) < .01 && Math.abs(h - _) < .01 && Math.abs(p - g) < .01) {
            if (Math.abs(u + f) < .1 && Math.abs(h + _) < .1 && Math.abs(p + g) < .1 && Math.abs(c + d + m - 3) < .1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const v = (c + 1) / 2,
                x = (d + 1) / 2,
                C = (m + 1) / 2,
                S = (u + f) / 4,
                R = (h + _) / 4,
                F = (p + g) / 4;
            return v > x && v > C ? v < .01 ? (i = 0, r = .707106781, s = .707106781) : (i = Math.sqrt(v), r = S / i, s = R / i) : x > C ? x < .01 ? (i = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(x), i = S / r, s = F / r) : C < .01 ? (i = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(C), i = R / s, r = F / s), this.set(i, r, s, t), this
        }
        let y = Math.sqrt((g - p) * (g - p) + (h - _) * (h - _) + (f - u) * (f - u));
        return Math.abs(y) < .001 && (y = 1), this.x = (g - p) / y, this.y = (h - _) / y, this.z = (f - u) / y, this.w = Math.acos((c + d + m - 1) / 2), this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class DM extends Mr {
    constructor(e = 1, t = 1, i = {}) {
        super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new pt(0, 0, e, t), this.scissorTest = !1, this.viewport = new pt(0, 0, e, t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i.encoding !== void 0 && (Qs("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), i.colorSpace = i.encoding === ur ? Pt : vn), i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: cn,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0
        }, i), this.texture = new zt(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps, this.texture.internalFormat = i.internalFormat, this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples
    }
    setSize(e, t, i = 1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new ir(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class pr extends DM {
    constructor(e = 1, t = 1, i = {}) {
        super(e, t, i), this.isWebGLRenderTarget = !0
    }
}
class Lg extends zt {
    constructor(e = null, t = 1, i = 1, r = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        }, this.magFilter = It, this.minFilter = It, this.wrapR = _n, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class OM extends zt {
    constructor(e = null, t = 1, i = 1, r = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        }, this.magFilter = It, this.minFilter = It, this.wrapR = _n, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class Zn {
    constructor(e = 0, t = 0, i = 0, r = 1) {
        this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0],
            c = i[r + 1],
            u = i[r + 2],
            h = i[r + 3];
        const f = s[o + 0],
            d = s[o + 1],
            p = s[o + 2],
            _ = s[o + 3];
        if (a === 0) {
            e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = f, e[t + 1] = d, e[t + 2] = p, e[t + 3] = _;
            return
        }
        if (h !== _ || l !== f || c !== d || u !== p) {
            let g = 1 - a;
            const m = l * f + c * d + u * p + h * _,
                y = m >= 0 ? 1 : -1,
                v = 1 - m * m;
            if (v > Number.EPSILON) {
                const C = Math.sqrt(v),
                    S = Math.atan2(C, m * y);
                g = Math.sin(g * S) / C, a = Math.sin(a * S) / C
            }
            const x = a * y;
            if (l = l * g + f * x, c = c * g + d * x, u = u * g + p * x, h = h * g + _ * x, g === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
                l *= C, c *= C, u *= C, h *= C
            }
        }
        e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r],
            l = i[r + 1],
            c = i[r + 2],
            u = i[r + 3],
            h = s[o],
            f = s[o + 1],
            d = s[o + 2],
            p = s[o + 3];
        return e[t] = a * p + u * h + l * d - c * f, e[t + 1] = l * p + u * f + c * h - a * d, e[t + 2] = c * p + u * d + a * f - l * h, e[t + 3] = u * p - a * h - l * f - c * d, e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e, this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
    }
    setFromEuler(e, t = !0) {
        const i = e._x,
            r = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(i / 2),
            u = a(r / 2),
            h = a(s / 2),
            f = l(i / 2),
            d = l(r / 2),
            p = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = f * u * h + c * d * p, this._y = c * d * h - f * u * p, this._z = c * u * p + f * d * h, this._w = c * u * h - f * d * p;
            break;
        case "YXZ":
            this._x = f * u * h + c * d * p, this._y = c * d * h - f * u * p, this._z = c * u * p - f * d * h, this._w = c * u * h + f * d * p;
            break;
        case "ZXY":
            this._x = f * u * h - c * d * p, this._y = c * d * h + f * u * p, this._z = c * u * p + f * d * h, this._w = c * u * h - f * d * p;
            break;
        case "ZYX":
            this._x = f * u * h - c * d * p, this._y = c * d * h + f * u * p, this._z = c * u * p - f * d * h, this._w = c * u * h + f * d * p;
            break;
        case "YZX":
            this._x = f * u * h + c * d * p, this._y = c * d * h + f * u * p, this._z = c * u * p - f * d * h, this._w = c * u * h - f * d * p;
            break;
        case "XZY":
            this._x = f * u * h - c * d * p, this._y = c * d * h - f * u * p, this._z = c * u * p + f * d * h, this._w = c * u * h + f * d * p;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(), this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2,
            r = Math.sin(i);
        return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this
    }
    setFromRotationMatrix(e) {
        const t = e.elements,
            i = t[0],
            r = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            u = t[6],
            h = t[10],
            f = i + a + h;
        if (f > 0) {
            const d = .5 / Math.sqrt(f + 1);
            this._w = .25 / d, this._x = (u - l) * d, this._y = (s - c) * d, this._z = (o - r) * d
        } else if (i > a && i > h) {
            const d = 2 * Math.sqrt(1 + i - a - h);
            this._w = (u - l) / d, this._x = .25 * d, this._y = (r + o) / d, this._z = (s + c) / d
        } else if (a > h) {
            const d = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - c) / d, this._x = (r + o) / d, this._y = .25 * d, this._z = (l + u) / d
        } else {
            const d = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / d, this._x = (s + c) / d, this._y = (l + u) / d, this._z = .25 * d
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Lt(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0) return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x,
            r = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            u = t._w;
        return this._x = i * u + o * a + r * c - s * l, this._y = r * u + o * l + s * a - i * c, this._z = s * u + o * c + i * l - r * a, this._w = o * u - i * a - r * l - s * c, this._onChangeCallback(), this
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const i = this._x,
            r = this._y,
            s = this._z,
            o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const d = 1 - t;
            return this._w = d * o + t * this._w, this._x = d * i + t * this._x, this._y = d * r + t * this._y, this._z = d * s + t * this._z, this.normalize(), this
        }
        const c = Math.sqrt(l),
            u = Math.atan2(c, a),
            h = Math.sin((1 - t) * u) / c,
            f = Math.sin(t * u) / c;
        return this._w = o * h + this._w * f, this._x = i * h + this._x * f, this._y = r * h + this._y * f, this._z = s * h + this._z * f, this._onChangeCallback(), this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random(),
            t = Math.sqrt(1 - e),
            i = Math.sqrt(e),
            r = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}
class L {
    constructor(e = 0, t = 0, i = 0) {
        L.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
    }
    applyEuler(e) {
        return this.applyQuaternion(wd.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(wd.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this
    }
    applyQuaternion(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = 2 * (o * r - a * i),
            u = 2 * (a * t - s * r),
            h = 2 * (s * i - o * t);
        return this.x = t + l * c + o * h - a * u, this.y = i + l * u + a * c - s * h, this.z = r + l * h + s * u - o * c, this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize()
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
        return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return lc.copy(this).projectOnVector(e), this.sub(lc)
    }
    reflect(e) {
        return this.sub(lc.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(Lt(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y,
            r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = i, this.z = r, this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this
    }
    setFromColor(e) {
        return this.x = e.r, this.y = e.g, this.z = e.b, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2,
            t = Math.random() * Math.PI * 2,
            i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}
const lc = new L,
    wd = new Zn;
class Mn {
    constructor(e = new L(1 / 0, 1 / 0, 1 / 0), t = new L(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = e, this.max = t
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Cn.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Cn.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = Cn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++) e.isMesh === !0 ? e.getVertexPosition(o, Cn) : Cn.fromBufferAttribute(s, o), Cn.applyMatrix4(e.matrixWorld), this.expandByPoint(Cn);
            else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), zo.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), zo.copy(i.boundingBox)), zo.applyMatrix4(e.matrixWorld), this.union(zo)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Cn), Cn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(Ls), Go.subVectors(this.max, Ls), Cr.subVectors(e.a, Ls), Pr.subVectors(e.b, Ls), Lr.subVectors(e.c, Ls), yi.subVectors(Pr, Cr), xi.subVectors(Lr, Pr), Xi.subVectors(Cr, Lr);
        let t = [0, -yi.z, yi.y, 0, -xi.z, xi.y, 0, -Xi.z, Xi.y, yi.z, 0, -yi.x, xi.z, 0, -xi.x, Xi.z, 0, -Xi.x, -yi.y, yi.x, 0, -xi.y, xi.x, 0, -Xi.y, Xi.x, 0];
        return !cc(t, Cr, Pr, Lr, Go) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !cc(t, Cr, Pr, Lr, Go)) ? !1 : (Vo.crossVectors(yi, xi), t = [Vo.x, Vo.y, Vo.z], cc(t, Cr, Pr, Lr, Go))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Cn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Cn).length() * .5), e
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (si[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), si[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), si[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), si[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), si[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), si[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), si[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), si[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(si), this)
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const si = [new L, new L, new L, new L, new L, new L, new L, new L],
    Cn = new L,
    zo = new Mn,
    Cr = new L,
    Pr = new L,
    Lr = new L,
    yi = new L,
    xi = new L,
    Xi = new L,
    Ls = new L,
    Go = new L,
    Vo = new L,
    qi = new L;

function cc(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        qi.fromArray(n, s);
        const a = r.x * Math.abs(qi.x) + r.y * Math.abs(qi.y) + r.z * Math.abs(qi.z),
            l = e.dot(qi),
            c = t.dot(qi),
            u = i.dot(qi);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1
    }
    return !0
}
const NM = new Mn,
    Is = new L,
    uc = new L;
class an {
    constructor(e = new L, t = -1) {
        this.isSphere = !0, this.center = e, this.radius = t
    }
    set(e, t) {
        return this.center.copy(e), this.radius = t, this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : NM.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r), this
    }
    copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
    }
    translate(e) {
        return this.center.add(e), this
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
        Is.subVectors(e, this.center);
        const t = Is.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
                r = (i - this.radius) * .5;
            this.center.addScaledVector(Is, r / i), this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (uc.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Is.copy(e.center).add(uc)), this.expandByPoint(Is.copy(e.center).sub(uc))), this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const oi = new L,
    hc = new L,
    Ho = new L,
    Mi = new L,
    fc = new L,
    Wo = new L,
    dc = new L;
class Eo {
    constructor(e = new L, t = new L(0, 0, -1)) {
        this.origin = e, this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this
    }
    recast(e) {
        return this.origin.copy(this.at(e, oi)), this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = oi.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (oi.copy(this.origin).addScaledVector(this.direction, t), oi.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        hc.copy(e).add(t).multiplyScalar(.5), Ho.copy(t).sub(e).normalize(), Mi.copy(this.origin).sub(hc);
        const s = e.distanceTo(t) * .5,
            o = -this.direction.dot(Ho),
            a = Mi.dot(this.direction),
            l = -Mi.dot(Ho),
            c = Mi.lengthSq(),
            u = Math.abs(1 - o * o);
        let h, f, d, p;
        if (u > 0)
            if (h = o * l - a, f = o * a - l, p = s * u, h >= 0)
                if (f >= -p)
                    if (f <= p) {
                        const _ = 1 / u;
                        h *= _, f *= _, d = h * (h + o * f + 2 * a) + f * (o * h + f + 2 * l) + c
                    } else f = s, h = Math.max(0, -(o * f + a)), d = -h * h + f * (f + 2 * l) + c;
        else f = -s, h = Math.max(0, -(o * f + a)), d = -h * h + f * (f + 2 * l) + c;
        else f <= -p ? (h = Math.max(0, -(-o * s + a)), f = h > 0 ? -s : Math.min(Math.max(-s, -l), s), d = -h * h + f * (f + 2 * l) + c) : f <= p ? (h = 0, f = Math.min(Math.max(-s, -l), s), d = f * (f + 2 * l) + c) : (h = Math.max(0, -(o * s + a)), f = h > 0 ? s : Math.min(Math.max(-s, -l), s), d = -h * h + f * (f + 2 * l) + c);
        else f = o > 0 ? -s : s, h = Math.max(0, -(o * f + a)), d = -h * h + f * (f + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(hc).addScaledVector(Ho, f), d
    }
    intersectSphere(e, t) {
        oi.subVectors(e.center, this.origin);
        const i = oi.dot(this.direction),
            r = oi.dot(oi) - i * i,
            s = e.radius * e.radius;
        if (r > s) return null;
        const o = Math.sqrt(s - r),
            a = i - o,
            l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            h = 1 / this.direction.z,
            f = this.origin;
        return c >= 0 ? (i = (e.min.x - f.x) * c, r = (e.max.x - f.x) * c) : (i = (e.max.x - f.x) * c, r = (e.min.x - f.x) * c), u >= 0 ? (s = (e.min.y - f.y) * u, o = (e.max.y - f.y) * u) : (s = (e.max.y - f.y) * u, o = (e.min.y - f.y) * u), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), h >= 0 ? (a = (e.min.z - f.z) * h, l = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h, l = (e.min.z - f.z) * h), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, oi) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        fc.subVectors(t, e), Wo.subVectors(i, e), dc.crossVectors(fc, Wo);
        let o = this.direction.dot(dc),
            a;
        if (o > 0) {
            if (r) return null;
            a = 1
        } else if (o < 0) a = -1, o = -o;
        else return null;
        Mi.subVectors(this.origin, e);
        const l = a * this.direction.dot(Wo.crossVectors(Mi, Wo));
        if (l < 0) return null;
        const c = a * this.direction.dot(fc.cross(Mi));
        if (c < 0 || l + c > o) return null;
        const u = -a * Mi.dot(dc);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class qe {
    constructor(e, t, i, r, s, o, a, l, c, u, h, f, d, p, _, g) {
        qe.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, h, f, d, p, _, g)
    }
    set(e, t, i, r, s, o, a, l, c, u, h, f, d, p, _, g) {
        const m = this.elements;
        return m[0] = e, m[4] = t, m[8] = i, m[12] = r, m[1] = s, m[5] = o, m[9] = a, m[13] = l, m[2] = c, m[6] = u, m[10] = h, m[14] = f, m[3] = d, m[7] = p, m[11] = _, m[15] = g, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return new qe().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
    }
    copyPosition(e) {
        const t = this.elements,
            i = e.elements;
        return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(e) {
        const t = this.elements,
            i = e.elements,
            r = 1 / Ir.setFromMatrixColumn(e, 0).length(),
            s = 1 / Ir.setFromMatrixColumn(e, 1).length(),
            o = 1 / Ir.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromEuler(e) {
        const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z,
            o = Math.cos(i),
            a = Math.sin(i),
            l = Math.cos(r),
            c = Math.sin(r),
            u = Math.cos(s),
            h = Math.sin(s);
        if (e.order === "XYZ") {
            const f = o * u,
                d = o * h,
                p = a * u,
                _ = a * h;
            t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = d + p * c, t[5] = f - _ * c, t[9] = -a * l, t[2] = _ - f * c, t[6] = p + d * c, t[10] = o * l
        } else if (e.order === "YXZ") {
            const f = l * u,
                d = l * h,
                p = c * u,
                _ = c * h;
            t[0] = f + _ * a, t[4] = p * a - d, t[8] = o * c, t[1] = o * h, t[5] = o * u, t[9] = -a, t[2] = d * a - p, t[6] = _ + f * a, t[10] = o * l
        } else if (e.order === "ZXY") {
            const f = l * u,
                d = l * h,
                p = c * u,
                _ = c * h;
            t[0] = f - _ * a, t[4] = -o * h, t[8] = p + d * a, t[1] = d + p * a, t[5] = o * u, t[9] = _ - f * a, t[2] = -o * c, t[6] = a, t[10] = o * l
        } else if (e.order === "ZYX") {
            const f = o * u,
                d = o * h,
                p = a * u,
                _ = a * h;
            t[0] = l * u, t[4] = p * c - d, t[8] = f * c + _, t[1] = l * h, t[5] = _ * c + f, t[9] = d * c - p, t[2] = -c, t[6] = a * l, t[10] = o * l
        } else if (e.order === "YZX") {
            const f = o * l,
                d = o * c,
                p = a * l,
                _ = a * c;
            t[0] = l * u, t[4] = _ - f * h, t[8] = p * h + d, t[1] = h, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = d * h + p, t[10] = f - _ * h
        } else if (e.order === "XZY") {
            const f = o * l,
                d = o * c,
                p = a * l,
                _ = a * c;
            t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = f * h + _, t[5] = o * u, t[9] = d * h - p, t[2] = p * h - d, t[6] = a * u, t[10] = _ * h + f
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(UM, e, FM)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return pn.subVectors(e, t), pn.lengthSq() === 0 && (pn.z = 1), pn.normalize(), bi.crossVectors(i, pn), bi.lengthSq() === 0 && (Math.abs(i.z) === 1 ? pn.x += 1e-4 : pn.z += 1e-4, pn.normalize(), bi.crossVectors(i, pn)), bi.normalize(), $o.crossVectors(pn, bi), r[0] = bi.x, r[4] = $o.x, r[8] = pn.x, r[1] = bi.y, r[5] = $o.y, r[9] = pn.y, r[2] = bi.z, r[6] = $o.z, r[10] = pn.z, this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[4],
            l = i[8],
            c = i[12],
            u = i[1],
            h = i[5],
            f = i[9],
            d = i[13],
            p = i[2],
            _ = i[6],
            g = i[10],
            m = i[14],
            y = i[3],
            v = i[7],
            x = i[11],
            C = i[15],
            S = r[0],
            R = r[4],
            F = r[8],
            T = r[12],
            A = r[1],
            G = r[5],
            ee = r[9],
            he = r[13],
            B = r[2],
            V = r[6],
            q = r[10],
            j = r[14],
            J = r[3],
            ie = r[7],
            pe = r[11],
            de = r[15];
        return s[0] = o * S + a * A + l * B + c * J, s[4] = o * R + a * G + l * V + c * ie, s[8] = o * F + a * ee + l * q + c * pe, s[12] = o * T + a * he + l * j + c * de, s[1] = u * S + h * A + f * B + d * J, s[5] = u * R + h * G + f * V + d * ie, s[9] = u * F + h * ee + f * q + d * pe, s[13] = u * T + h * he + f * j + d * de, s[2] = p * S + _ * A + g * B + m * J, s[6] = p * R + _ * G + g * V + m * ie, s[10] = p * F + _ * ee + g * q + m * pe, s[14] = p * T + _ * he + g * j + m * de, s[3] = y * S + v * A + x * B + C * J, s[7] = y * R + v * G + x * V + C * ie, s[11] = y * F + v * ee + x * q + C * pe, s[15] = y * T + v * he + x * j + C * de, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[4],
            r = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            u = e[2],
            h = e[6],
            f = e[10],
            d = e[14],
            p = e[3],
            _ = e[7],
            g = e[11],
            m = e[15];
        return p * (+s * l * h - r * c * h - s * a * f + i * c * f + r * a * d - i * l * d) + _ * (+t * l * d - t * c * f + s * o * f - r * o * d + r * c * u - s * l * u) + g * (+t * c * h - t * a * d - s * o * h + i * o * d + s * a * u - i * c * u) + m * (-r * a * u - t * l * h + t * a * f + r * o * h - i * o * f + i * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = e[9],
            f = e[10],
            d = e[11],
            p = e[12],
            _ = e[13],
            g = e[14],
            m = e[15],
            y = h * g * c - _ * f * c + _ * l * d - a * g * d - h * l * m + a * f * m,
            v = p * f * c - u * g * c - p * l * d + o * g * d + u * l * m - o * f * m,
            x = u * _ * c - p * h * c + p * a * d - o * _ * d - u * a * m + o * h * m,
            C = p * h * l - u * _ * l - p * a * f + o * _ * f + u * a * g - o * h * g,
            S = t * y + i * v + r * x + s * C;
        if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / S;
        return e[0] = y * R, e[1] = (_ * f * s - h * g * s - _ * r * d + i * g * d + h * r * m - i * f * m) * R, e[2] = (a * g * s - _ * l * s + _ * r * c - i * g * c - a * r * m + i * l * m) * R, e[3] = (h * l * s - a * f * s - h * r * c + i * f * c + a * r * d - i * l * d) * R, e[4] = v * R, e[5] = (u * g * s - p * f * s + p * r * d - t * g * d - u * r * m + t * f * m) * R, e[6] = (p * l * s - o * g * s - p * r * c + t * g * c + o * r * m - t * l * m) * R, e[7] = (o * f * s - u * l * s + u * r * c - t * f * c - o * r * d + t * l * d) * R, e[8] = x * R, e[9] = (p * h * s - u * _ * s - p * i * d + t * _ * d + u * i * m - t * h * m) * R, e[10] = (o * _ * s - p * a * s + p * i * c - t * _ * c - o * i * m + t * a * m) * R, e[11] = (u * a * s - o * h * s - u * i * c + t * h * c + o * i * d - t * a * d) * R, e[12] = C * R, e[13] = (u * _ * r - p * h * r + p * i * f - t * _ * f - u * i * g + t * h * g) * R, e[14] = (p * a * r - o * _ * r - p * i * l + t * _ * l + o * i * g - t * a * g) * R, e[15] = (o * h * r - u * a * r + u * i * l - t * h * l - o * i * f + t * a * f) * R, this
    }
    scale(e) {
        const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z;
        return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
    }
    makeRotationX(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
    }
    makeRotationY(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t),
            r = Math.sin(t),
            s = 1 - i,
            o = e.x,
            a = e.y,
            l = e.z,
            c = s * o,
            u = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, u * a + i, u * l - r * o, 0, c * l - r * a, u * l + r * o, s * l * l + i, 0, 0, 0, 0, 1), this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this
    }
    compose(e, t, i) {
        const r = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = s + s,
            u = o + o,
            h = a + a,
            f = s * c,
            d = s * u,
            p = s * h,
            _ = o * u,
            g = o * h,
            m = a * h,
            y = l * c,
            v = l * u,
            x = l * h,
            C = i.x,
            S = i.y,
            R = i.z;
        return r[0] = (1 - (_ + m)) * C, r[1] = (d + x) * C, r[2] = (p - v) * C, r[3] = 0, r[4] = (d - x) * S, r[5] = (1 - (f + m)) * S, r[6] = (g + y) * S, r[7] = 0, r[8] = (p + v) * R, r[9] = (g - y) * R, r[10] = (1 - (f + _)) * R, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = Ir.set(r[0], r[1], r[2]).length();
        const o = Ir.set(r[4], r[5], r[6]).length(),
            a = Ir.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Pn.copy(this);
        const c = 1 / s,
            u = 1 / o,
            h = 1 / a;
        return Pn.elements[0] *= c, Pn.elements[1] *= c, Pn.elements[2] *= c, Pn.elements[4] *= u, Pn.elements[5] *= u, Pn.elements[6] *= u, Pn.elements[8] *= h, Pn.elements[9] *= h, Pn.elements[10] *= h, t.setFromRotationMatrix(Pn), i.x = s, i.y = o, i.z = a, this
    }
    makePerspective(e, t, i, r, s, o, a = Yn) {
        const l = this.elements,
            c = 2 * s / (t - e),
            u = 2 * s / (i - r),
            h = (t + e) / (t - e),
            f = (i + r) / (i - r);
        let d, p;
        if (a === Yn) d = -(o + s) / (o - s), p = -2 * o * s / (o - s);
        else if (a === mo) d = -o / (o - s), p = -o * s / (o - s);
        else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = u, l[9] = f, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = d, l[14] = p, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
    }
    makeOrthographic(e, t, i, r, s, o, a = Yn) {
        const l = this.elements,
            c = 1 / (t - e),
            u = 1 / (i - r),
            h = 1 / (o - s),
            f = (t + e) * c,
            d = (i + r) * u;
        let p, _;
        if (a === Yn) p = (o + s) * h, _ = -2 * h;
        else if (a === mo) p = s * h, _ = -1 * h;
        else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -f, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -d, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -p, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
    }
}
const Ir = new L,
    Pn = new qe,
    UM = new L(0, 0, 0),
    FM = new L(1, 1, 1),
    bi = new L,
    $o = new L,
    pn = new L,
    Ed = new qe,
    Ad = new Zn;
class Tl {
    constructor(e = 0, t = 0, i = 0, r = Tl.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e, this._onChangeCallback()
    }
    set(e, t, i, r = this._order) {
        return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(e, t = this._order, i = !0) {
        const r = e.elements,
            s = r[0],
            o = r[4],
            a = r[8],
            l = r[1],
            c = r[5],
            u = r[9],
            h = r[2],
            f = r[6],
            d = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(Lt(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c), this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Lt(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Lt(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-Lt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(Lt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, d));
            break;
        case "XZY":
            this._z = Math.asin(-Lt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, d), this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t, i === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(e, t, i) {
        return Ed.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ed, t, i)
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return Ad.setFromEuler(this), this.setFromQuaternion(Ad, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}
Tl.DEFAULT_ORDER = "XYZ";
class Ig {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let BM = 0;
const Rd = new L,
    Dr = new Zn,
    ai = new qe,
    Xo = new L,
    Ds = new L,
    kM = new L,
    zM = new Zn,
    Cd = new L(1, 0, 0),
    Pd = new L(0, 1, 0),
    Ld = new L(0, 0, 1),
    GM = {
        type: "added"
    },
    VM = {
        type: "removed"
    };
class Mt extends Mr {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: BM++
        }), this.uuid = Rn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Mt.DEFAULT_UP.clone();
        const e = new L,
            t = new Tl,
            i = new Zn,
            r = new L(1, 1, 1);

        function s() {
            i.setFromEuler(t, !1)
        }

        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s), i._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new qe
            },
            normalMatrix: {
                value: new Qe
            }
        }), this.matrix = new qe, this.matrixWorld = new qe, this.matrixAutoUpdate = Mt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Ig, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Dr.setFromAxisAngle(e, t), this.quaternion.multiply(Dr), this
    }
    rotateOnWorldAxis(e, t) {
        return Dr.setFromAxisAngle(e, t), this.quaternion.premultiply(Dr), this
    }
    rotateX(e) {
        return this.rotateOnAxis(Cd, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(Pd, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Ld, e)
    }
    translateOnAxis(e, t) {
        return Rd.copy(e).applyQuaternion(this.quaternion), this.position.add(Rd.multiplyScalar(t)), this
    }
    translateX(e) {
        return this.translateOnAxis(Cd, e)
    }
    translateY(e) {
        return this.translateOnAxis(Pd, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Ld, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ai.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Xo.copy(e) : Xo.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1), Ds.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ai.lookAt(Ds, Xo, this.up) : ai.lookAt(Xo, Ds, this.up), this.quaternion.setFromRotationMatrix(ai), r && (ai.extractRotation(r.matrixWorld), Dr.setFromRotationMatrix(ai), this.quaternion.premultiply(Dr.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(GM)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(VM)), this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1), ai.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ai.multiply(e.parent.matrixWorld)), e.applyMatrix4(ai), this.add(e), e.updateWorldMatrix(!1, !0), this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0) return o
        }
    }
    getObjectsByProperty(e, t, i = []) {
        this[e] === t && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ds, e, kM), e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ds, zM, e), e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string",
            i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius
        }), this.boundingBox !== null && (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray()
        }));

        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
        }
        if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const h = l[c];
                        s(e.shapes, h)
                    } else s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++) a.push(s(e.materials, this.material[l]));
                r.material = a
            } else r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++) r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries),
                l = o(e.materials),
                c = o(e.textures),
                u = o(e.images),
                h = o(e.shapes),
                f = o(e.skeletons),
                d = o(e.animations),
                p = o(e.nodes);
            a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), f.length > 0 && (i.skeletons = f), d.length > 0 && (i.animations = d), p.length > 0 && (i.nodes = p)
        }
        return i.object = r, i;

        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata, l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t = !0) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Mt.DEFAULT_UP = new L(0, 1, 0);
Mt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ln = new L,
    li = new L,
    pc = new L,
    ci = new L,
    Or = new L,
    Nr = new L,
    Id = new L,
    mc = new L,
    gc = new L,
    _c = new L;
let qo = !1;
class gn {
    constructor(e = new L, t = new L, i = new L) {
        this.a = e, this.b = t, this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t), Ln.subVectors(e, t), r.cross(Ln);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Ln.subVectors(r, t), li.subVectors(i, t), pc.subVectors(e, t);
        const o = Ln.dot(Ln),
            a = Ln.dot(li),
            l = Ln.dot(pc),
            c = li.dot(li),
            u = li.dot(pc),
            h = o * c - a * a;
        if (h === 0) return s.set(0, 0, 0), null;
        const f = 1 / h,
            d = (c * l - a * u) * f,
            p = (o * u - a * l) * f;
        return s.set(1 - d - p, p, d)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, ci) === null ? !1 : ci.x >= 0 && ci.y >= 0 && ci.x + ci.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, l) {
        return qo === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), qo = !0), this.getInterpolation(e, t, i, r, s, o, a, l)
    }
    static getInterpolation(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, ci) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, ci.x), l.addScaledVector(o, ci.y), l.addScaledVector(a, ci.z), l)
    }
    static isFrontFacing(e, t, i, r) {
        return Ln.subVectors(i, t), li.subVectors(e, t), Ln.cross(li).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
    }
    getArea() {
        return Ln.subVectors(this.c, this.b), li.subVectors(this.a, this.b), Ln.cross(li).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return gn.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return gn.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return qo === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), qo = !0), gn.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    getInterpolation(e, t, i, r, s) {
        return gn.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return gn.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return gn.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a,
            r = this.b,
            s = this.c;
        let o, a;
        Or.subVectors(r, i), Nr.subVectors(s, i), mc.subVectors(e, i);
        const l = Or.dot(mc),
            c = Nr.dot(mc);
        if (l <= 0 && c <= 0) return t.copy(i);
        gc.subVectors(e, r);
        const u = Or.dot(gc),
            h = Nr.dot(gc);
        if (u >= 0 && h <= u) return t.copy(r);
        const f = l * h - u * c;
        if (f <= 0 && l >= 0 && u <= 0) return o = l / (l - u), t.copy(i).addScaledVector(Or, o);
        _c.subVectors(e, s);
        const d = Or.dot(_c),
            p = Nr.dot(_c);
        if (p >= 0 && d <= p) return t.copy(s);
        const _ = d * c - l * p;
        if (_ <= 0 && c >= 0 && p <= 0) return a = c / (c - p), t.copy(i).addScaledVector(Nr, a);
        const g = u * p - d * h;
        if (g <= 0 && h - u >= 0 && d - p >= 0) return Id.subVectors(s, r), a = (h - u) / (h - u + (d - p)), t.copy(r).addScaledVector(Id, a);
        const m = 1 / (g + _ + f);
        return o = _ * m, a = f * m, t.copy(i).addScaledVector(Or, o).addScaledVector(Nr, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Dg = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Si = {
        h: 0,
        s: 0,
        l: 0
    },
    Yo = {
        h: 0,
        s: 0,
        l: 0
    };

function vc(n, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Fe {
    constructor(e, t, i) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this
    }
    setHex(e, t = Pt) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, dt.toWorkingColorSpace(this, t), this
    }
    setRGB(e, t, i, r = dt.workingColorSpace) {
        return this.r = e, this.g = t, this.b = i, dt.toWorkingColorSpace(this, r), this
    }
    setHSL(e, t, i, r = dt.workingColorSpace) {
        if (e = ju(e, 1), t = Lt(t, 0, 1), i = Lt(i, 0, 1), t === 0) this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t,
                o = 2 * i - s;
            this.r = vc(o, s, e + 1 / 3), this.g = vc(o, s, e), this.b = vc(o, s, e - 1 / 3)
        }
        return dt.toWorkingColorSpace(this, r), this
    }
    setStyle(e, t = Pt) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1],
                a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1],
                o = s.length;
            if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6) return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0) return this.setColorName(e, t);
        return this
    }
    setColorName(e, t = Pt) {
        const i = Dg[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this
    }
    copySRGBToLinear(e) {
        return this.r = cs(e.r), this.g = cs(e.g), this.b = cs(e.b), this
    }
    copyLinearToSRGB(e) {
        return this.r = oc(e.r), this.g = oc(e.g), this.b = oc(e.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(e = Pt) {
        return dt.fromWorkingColorSpace($t.copy(this), e), Math.round(Lt($t.r * 255, 0, 255)) * 65536 + Math.round(Lt($t.g * 255, 0, 255)) * 256 + Math.round(Lt($t.b * 255, 0, 255))
    }
    getHexString(e = Pt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t = dt.workingColorSpace) {
        dt.fromWorkingColorSpace($t.copy(this), t);
        const i = $t.r,
            r = $t.g,
            s = $t.b,
            o = Math.max(i, r, s),
            a = Math.min(i, r, s);
        let l, c;
        const u = (a + o) / 2;
        if (a === o) l = 0, c = 0;
        else {
            const h = o - a;
            switch (c = u <= .5 ? h / (o + a) : h / (2 - o - a), o) {
            case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / h + 2;
                break;
            case s:
                l = (i - r) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l, e.s = c, e.l = u, e
    }
    getRGB(e, t = dt.workingColorSpace) {
        return dt.fromWorkingColorSpace($t.copy(this), t), e.r = $t.r, e.g = $t.g, e.b = $t.b, e
    }
    getStyle(e = Pt) {
        dt.fromWorkingColorSpace($t.copy(this), e);
        const t = $t.r,
            i = $t.g,
            r = $t.b;
        return e !== Pt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(r*255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Si), this.setHSL(Si.h + e, Si.s + t, Si.l + i)
    }
    add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this
    }
    addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
    }
    addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
    }
    multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
    }
    multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
    }
    lerpHSL(e, t) {
        this.getHSL(Si), e.getHSL(Yo);
        const i = Zs(Si.h, Yo.h, t),
            r = Zs(Si.s, Yo.s, t),
            s = Zs(Si.l, Yo.l, t);
        return this.setHSL(i, r, s), this
    }
    setFromVector3(e) {
        return this.r = e.x, this.g = e.y, this.b = e.z, this
    }
    applyMatrix3(e) {
        const t = this.r,
            i = this.g,
            r = this.b,
            s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r, this.g = s[1] * t + s[4] * i + s[7] * r, this.b = s[2] * t + s[5] * i + s[8] * r, this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
    }
    toJSON() {
        return this.getHex()
    }*[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
const $t = new Fe;
Fe.NAMES = Dg;
let HM = 0;
class Vt extends Mr {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: HM++
        }), this.uuid = Rn(), this.name = "", this.type = "Material", this.blending = as, this.side = zi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = lu, this.blendDst = cu, this.blendEquation = Qi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Fe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = qa, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = yd, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ar, this.stencilZFail = Ar, this.stencilZPass = Ar, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== as && (i.blending = this.blending), this.side !== zi && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== lu && (i.blendSrc = this.blendSrc), this.blendDst !== cu && (i.blendDst = this.blendDst), this.blendEquation !== Qi && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== qa && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== yd && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Ar && (i.stencilFail = this.stencilFail), this.stencilZFail !== Ar && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Ar && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);

        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata, o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures),
                o = r(e.images);
            s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s) i[s] = t[s].clone()
        }
        return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Ju extends Vt {
    constructor(e) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Fe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bl, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
const Ct = new L,
    Ko = new ue;
class ut {
    constructor(e, t, i = !1) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = uu, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.gpuType = qn, this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(e) {
        return this.usage = e, this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
    }
    copyAt(e, t, i) {
        e *= this.itemSize, i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e), this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++) Ko.fromBufferAttribute(this, t), Ko.applyMatrix3(e), this.setXY(t, Ko.x, Ko.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++) Ct.fromBufferAttribute(this, t), Ct.applyMatrix3(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++) Ct.fromBufferAttribute(this, t), Ct.applyMatrix4(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) Ct.fromBufferAttribute(this, t), Ct.applyNormalMatrix(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) Ct.fromBufferAttribute(this, t), Ct.transformDirection(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = Xn(i, this.array)), i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = ft(i, this.array)), this.array[e * this.itemSize + t] = i, this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    setX(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize] = t, this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    setY(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize + 1] = t, this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    setZ(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize + 2] = t, this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    setW(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize + 3] = t, this
    }
    setXY(e, t, i) {
        return e *= this.itemSize, this.normalized && (t = ft(t, this.array), i = ft(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), r = ft(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), r = ft(r, this.array), s = ft(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== uu && (e.usage = this.usage), e
    }
}
class Og extends ut {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class Ng extends ut {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class Ge extends ut {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let WM = 0;
const Tn = new qe,
    yc = new Mt,
    Ur = new L,
    mn = new Mn,
    Os = new Mn,
    Bt = new L;
class ht extends Mr {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: WM++
        }), this.uuid = Rn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new(Cg(e) ? Ng : Og)(e, 1) : this.index = e, this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t, this
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i = 0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new Qe().getNormalMatrix(e);
            i.applyNormalMatrix(s), i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(e) {
        return Tn.makeRotationFromQuaternion(e), this.applyMatrix4(Tn), this
    }
    rotateX(e) {
        return Tn.makeRotationX(e), this.applyMatrix4(Tn), this
    }
    rotateY(e) {
        return Tn.makeRotationY(e), this.applyMatrix4(Tn), this
    }
    rotateZ(e) {
        return Tn.makeRotationZ(e), this.applyMatrix4(Tn), this
    }
    translate(e, t, i) {
        return Tn.makeTranslation(e, t, i), this.applyMatrix4(Tn), this
    }
    scale(e, t, i) {
        return Tn.makeScale(e, t, i), this.applyMatrix4(Tn), this
    }
    lookAt(e) {
        return yc.lookAt(e), yc.updateMatrix(), this.applyMatrix4(yc.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Ur).negate(), this.translate(Ur.x, Ur.y, Ur.z), this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new Ge(t, 3)), this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Mn);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new L(-1 / 0, -1 / 0, -1 / 0), new L(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    mn.setFromBufferAttribute(s), this.morphTargetsRelative ? (Bt.addVectors(this.boundingBox.min, mn.min), this.boundingBox.expandByPoint(Bt), Bt.addVectors(this.boundingBox.max, mn.max), this.boundingBox.expandByPoint(Bt)) : (this.boundingBox.expandByPoint(mn.min), this.boundingBox.expandByPoint(mn.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new an);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new L, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (mn.setFromBufferAttribute(e), t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Os.setFromBufferAttribute(a), this.morphTargetsRelative ? (Bt.addVectors(mn.min, Os.min), mn.expandByPoint(Bt), Bt.addVectors(mn.max, Os.max), mn.expandByPoint(Bt)) : (mn.expandByPoint(Os.min), mn.expandByPoint(Os.max))
                }
            mn.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++) Bt.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(Bt));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s],
                        l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++) Bt.fromBufferAttribute(a, c), l && (Ur.fromBufferAttribute(e, c), Bt.add(Ur)), r = Math.max(r, i.distanceToSquared(Bt))
                }
            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index,
            t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array,
            r = t.position.array,
            s = t.normal.array,
            o = t.uv.array,
            a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ut(new Float32Array(4 * a), 4));
        const l = this.getAttribute("tangent").array,
            c = [],
            u = [];
        for (let A = 0; A < a; A++) c[A] = new L, u[A] = new L;
        const h = new L,
            f = new L,
            d = new L,
            p = new ue,
            _ = new ue,
            g = new ue,
            m = new L,
            y = new L;

        function v(A, G, ee) {
            h.fromArray(r, A * 3), f.fromArray(r, G * 3), d.fromArray(r, ee * 3), p.fromArray(o, A * 2), _.fromArray(o, G * 2), g.fromArray(o, ee * 2), f.sub(h), d.sub(h), _.sub(p), g.sub(p);
            const he = 1 / (_.x * g.y - g.x * _.y);
            isFinite(he) && (m.copy(f).multiplyScalar(g.y).addScaledVector(d, -_.y).multiplyScalar(he), y.copy(d).multiplyScalar(_.x).addScaledVector(f, -g.x).multiplyScalar(he), c[A].add(m), c[G].add(m), c[ee].add(m), u[A].add(y), u[G].add(y), u[ee].add(y))
        }
        let x = this.groups;
        x.length === 0 && (x = [{
            start: 0,
            count: i.length
        }]);
        for (let A = 0, G = x.length; A < G; ++A) {
            const ee = x[A],
                he = ee.start,
                B = ee.count;
            for (let V = he, q = he + B; V < q; V += 3) v(i[V + 0], i[V + 1], i[V + 2])
        }
        const C = new L,
            S = new L,
            R = new L,
            F = new L;

        function T(A) {
            R.fromArray(s, A * 3), F.copy(R);
            const G = c[A];
            C.copy(G), C.sub(R.multiplyScalar(R.dot(G))).normalize(), S.crossVectors(F, G);
            const he = S.dot(u[A]) < 0 ? -1 : 1;
            l[A * 4] = C.x, l[A * 4 + 1] = C.y, l[A * 4 + 2] = C.z, l[A * 4 + 3] = he
        }
        for (let A = 0, G = x.length; A < G; ++A) {
            const ee = x[A],
                he = ee.start,
                B = ee.count;
            for (let V = he, q = he + B; V < q; V += 3) T(i[V + 0]), T(i[V + 1]), T(i[V + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index,
            t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new ut(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
            else
                for (let f = 0, d = i.count; f < d; f++) i.setXYZ(f, 0, 0, 0);
            const r = new L,
                s = new L,
                o = new L,
                a = new L,
                l = new L,
                c = new L,
                u = new L,
                h = new L;
            if (e)
                for (let f = 0, d = e.count; f < d; f += 3) {
                    const p = e.getX(f + 0),
                        _ = e.getX(f + 1),
                        g = e.getX(f + 2);
                    r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, _), o.fromBufferAttribute(t, g), u.subVectors(o, s), h.subVectors(r, s), u.cross(h), a.fromBufferAttribute(i, p), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, g), a.add(u), l.add(u), c.add(u), i.setXYZ(p, a.x, a.y, a.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(g, c.x, c.y, c.z)
                } else
                    for (let f = 0, d = t.count; f < d; f += 3) r.fromBufferAttribute(t, f + 0), s.fromBufferAttribute(t, f + 1), o.fromBufferAttribute(t, f + 2), u.subVectors(o, s), h.subVectors(r, s), u.cross(h), i.setXYZ(f + 0, u.x, u.y, u.z), i.setXYZ(f + 1, u.x, u.y, u.z), i.setXYZ(f + 2, u.x, u.y, u.z);
            this.normalizeNormals(), i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++) Bt.fromBufferAttribute(e, t), Bt.normalize(), e.setXYZ(t, Bt.x, Bt.y, Bt.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array,
                u = a.itemSize,
                h = a.normalized,
                f = new c.constructor(l.length * u);
            let d = 0,
                p = 0;
            for (let _ = 0, g = l.length; _ < g; _++) {
                a.isInterleavedBufferAttribute ? d = l[_] * a.data.stride + a.offset : d = l[_] * u;
                for (let m = 0; m < u; m++) f[p++] = c[d++]
            }
            return new ut(f, u, h)
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const t = new ht,
            i = this.index.array,
            r = this.attributes;
        for (const a in r) {
            const l = r[a],
                c = e(l, i);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = [],
                c = s[a];
            for (let u = 0, h = c.length; u < h; u++) {
                const f = c[u],
                    d = e(f, i);
                l.push(d)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
                u = [];
            for (let h = 0, f = c.length; h < f; h++) {
                const d = c[h];
                u.push(d.toJSON(e.data))
            }
            u.length > 0 && (r[l] = u, s = !0)
        }
        s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const c in r) {
            const u = r[c];
            this.setAttribute(c, u.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const u = [],
                h = s[c];
            for (let f = 0, d = h.length; f < d; f++) u.push(h[f].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const h = o[c];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Dd = new qe,
    Yi = new Eo,
    jo = new an,
    Od = new L,
    Fr = new L,
    Br = new L,
    kr = new L,
    xc = new L,
    Jo = new L,
    Zo = new ue,
    Qo = new ue,
    ea = new ue,
    Nd = new L,
    Ud = new L,
    Fd = new L,
    ta = new L,
    na = new L;
class xt extends Mt {
    constructor(e = new ht, t = new Ju) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry,
            r = i.attributes.position,
            s = i.morphAttributes.position,
            o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Jo.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const u = a[l],
                    h = s[l];
                u !== 0 && (xc.fromBufferAttribute(h, e), o ? Jo.addScaledVector(xc, u) : Jo.addScaledVector(xc.sub(t), u))
            }
            t.add(Jo)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.material,
            s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), jo.copy(i.boundingSphere), jo.applyMatrix4(s), Yi.copy(e.ray).recast(e.near), !(jo.containsPoint(Yi.origin) === !1 && (Yi.intersectSphere(jo, Od) === null || Yi.origin.distanceToSquared(Od) > (e.far - e.near) ** 2)) && (Dd.copy(s).invert(), Yi.copy(e.ray).applyMatrix4(Dd), !(i.boundingBox !== null && Yi.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Yi)))
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry,
            o = this.material,
            a = s.index,
            l = s.attributes.position,
            c = s.attributes.uv,
            u = s.attributes.uv1,
            h = s.attributes.normal,
            f = s.groups,
            d = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let p = 0, _ = f.length; p < _; p++) {
                    const g = f[p],
                        m = o[g.materialIndex],
                        y = Math.max(g.start, d.start),
                        v = Math.min(a.count, Math.min(g.start + g.count, d.start + d.count));
                    for (let x = y, C = v; x < C; x += 3) {
                        const S = a.getX(x),
                            R = a.getX(x + 1),
                            F = a.getX(x + 2);
                        r = ia(this, m, e, i, c, u, h, S, R, F), r && (r.faceIndex = Math.floor(x / 3), r.face.materialIndex = g.materialIndex, t.push(r))
                    }
                } else {
                    const p = Math.max(0, d.start),
                        _ = Math.min(a.count, d.start + d.count);
                    for (let g = p, m = _; g < m; g += 3) {
                        const y = a.getX(g),
                            v = a.getX(g + 1),
                            x = a.getX(g + 2);
                        r = ia(this, o, e, i, c, u, h, y, v, x), r && (r.faceIndex = Math.floor(g / 3), t.push(r))
                    }
                } else if (l !== void 0)
                    if (Array.isArray(o))
                        for (let p = 0, _ = f.length; p < _; p++) {
                            const g = f[p],
                                m = o[g.materialIndex],
                                y = Math.max(g.start, d.start),
                                v = Math.min(l.count, Math.min(g.start + g.count, d.start + d.count));
                            for (let x = y, C = v; x < C; x += 3) {
                                const S = x,
                                    R = x + 1,
                                    F = x + 2;
                                r = ia(this, m, e, i, c, u, h, S, R, F), r && (r.faceIndex = Math.floor(x / 3), r.face.materialIndex = g.materialIndex, t.push(r))
                            }
                        } else {
                            const p = Math.max(0, d.start),
                                _ = Math.min(l.count, d.start + d.count);
                            for (let g = p, m = _; g < m; g += 3) {
                                const y = g,
                                    v = g + 1,
                                    x = g + 2;
                                r = ia(this, o, e, i, c, u, h, y, v, x), r && (r.faceIndex = Math.floor(g / 3), t.push(r))
                            }
                        }
    }
}

function $M(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === un ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === zi, a), l === null) return null;
    na.copy(a), na.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(na);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: na.clone(),
        object: n
    }
}

function ia(n, e, t, i, r, s, o, a, l, c) {
    n.getVertexPosition(a, Fr), n.getVertexPosition(l, Br), n.getVertexPosition(c, kr);
    const u = $M(n, e, t, i, Fr, Br, kr, ta);
    if (u) {
        r && (Zo.fromBufferAttribute(r, a), Qo.fromBufferAttribute(r, l), ea.fromBufferAttribute(r, c), u.uv = gn.getInterpolation(ta, Fr, Br, kr, Zo, Qo, ea, new ue)), s && (Zo.fromBufferAttribute(s, a), Qo.fromBufferAttribute(s, l), ea.fromBufferAttribute(s, c), u.uv1 = gn.getInterpolation(ta, Fr, Br, kr, Zo, Qo, ea, new ue), u.uv2 = u.uv1), o && (Nd.fromBufferAttribute(o, a), Ud.fromBufferAttribute(o, l), Fd.fromBufferAttribute(o, c), u.normal = gn.getInterpolation(ta, Fr, Br, kr, Nd, Ud, Fd, new L), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const h = {
            a,
            b: l,
            c,
            normal: new L,
            materialIndex: 0
        };
        gn.getNormal(Fr, Br, kr, h.normal), u.face = h
    }
    return u
}
class Ms extends ht {
    constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
        const l = [],
            c = [],
            u = [],
            h = [];
        let f = 0,
            d = 0;
        p("z", "y", "x", -1, -1, i, t, e, o, s, 0), p("z", "y", "x", 1, -1, i, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, i, t, r, o, 2), p("x", "z", "y", 1, -1, e, i, -t, r, o, 3), p("x", "y", "z", 1, -1, e, t, i, r, s, 4), p("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new Ge(c, 3)), this.setAttribute("normal", new Ge(u, 3)), this.setAttribute("uv", new Ge(h, 2));

        function p(_, g, m, y, v, x, C, S, R, F, T) {
            const A = x / R,
                G = C / F,
                ee = x / 2,
                he = C / 2,
                B = S / 2,
                V = R + 1,
                q = F + 1;
            let j = 0,
                J = 0;
            const ie = new L;
            for (let pe = 0; pe < q; pe++) {
                const de = pe * G - he;
                for (let xe = 0; xe < V; xe++) {
                    const te = xe * A - ee;
                    ie[_] = te * y, ie[g] = de * v, ie[m] = B, c.push(ie.x, ie.y, ie.z), ie[_] = 0, ie[g] = 0, ie[m] = S > 0 ? 1 : -1, u.push(ie.x, ie.y, ie.z), h.push(xe / R), h.push(1 - pe / F), j += 1
                }
            }
            for (let pe = 0; pe < F; pe++)
                for (let de = 0; de < R; de++) {
                    const xe = f + de + V * pe,
                        te = f + de + V * (pe + 1),
                        me = f + (de + 1) + V * (pe + 1),
                        Re = f + (de + 1) + V * pe;
                    l.push(xe, te, Re), l.push(te, me, Re), J += 6
                }
            a.addGroup(d, J, T), d += J, f += j
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Ms(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
    }
}

function _s(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}

function sn(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = _s(n[t]);
        for (const r in i) e[r] = i[r]
    }
    return e
}

function XM(n) {
    const e = [];
    for (let t = 0; t < n.length; t++) e.push(n[t].clone());
    return e
}

function Ug(n) {
    return n.getRenderTarget() === null ? n.outputColorSpace : dt.workingColorSpace
}
const qM = {
    clone: _s,
    merge: sn
};
var YM = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    KM = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Qn extends Vt {
    constructor(e) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = YM, this.fragmentShader = KM, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
            clipCullDistance: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = _s(e.uniforms), this.uniformsGroups = XM(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t
    }
}
class Fg extends Mt {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new qe, this.projectionMatrix = new qe, this.projectionMatrixInverse = new qe, this.coordinateSystem = Yn
    }
    copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class qt extends Fg {
    constructor(e = 50, t = 1, i = .1, r = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = gs * 2 * Math.atan(t), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(ls * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return gs * 2 * Math.atan(Math.tan(ls * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(ls * .5 * this.fov) / this.zoom,
            i = 2 * t,
            r = this.aspect * i,
            s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
                c = o.fullHeight;
            s += o.offsetX * r / l, t -= o.offsetY * i / c, r *= o.width / l, i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
    }
}
const zr = -90,
    Gr = 1;
class jM extends Mt {
    constructor(e, t, i) {
        super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
        const r = new qt(zr, Gr, e, t);
        r.layers = this.layers, this.add(r);
        const s = new qt(zr, Gr, e, t);
        s.layers = this.layers, this.add(s);
        const o = new qt(zr, Gr, e, t);
        o.layers = this.layers, this.add(o);
        const a = new qt(zr, Gr, e, t);
        a.layers = this.layers, this.add(a);
        const l = new qt(zr, Gr, e, t);
        l.layers = this.layers, this.add(l);
        const c = new qt(zr, Gr, e, t);
        c.layers = this.layers, this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem,
            t = this.children.concat(),
            [i, r, s, o, a, l] = t;
        for (const c of t) this.remove(c);
        if (e === Yn) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
        else if (e === mo) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
        else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t) this.add(c), c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {
            renderTarget: i,
            activeMipmapLevel: r
        } = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
        const [s, o, a, l, c, u] = this.children, h = e.getRenderTarget(), f = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), p = e.xr.enabled;
        e.xr.enabled = !1;
        const _ = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, o), e.setRenderTarget(i, 2, r), e.render(t, a), e.setRenderTarget(i, 3, r), e.render(t, l), e.setRenderTarget(i, 4, r), e.render(t, c), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, r), e.render(t, u), e.setRenderTarget(h, f, d), e.xr.enabled = p, i.texture.needsPMREMUpdate = !0
    }
}
class Zu extends zt {
    constructor(e, t, i, r, s, o, a, l, c, u) {
        e = e !== void 0 ? e : [], t = t !== void 0 ? t : hr, super(e, t, i, r, s, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class JM extends pr {
    constructor(e = 1, t = {}) {
        super(e, e, t), this.isWebGLCubeRenderTarget = !0;
        const i = {
                width: e,
                height: e,
                depth: 1
            },
            r = [i, i, i, i, i, i];
        t.encoding !== void 0 && (Qs("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === ur ? Pt : vn), this.texture = new Zu(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : cn
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        const i = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            },
            r = new Ms(5, 5, 5),
            s = new Qn({
                name: "CubemapFromEquirect",
                uniforms: _s(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: un,
                blending: Oi
            });
        s.uniforms.tEquirect.value = t;
        const o = new xt(r, s),
            a = t.minFilter;
        return t.minFilter === dr && (t.minFilter = cn), new jM(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const Mc = new L,
    ZM = new L,
    QM = new Qe;
class Ci {
    constructor(e = new L(1, 0, 0), t = 0) {
        this.isPlane = !0, this.normal = e, this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e), this.constant = t, this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i), this.constant = r, this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Mc.subVectors(i, t).cross(ZM.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this
    }
    copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Mc),
            r = this.normal.dot(i);
        if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || QM.getNormalMatrix(e),
            r = this.coplanarPoint(Mc).applyMatrix4(e),
            s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s), this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal), this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ki = new an,
    ra = new L;
class wl {
    constructor(e = new Ci, t = new Ci, i = new Ci, r = new Ci, s = new Ci, o = new Ci) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t = Yn) {
        const i = this.planes,
            r = e.elements,
            s = r[0],
            o = r[1],
            a = r[2],
            l = r[3],
            c = r[4],
            u = r[5],
            h = r[6],
            f = r[7],
            d = r[8],
            p = r[9],
            _ = r[10],
            g = r[11],
            m = r[12],
            y = r[13],
            v = r[14],
            x = r[15];
        if (i[0].setComponents(l - s, f - c, g - d, x - m).normalize(), i[1].setComponents(l + s, f + c, g + d, x + m).normalize(), i[2].setComponents(l + o, f + u, g + p, x + y).normalize(), i[3].setComponents(l - o, f - u, g - p, x - y).normalize(), i[4].setComponents(l - a, f - h, g - _, x - v).normalize(), t === Yn) i[5].setComponents(l + a, f + h, g + _, x + v).normalize();
        else if (t === mo) i[5].setComponents(a, h, _, v).normalize();
        else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ki.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), Ki.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Ki)
    }
    intersectsSprite(e) {
        return Ki.center.set(0, 0, 0), Ki.radius = .7071067811865476, Ki.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ki)
    }
    intersectsSphere(e) {
        const t = this.planes,
            i = e.center,
            r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r) return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (ra.x = r.normal.x > 0 ? e.max.x : e.min.x, ra.y = r.normal.y > 0 ? e.max.y : e.min.y, ra.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(ra) < 0) return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0) return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}

function Bg() {
    let n = null,
        e = !1,
        t = null,
        i = null;

    function r(s, o) {
        t(s, o), i = n.requestAnimationFrame(r)
    }
    return {
        start: function () {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0)
        },
        stop: function () {
            n.cancelAnimationFrame(i), e = !1
        },
        setAnimationLoop: function (s) {
            t = s
        },
        setContext: function (s) {
            n = s
        }
    }
}

function eb(n, e) {
    const t = e.isWebGL2,
        i = new WeakMap;

    function r(c, u) {
        const h = c.array,
            f = c.usage,
            d = h.byteLength,
            p = n.createBuffer();
        n.bindBuffer(u, p), n.bufferData(u, h, f), c.onUploadCallback();
        let _;
        if (h instanceof Float32Array) _ = n.FLOAT;
        else if (h instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
                if (t) _ = n.HALF_FLOAT;
                else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        else _ = n.UNSIGNED_SHORT;
        else if (h instanceof Int16Array) _ = n.SHORT;
        else if (h instanceof Uint32Array) _ = n.UNSIGNED_INT;
        else if (h instanceof Int32Array) _ = n.INT;
        else if (h instanceof Int8Array) _ = n.BYTE;
        else if (h instanceof Uint8Array) _ = n.UNSIGNED_BYTE;
        else if (h instanceof Uint8ClampedArray) _ = n.UNSIGNED_BYTE;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: p,
            type: _,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: c.version,
            size: d
        }
    }

    function s(c, u, h) {
        const f = u.array,
            d = u._updateRange,
            p = u.updateRanges;
        if (n.bindBuffer(h, c), d.count === -1 && p.length === 0 && n.bufferSubData(h, 0, f), p.length !== 0) {
            for (let _ = 0, g = p.length; _ < g; _++) {
                const m = p[_];
                t ? n.bufferSubData(h, m.start * f.BYTES_PER_ELEMENT, f, m.start, m.count) : n.bufferSubData(h, m.start * f.BYTES_PER_ELEMENT, f.subarray(m.start, m.start + m.count))
            }
            u.clearUpdateRanges()
        }
        d.count !== -1 && (t ? n.bufferSubData(h, d.offset * f.BYTES_PER_ELEMENT, f, d.offset, d.count) : n.bufferSubData(h, d.offset * f.BYTES_PER_ELEMENT, f.subarray(d.offset, d.offset + d.count)), d.count = -1), u.onUploadCallback()
    }

    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data), i.get(c)
    }

    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const u = i.get(c);
        u && (n.deleteBuffer(u.buffer), i.delete(c))
    }

    function l(c, u) {
        if (c.isGLBufferAttribute) {
            const f = i.get(c);
            (!f || f.version < c.version) && i.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = i.get(c);
        if (h === void 0) i.set(c, r(c, u));
        else if (h.version < c.version) {
            if (h.size !== c.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            s(h.buffer, c, u), h.version = c.version
        }
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class Ao extends ht {
    constructor(e = 1, t = 1, i = 1, r = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2,
            o = t / 2,
            a = Math.floor(i),
            l = Math.floor(r),
            c = a + 1,
            u = l + 1,
            h = e / a,
            f = t / l,
            d = [],
            p = [],
            _ = [],
            g = [];
        for (let m = 0; m < u; m++) {
            const y = m * f - o;
            for (let v = 0; v < c; v++) {
                const x = v * h - s;
                p.push(x, -y, 0), _.push(0, 0, 1), g.push(v / a), g.push(1 - m / l)
            }
        }
        for (let m = 0; m < l; m++)
            for (let y = 0; y < a; y++) {
                const v = y + c * m,
                    x = y + c * (m + 1),
                    C = y + 1 + c * (m + 1),
                    S = y + 1 + c * m;
                d.push(v, x, S), d.push(x, C, S)
            }
        this.setIndex(d), this.setAttribute("position", new Ge(p, 3)), this.setAttribute("normal", new Ge(_, 3)), this.setAttribute("uv", new Ge(g, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Ao(e.width, e.height, e.widthSegments, e.heightSegments)
    }
}
var tb = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
    nb = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
    ib = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    rb = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    sb = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
    ob = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    ab = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    lb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    cb = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    ub = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
    hb = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
    fb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    db = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    pb = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    mb = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    gb = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
    _b = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    vb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    yb = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    xb = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    Mb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    bb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    Sb = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    Tb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    wb = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    Eb = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    Ab = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    Rb = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    Cb = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    Pb = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    Lb = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    Ib = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
    Db = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    Ob = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    Nb = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    Ub = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    Fb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    Bb = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    kb = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    zb = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    Gb = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    Vb = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    Hb = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    Wb = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    $b = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    Xb = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    qb = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    Yb = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    Kb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    jb = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    Jb = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    Zb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    Qb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
    eS = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    tS = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    nS = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    iS = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
    rS = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    sS = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    oS = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    aS = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    lS = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    cS = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    uS = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    hS = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    fS = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    dS = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    pS = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    mS = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    gS = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    _S = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    vS = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
    yS = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    xS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    MS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    bS = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    SS = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    TS = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
    wS = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    ES = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    AS = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    RS = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    CS = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    PS = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    LS = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    IS = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    DS = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    OS = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    NS = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    US = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    FS = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    BS = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    kS = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    zS = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    GS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    VS = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    HS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    WS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    $S = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    XS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    qS = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    YS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    KS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    jS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    JS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    ZS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    QS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const eT = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    tT = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    nT = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    iT = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    rT = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    sT = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    oT = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    aT = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    lT = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    cT = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    uT = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    hT = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    fT = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    dT = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    pT = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    mT = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    gT = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    _T = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    vT = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    yT = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    xT = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    MT = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    bT = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    ST = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    TT = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    wT = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    ET = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    AT = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    RT = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    CT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    PT = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    LT = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    IT = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    DT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    je = {
        alphahash_fragment: tb,
        alphahash_pars_fragment: nb,
        alphamap_fragment: ib,
        alphamap_pars_fragment: rb,
        alphatest_fragment: sb,
        alphatest_pars_fragment: ob,
        aomap_fragment: ab,
        aomap_pars_fragment: lb,
        batching_pars_vertex: cb,
        batching_vertex: ub,
        begin_vertex: hb,
        beginnormal_vertex: fb,
        bsdfs: db,
        iridescence_fragment: pb,
        bumpmap_pars_fragment: mb,
        clipping_planes_fragment: gb,
        clipping_planes_pars_fragment: _b,
        clipping_planes_pars_vertex: vb,
        clipping_planes_vertex: yb,
        color_fragment: xb,
        color_pars_fragment: Mb,
        color_pars_vertex: bb,
        color_vertex: Sb,
        common: Tb,
        cube_uv_reflection_fragment: wb,
        defaultnormal_vertex: Eb,
        displacementmap_pars_vertex: Ab,
        displacementmap_vertex: Rb,
        emissivemap_fragment: Cb,
        emissivemap_pars_fragment: Pb,
        colorspace_fragment: Lb,
        colorspace_pars_fragment: Ib,
        envmap_fragment: Db,
        envmap_common_pars_fragment: Ob,
        envmap_pars_fragment: Nb,
        envmap_pars_vertex: Ub,
        envmap_physical_pars_fragment: Yb,
        envmap_vertex: Fb,
        fog_vertex: Bb,
        fog_pars_vertex: kb,
        fog_fragment: zb,
        fog_pars_fragment: Gb,
        gradientmap_pars_fragment: Vb,
        lightmap_fragment: Hb,
        lightmap_pars_fragment: Wb,
        lights_lambert_fragment: $b,
        lights_lambert_pars_fragment: Xb,
        lights_pars_begin: qb,
        lights_toon_fragment: Kb,
        lights_toon_pars_fragment: jb,
        lights_phong_fragment: Jb,
        lights_phong_pars_fragment: Zb,
        lights_physical_fragment: Qb,
        lights_physical_pars_fragment: eS,
        lights_fragment_begin: tS,
        lights_fragment_maps: nS,
        lights_fragment_end: iS,
        logdepthbuf_fragment: rS,
        logdepthbuf_pars_fragment: sS,
        logdepthbuf_pars_vertex: oS,
        logdepthbuf_vertex: aS,
        map_fragment: lS,
        map_pars_fragment: cS,
        map_particle_fragment: uS,
        map_particle_pars_fragment: hS,
        metalnessmap_fragment: fS,
        metalnessmap_pars_fragment: dS,
        morphcolor_vertex: pS,
        morphnormal_vertex: mS,
        morphtarget_pars_vertex: gS,
        morphtarget_vertex: _S,
        normal_fragment_begin: vS,
        normal_fragment_maps: yS,
        normal_pars_fragment: xS,
        normal_pars_vertex: MS,
        normal_vertex: bS,
        normalmap_pars_fragment: SS,
        clearcoat_normal_fragment_begin: TS,
        clearcoat_normal_fragment_maps: wS,
        clearcoat_pars_fragment: ES,
        iridescence_pars_fragment: AS,
        opaque_fragment: RS,
        packing: CS,
        premultiplied_alpha_fragment: PS,
        project_vertex: LS,
        dithering_fragment: IS,
        dithering_pars_fragment: DS,
        roughnessmap_fragment: OS,
        roughnessmap_pars_fragment: NS,
        shadowmap_pars_fragment: US,
        shadowmap_pars_vertex: FS,
        shadowmap_vertex: BS,
        shadowmask_pars_fragment: kS,
        skinbase_vertex: zS,
        skinning_pars_vertex: GS,
        skinning_vertex: VS,
        skinnormal_vertex: HS,
        specularmap_fragment: WS,
        specularmap_pars_fragment: $S,
        tonemapping_fragment: XS,
        tonemapping_pars_fragment: qS,
        transmission_fragment: YS,
        transmission_pars_fragment: KS,
        uv_pars_fragment: jS,
        uv_pars_vertex: JS,
        uv_vertex: ZS,
        worldpos_vertex: QS,
        background_vert: eT,
        background_frag: tT,
        backgroundCube_vert: nT,
        backgroundCube_frag: iT,
        cube_vert: rT,
        cube_frag: sT,
        depth_vert: oT,
        depth_frag: aT,
        distanceRGBA_vert: lT,
        distanceRGBA_frag: cT,
        equirect_vert: uT,
        equirect_frag: hT,
        linedashed_vert: fT,
        linedashed_frag: dT,
        meshbasic_vert: pT,
        meshbasic_frag: mT,
        meshlambert_vert: gT,
        meshlambert_frag: _T,
        meshmatcap_vert: vT,
        meshmatcap_frag: yT,
        meshnormal_vert: xT,
        meshnormal_frag: MT,
        meshphong_vert: bT,
        meshphong_frag: ST,
        meshphysical_vert: TT,
        meshphysical_frag: wT,
        meshtoon_vert: ET,
        meshtoon_frag: AT,
        points_vert: RT,
        points_frag: CT,
        shadow_vert: PT,
        shadow_frag: LT,
        sprite_vert: IT,
        sprite_frag: DT
    },
    Ae = {
        common: {
            diffuse: {
                value: new Fe(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Qe
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Qe
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new Qe
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new Qe
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new Qe
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new Qe
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new Qe
            },
            normalScale: {
                value: new ue(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new Qe
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new Qe
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new Qe
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new Qe
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Fe(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Fe(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Qe
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Qe
            }
        },
        sprite: {
            diffuse: {
                value: new Fe(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new ue(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Qe
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Qe
            },
            alphaTest: {
                value: 0
            }
        }
    },
    Wn = {
        basic: {
            uniforms: sn([Ae.common, Ae.specularmap, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.fog]),
            vertexShader: je.meshbasic_vert,
            fragmentShader: je.meshbasic_frag
        },
        lambert: {
            uniforms: sn([Ae.common, Ae.specularmap, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.fog, Ae.lights, {
                emissive: {
                    value: new Fe(0)
                }
            }]),
            vertexShader: je.meshlambert_vert,
            fragmentShader: je.meshlambert_frag
        },
        phong: {
            uniforms: sn([Ae.common, Ae.specularmap, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.fog, Ae.lights, {
                emissive: {
                    value: new Fe(0)
                },
                specular: {
                    value: new Fe(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: je.meshphong_vert,
            fragmentShader: je.meshphong_frag
        },
        standard: {
            uniforms: sn([Ae.common, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.roughnessmap, Ae.metalnessmap, Ae.fog, Ae.lights, {
                emissive: {
                    value: new Fe(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: je.meshphysical_vert,
            fragmentShader: je.meshphysical_frag
        },
        toon: {
            uniforms: sn([Ae.common, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.gradientmap, Ae.fog, Ae.lights, {
                emissive: {
                    value: new Fe(0)
                }
            }]),
            vertexShader: je.meshtoon_vert,
            fragmentShader: je.meshtoon_frag
        },
        matcap: {
            uniforms: sn([Ae.common, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: je.meshmatcap_vert,
            fragmentShader: je.meshmatcap_frag
        },
        points: {
            uniforms: sn([Ae.points, Ae.fog]),
            vertexShader: je.points_vert,
            fragmentShader: je.points_frag
        },
        dashed: {
            uniforms: sn([Ae.common, Ae.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: je.linedashed_vert,
            fragmentShader: je.linedashed_frag
        },
        depth: {
            uniforms: sn([Ae.common, Ae.displacementmap]),
            vertexShader: je.depth_vert,
            fragmentShader: je.depth_frag
        },
        normal: {
            uniforms: sn([Ae.common, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: je.meshnormal_vert,
            fragmentShader: je.meshnormal_frag
        },
        sprite: {
            uniforms: sn([Ae.sprite, Ae.fog]),
            vertexShader: je.sprite_vert,
            fragmentShader: je.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Qe
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: je.background_vert,
            fragmentShader: je.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: je.backgroundCube_vert,
            fragmentShader: je.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: je.cube_vert,
            fragmentShader: je.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: je.equirect_vert,
            fragmentShader: je.equirect_frag
        },
        distanceRGBA: {
            uniforms: sn([Ae.common, Ae.displacementmap, {
                referencePosition: {
                    value: new L
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: je.distanceRGBA_vert,
            fragmentShader: je.distanceRGBA_frag
        },
        shadow: {
            uniforms: sn([Ae.lights, Ae.fog, {
                color: {
                    value: new Fe(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: je.shadow_vert,
            fragmentShader: je.shadow_frag
        }
    };
Wn.physical = {
    uniforms: sn([Wn.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Qe
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Qe
        },
        clearcoatNormalScale: {
            value: new ue(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Qe
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Qe
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Qe
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Fe(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Qe
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Qe
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Qe
        },
        transmissionSamplerSize: {
            value: new ue
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Qe
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Fe(0)
        },
        specularColor: {
            value: new Fe(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Qe
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Qe
        },
        anisotropyVector: {
            value: new ue
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new Qe
        }
    }]),
    vertexShader: je.meshphysical_vert,
    fragmentShader: je.meshphysical_frag
};
const sa = {
    r: 0,
    b: 0,
    g: 0
};

function OT(n, e, t, i, r, s, o) {
    const a = new Fe(0);
    let l = s === !0 ? 0 : 1,
        c, u, h = null,
        f = 0,
        d = null;

    function p(g, m) {
        let y = !1,
            v = m.isScene === !0 ? m.background : null;
        v && v.isTexture && (v = (m.backgroundBlurriness > 0 ? t : e).get(v)), v === null ? _(a, l) : v && v.isColor && (_(v, 1), y = !0);
        const x = n.xr.getEnvironmentBlendMode();
        x === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : x === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (n.autoClear || y) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), v && (v.isCubeTexture || v.mapping === wo) ? (u === void 0 && (u = new xt(new Ms(1, 1, 1), new Qn({
            name: "BackgroundCubeMaterial",
            uniforms: _s(Wn.backgroundCube.uniforms),
            vertexShader: Wn.backgroundCube.vertexShader,
            fragmentShader: Wn.backgroundCube.fragmentShader,
            side: un,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (C, S, R) {
            this.matrixWorld.copyPosition(R.matrixWorld)
        }, Object.defineProperty(u.material, "envMap", {
            get: function () {
                return this.uniforms.envMap.value
            }
        }), r.update(u)), u.material.uniforms.envMap.value = v, u.material.uniforms.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, u.material.toneMapped = dt.getTransfer(v.colorSpace) !== vt, (h !== v || f !== v.version || d !== n.toneMapping) && (u.material.needsUpdate = !0, h = v, f = v.version, d = n.toneMapping), u.layers.enableAll(), g.unshift(u, u.geometry, u.material, 0, 0, null)) : v && v.isTexture && (c === void 0 && (c = new xt(new Ao(2, 2), new Qn({
            name: "BackgroundMaterial",
            uniforms: _s(Wn.background.uniforms),
            vertexShader: Wn.background.vertexShader,
            fragmentShader: Wn.background.fragmentShader,
            side: zi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function () {
                return this.uniforms.t2D.value
            }
        }), r.update(c)), c.material.uniforms.t2D.value = v, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.toneMapped = dt.getTransfer(v.colorSpace) !== vt, v.matrixAutoUpdate === !0 && v.updateMatrix(), c.material.uniforms.uvTransform.value.copy(v.matrix), (h !== v || f !== v.version || d !== n.toneMapping) && (c.material.needsUpdate = !0, h = v, f = v.version, d = n.toneMapping), c.layers.enableAll(), g.unshift(c, c.geometry, c.material, 0, 0, null))
    }

    function _(g, m) {
        g.getRGB(sa, Ug(n)), i.buffers.color.setClear(sa.r, sa.g, sa.b, m, o)
    }
    return {
        getClearColor: function () {
            return a
        },
        setClearColor: function (g, m = 1) {
            a.set(g), l = m, _(a, l)
        },
        getClearAlpha: function () {
            return l
        },
        setClearAlpha: function (g) {
            l = g, _(a, l)
        },
        render: p
    }
}

function NT(n, e, t, i) {
    const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = i.isWebGL2 || s !== null,
        a = {},
        l = g(null);
    let c = l,
        u = !1;

    function h(B, V, q, j, J) {
        let ie = !1;
        if (o) {
            const pe = _(j, q, V);
            c !== pe && (c = pe, d(c.object)), ie = m(B, j, q, J), ie && y(B, j, q, J)
        } else {
            const pe = V.wireframe === !0;
            (c.geometry !== j.id || c.program !== q.id || c.wireframe !== pe) && (c.geometry = j.id, c.program = q.id, c.wireframe = pe, ie = !0)
        }
        J !== null && t.update(J, n.ELEMENT_ARRAY_BUFFER), (ie || u) && (u = !1, F(B, V, q, j), J !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(J).buffer))
    }

    function f() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }

    function d(B) {
        return i.isWebGL2 ? n.bindVertexArray(B) : s.bindVertexArrayOES(B)
    }

    function p(B) {
        return i.isWebGL2 ? n.deleteVertexArray(B) : s.deleteVertexArrayOES(B)
    }

    function _(B, V, q) {
        const j = q.wireframe === !0;
        let J = a[B.id];
        J === void 0 && (J = {}, a[B.id] = J);
        let ie = J[V.id];
        ie === void 0 && (ie = {}, J[V.id] = ie);
        let pe = ie[j];
        return pe === void 0 && (pe = g(f()), ie[j] = pe), pe
    }

    function g(B) {
        const V = [],
            q = [],
            j = [];
        for (let J = 0; J < r; J++) V[J] = 0, q[J] = 0, j[J] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: V,
            enabledAttributes: q,
            attributeDivisors: j,
            object: B,
            attributes: {},
            index: null
        }
    }

    function m(B, V, q, j) {
        const J = c.attributes,
            ie = V.attributes;
        let pe = 0;
        const de = q.getAttributes();
        for (const xe in de)
            if (de[xe].location >= 0) {
                const me = J[xe];
                let Re = ie[xe];
                if (Re === void 0 && (xe === "instanceMatrix" && B.instanceMatrix && (Re = B.instanceMatrix), xe === "instanceColor" && B.instanceColor && (Re = B.instanceColor)), me === void 0 || me.attribute !== Re || Re && me.data !== Re.data) return !0;
                pe++
            } return c.attributesNum !== pe || c.index !== j
    }

    function y(B, V, q, j) {
        const J = {},
            ie = V.attributes;
        let pe = 0;
        const de = q.getAttributes();
        for (const xe in de)
            if (de[xe].location >= 0) {
                let me = ie[xe];
                me === void 0 && (xe === "instanceMatrix" && B.instanceMatrix && (me = B.instanceMatrix), xe === "instanceColor" && B.instanceColor && (me = B.instanceColor));
                const Re = {};
                Re.attribute = me, me && me.data && (Re.data = me.data), J[xe] = Re, pe++
            } c.attributes = J, c.attributesNum = pe, c.index = j
    }

    function v() {
        const B = c.newAttributes;
        for (let V = 0, q = B.length; V < q; V++) B[V] = 0
    }

    function x(B) {
        C(B, 0)
    }

    function C(B, V) {
        const q = c.newAttributes,
            j = c.enabledAttributes,
            J = c.attributeDivisors;
        q[B] = 1, j[B] === 0 && (n.enableVertexAttribArray(B), j[B] = 1), J[B] !== V && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, V), J[B] = V)
    }

    function S() {
        const B = c.newAttributes,
            V = c.enabledAttributes;
        for (let q = 0, j = V.length; q < j; q++) V[q] !== B[q] && (n.disableVertexAttribArray(q), V[q] = 0)
    }

    function R(B, V, q, j, J, ie, pe) {
        pe === !0 ? n.vertexAttribIPointer(B, V, q, J, ie) : n.vertexAttribPointer(B, V, q, j, J, ie)
    }

    function F(B, V, q, j) {
        if (i.isWebGL2 === !1 && (B.isInstancedMesh || j.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
        v();
        const J = j.attributes,
            ie = q.getAttributes(),
            pe = V.defaultAttributeValues;
        for (const de in ie) {
            const xe = ie[de];
            if (xe.location >= 0) {
                let te = J[de];
                if (te === void 0 && (de === "instanceMatrix" && B.instanceMatrix && (te = B.instanceMatrix), de === "instanceColor" && B.instanceColor && (te = B.instanceColor)), te !== void 0) {
                    const me = te.normalized,
                        Re = te.itemSize,
                        Pe = t.get(te);
                    if (Pe === void 0) continue;
                    const H = Pe.buffer,
                        ce = Pe.type,
                        ae = Pe.bytesPerElement,
                        le = i.isWebGL2 === !0 && (ce === n.INT || ce === n.UNSIGNED_INT || te.gpuType === xg);
                    if (te.isInterleavedBufferAttribute) {
                        const Ce = te.data,
                            I = Ce.stride,
                            w = te.offset;
                        if (Ce.isInstancedInterleavedBuffer) {
                            for (let E = 0; E < xe.locationSize; E++) C(xe.location + E, Ce.meshPerAttribute);
                            B.isInstancedMesh !== !0 && j._maxInstanceCount === void 0 && (j._maxInstanceCount = Ce.meshPerAttribute * Ce.count)
                        } else
                            for (let E = 0; E < xe.locationSize; E++) x(xe.location + E);
                        n.bindBuffer(n.ARRAY_BUFFER, H);
                        for (let E = 0; E < xe.locationSize; E++) R(xe.location + E, Re / xe.locationSize, ce, me, I * ae, (w + Re / xe.locationSize * E) * ae, le)
                    } else {
                        if (te.isInstancedBufferAttribute) {
                            for (let Ce = 0; Ce < xe.locationSize; Ce++) C(xe.location + Ce, te.meshPerAttribute);
                            B.isInstancedMesh !== !0 && j._maxInstanceCount === void 0 && (j._maxInstanceCount = te.meshPerAttribute * te.count)
                        } else
                            for (let Ce = 0; Ce < xe.locationSize; Ce++) x(xe.location + Ce);
                        n.bindBuffer(n.ARRAY_BUFFER, H);
                        for (let Ce = 0; Ce < xe.locationSize; Ce++) R(xe.location + Ce, Re / xe.locationSize, ce, me, Re * ae, Re / xe.locationSize * Ce * ae, le)
                    }
                } else if (pe !== void 0) {
                    const me = pe[de];
                    if (me !== void 0) switch (me.length) {
                    case 2:
                        n.vertexAttrib2fv(xe.location, me);
                        break;
                    case 3:
                        n.vertexAttrib3fv(xe.location, me);
                        break;
                    case 4:
                        n.vertexAttrib4fv(xe.location, me);
                        break;
                    default:
                        n.vertexAttrib1fv(xe.location, me)
                    }
                }
            }
        }
        S()
    }

    function T() {
        ee();
        for (const B in a) {
            const V = a[B];
            for (const q in V) {
                const j = V[q];
                for (const J in j) p(j[J].object), delete j[J];
                delete V[q]
            }
            delete a[B]
        }
    }

    function A(B) {
        if (a[B.id] === void 0) return;
        const V = a[B.id];
        for (const q in V) {
            const j = V[q];
            for (const J in j) p(j[J].object), delete j[J];
            delete V[q]
        }
        delete a[B.id]
    }

    function G(B) {
        for (const V in a) {
            const q = a[V];
            if (q[B.id] === void 0) continue;
            const j = q[B.id];
            for (const J in j) p(j[J].object), delete j[J];
            delete q[B.id]
        }
    }

    function ee() {
        he(), u = !0, c !== l && (c = l, d(c.object))
    }

    function he() {
        l.geometry = null, l.program = null, l.wireframe = !1
    }
    return {
        setup: h,
        reset: ee,
        resetDefaultState: he,
        dispose: T,
        releaseStatesOfGeometry: A,
        releaseStatesOfProgram: G,
        initAttributes: v,
        enableAttribute: x,
        disableUnusedAttributes: S
    }
}

function UT(n, e, t, i) {
    const r = i.isWebGL2;
    let s;

    function o(u) {
        s = u
    }

    function a(u, h) {
        n.drawArrays(s, u, h), t.update(h, s, 1)
    }

    function l(u, h, f) {
        if (f === 0) return;
        let d, p;
        if (r) d = n, p = "drawArraysInstanced";
        else if (d = e.get("ANGLE_instanced_arrays"), p = "drawArraysInstancedANGLE", d === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        d[p](s, u, h, f), t.update(h, s, f)
    }

    function c(u, h, f) {
        if (f === 0) return;
        const d = e.get("WEBGL_multi_draw");
        if (d === null)
            for (let p = 0; p < f; p++) this.render(u[p], h[p]);
        else {
            d.multiDrawArraysWEBGL(s, u, 0, h, 0, f);
            let p = 0;
            for (let _ = 0; _ < f; _++) p += h[_];
            t.update(p, s, 1)
        }
    }
    this.setMode = o, this.render = a, this.renderInstances = l, this.renderMultiDraw = c
}

function FT(n, e, t) {
    let i;

    function r() {
        if (i !== void 0) return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else i = 0;
        return i
    }

    function s(R) {
        if (R === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
            R = "mediump"
        }
        return R === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
    const c = o || e.has("WEBGL_draw_buffers"),
        u = t.logarithmicDepthBuffer === !0,
        h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
        f = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        d = n.getParameter(n.MAX_TEXTURE_SIZE),
        p = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
        _ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
        g = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
        m = n.getParameter(n.MAX_VARYING_VECTORS),
        y = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
        v = f > 0,
        x = o || e.has("OES_texture_float"),
        C = v && x,
        S = o ? n.getParameter(n.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: u,
        maxTextures: h,
        maxVertexTextures: f,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: _,
        maxVertexUniforms: g,
        maxVaryings: m,
        maxFragmentUniforms: y,
        vertexTextures: v,
        floatFragmentTextures: x,
        floatVertexTextures: C,
        maxSamples: S
    }
}

function BT(n) {
    const e = this;
    let t = null,
        i = 0,
        r = !1,
        s = !1;
    const o = new Ci,
        a = new Qe,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (h, f) {
        const d = h.length !== 0 || f || i !== 0 || r;
        return r = f, i = h.length, d
    }, this.beginShadows = function () {
        s = !0, u(null)
    }, this.endShadows = function () {
        s = !1
    }, this.setGlobalState = function (h, f) {
        t = u(h, f, 0)
    }, this.setState = function (h, f, d) {
        const p = h.clippingPlanes,
            _ = h.clipIntersection,
            g = h.clipShadows,
            m = n.get(h);
        if (!r || p === null || p.length === 0 || s && !g) s ? u(null) : c();
        else {
            const y = s ? 0 : i,
                v = y * 4;
            let x = m.clippingState || null;
            l.value = x, x = u(p, f, v, d);
            for (let C = 0; C !== v; ++C) x[C] = t[C];
            m.clippingState = x, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += y
        }
    };

    function c() {
        l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
    }

    function u(h, f, d, p) {
        const _ = h !== null ? h.length : 0;
        let g = null;
        if (_ !== 0) {
            if (g = l.value, p !== !0 || g === null) {
                const m = d + _ * 4,
                    y = f.matrixWorldInverse;
                a.getNormalMatrix(y), (g === null || g.length < m) && (g = new Float32Array(m));
                for (let v = 0, x = d; v !== _; ++v, x += 4) o.copy(h[v]).applyMatrix4(y, a), o.normal.toArray(g, x), g[x + 3] = o.constant
            }
            l.value = g, l.needsUpdate = !0
        }
        return e.numPlanes = _, e.numIntersection = 0, g
    }
}

function kT(n) {
    let e = new WeakMap;

    function t(o, a) {
        return a === Ya ? o.mapping = hr : a === Ka && (o.mapping = fr), o
    }

    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === Ya || a === Ka)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new JM(l.height / 2);
                        return c.fromEquirectangularTexture(n, o), e.set(o, c), o.addEventListener("dispose", r), t(c.texture, o.mapping)
                    } else return null
                }
        }
        return o
    }

    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose())
    }

    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class Qu extends Fg {
    constructor(e = -1, t = 1, i = 1, r = -1, s = .1, o = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        let s = i - e,
            o = i + e,
            a = r + t,
            l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX, o = s + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
    }
}
const Zr = 4,
    Bd = [.125, .215, .35, .446, .526, .582],
    er = 20,
    bc = new Qu,
    kd = new Fe;
let Sc = null,
    Tc = 0,
    wc = 0;
const Ji = (1 + Math.sqrt(5)) / 2,
    Vr = 1 / Ji,
    zd = [new L(1, 1, 1), new L(-1, 1, 1), new L(1, 1, -1), new L(-1, 1, -1), new L(0, Ji, Vr), new L(0, Ji, -Vr), new L(Vr, 0, Ji), new L(-Vr, 0, Ji), new L(Ji, Vr, 0), new L(-Ji, Vr, 0)];
class Gd {
    constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t = 0, i = .1, r = 100) {
        Sc = this._renderer.getRenderTarget(), Tc = this._renderer.getActiveCubeFace(), wc = this._renderer.getActiveMipmapLevel(), this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Wd(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Hd(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Sc, Tc, wc), e.scissorTest = !1, oa(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === hr || e.mapping === fr ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Sc = this._renderer.getRenderTarget(), Tc = this._renderer.getActiveCubeFace(), wc = this._renderer.getActiveMipmapLevel();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = {
                magFilter: cn,
                minFilter: cn,
                generateMipmaps: !1,
                type: ho,
                format: on,
                colorSpace: mi,
                depthBuffer: !1
            },
            r = Vd(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Vd(e, t, i);
            const {
                _lodMax: s
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = zT(s)), this._blurMaterial = GT(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new xt(this._lodPlanes[0], e);
        this._renderer.compile(t, bc)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new qt(90, 1, t, i),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            h = u.autoClear,
            f = u.toneMapping;
        u.getClearColor(kd), u.toneMapping = Ni, u.autoClear = !1;
        const d = new Ju({
                name: "PMREM.Background",
                side: un,
                depthWrite: !1,
                depthTest: !1
            }),
            p = new xt(new Ms, d);
        let _ = !1;
        const g = e.background;
        g ? g.isColor && (d.color.copy(g), e.background = null, _ = !0) : (d.color.copy(kd), _ = !0);
        for (let m = 0; m < 6; m++) {
            const y = m % 3;
            y === 0 ? (a.up.set(0, l[m], 0), a.lookAt(c[m], 0, 0)) : y === 1 ? (a.up.set(0, 0, l[m]), a.lookAt(0, c[m], 0)) : (a.up.set(0, l[m], 0), a.lookAt(0, 0, c[m]));
            const v = this._cubeSize;
            oa(r, y * v, m > 2 ? v : 0, v, v), u.setRenderTarget(r), _ && u.render(p, a), u.render(e, a)
        }
        p.geometry.dispose(), p.material.dispose(), u.toneMapping = f, u.autoClear = h, e.background = g
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer,
            r = e.mapping === hr || e.mapping === fr;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = Wd()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Hd());
        const s = r ? this._cubemapMaterial : this._equirectMaterial,
            o = new xt(this._lodPlanes[0], s),
            a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        oa(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, bc)
    }
    _applyPMREM(e) {
        const t = this._renderer,
            i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
                o = zd[(r - 1) % zd.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer,
            c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3,
            h = new xt(this._lodPlanes[r], c),
            f = c.uniforms,
            d = this._sizeLods[i] - 1,
            p = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * er - 1),
            _ = s / p,
            g = isFinite(s) ? 1 + Math.floor(u * _) : er;
        g > er && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${er}`);
        const m = [];
        let y = 0;
        for (let R = 0; R < er; ++R) {
            const F = R / _,
                T = Math.exp(-F * F / 2);
            m.push(T), R === 0 ? y += T : R < g && (y += 2 * T)
        }
        for (let R = 0; R < m.length; R++) m[R] = m[R] / y;
        f.envMap.value = e.texture, f.samples.value = g, f.weights.value = m, f.latitudinal.value = o === "latitudinal", a && (f.poleAxis.value = a);
        const {
            _lodMax: v
        } = this;
        f.dTheta.value = p, f.mipInt.value = v - i;
        const x = this._sizeLods[r],
            C = 3 * x * (r > v - Zr ? r - v + Zr : 0),
            S = 4 * (this._cubeSize - x);
        oa(t, C, S, 3 * x, 2 * x), l.setRenderTarget(t), l.render(h, bc)
    }
}

function zT(n) {
    const e = [],
        t = [],
        i = [];
    let r = n;
    const s = n - Zr + 1 + Bd.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - Zr ? l = Bd[o - n + Zr - 1] : o === 0 && (l = 0), i.push(l);
        const c = 1 / (a - 2),
            u = -c,
            h = 1 + c,
            f = [u, u, h, u, h, h, u, u, h, h, u, h],
            d = 6,
            p = 6,
            _ = 3,
            g = 2,
            m = 1,
            y = new Float32Array(_ * p * d),
            v = new Float32Array(g * p * d),
            x = new Float32Array(m * p * d);
        for (let S = 0; S < d; S++) {
            const R = S % 3 * 2 / 3 - 1,
                F = S > 2 ? 0 : -1,
                T = [R, F, 0, R + 2 / 3, F, 0, R + 2 / 3, F + 1, 0, R, F, 0, R + 2 / 3, F + 1, 0, R, F + 1, 0];
            y.set(T, _ * p * S), v.set(f, g * p * S);
            const A = [S, S, S, S, S, S];
            x.set(A, m * p * S)
        }
        const C = new ht;
        C.setAttribute("position", new ut(y, _)), C.setAttribute("uv", new ut(v, g)), C.setAttribute("faceIndex", new ut(x, m)), e.push(C), r > Zr && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}

function Vd(n, e, t) {
    const i = new pr(n, e, t);
    return i.texture.mapping = wo, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
}

function oa(n, e, t, i, r) {
    n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r)
}

function GT(n, e, t) {
    const i = new Float32Array(er),
        r = new L(0, 1, 0);
    return new Qn({
        name: "SphericalGaussianBlur",
        defines: {
            n: er,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: eh(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );

				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Oi,
        depthTest: !1,
        depthWrite: !1
    })
}

function Hd() {
    return new Qn({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: eh(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Oi,
        depthTest: !1,
        depthWrite: !1
    })
}

function Wd() {
    return new Qn({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: eh(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Oi,
        depthTest: !1,
        depthWrite: !1
    })
}

function eh() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function VT(n) {
    let e = new WeakMap,
        t = null;

    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping,
                c = l === Ya || l === Ka,
                u = l === hr || l === fr;
            if (c || u)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new Gd(n)), h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), e.set(a, h), h.texture
                } else {
                    if (e.has(a)) return e.get(a).texture; {
                        const h = a.image;
                        if (c && h && h.height > 0 || u && h && r(h)) {
                            t === null && (t = new Gd(n));
                            const f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, f), a.addEventListener("dispose", s), f.texture
                        } else return null
                    }
                }
        }
        return a
    }

    function r(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
        return l === c
    }

    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose())
    }

    function o() {
        e = new WeakMap, t !== null && (t.dispose(), t = null)
    }
    return {
        get: i,
        dispose: o
    }
}

function HT(n) {
    const e = {};

    function t(i) {
        if (e[i] !== void 0) return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r, r
    }
    return {
        has: function (i) {
            return t(i) !== null
        },
        init: function (i) {
            i.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture")
        },
        get: function (i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r
        }
    }
}

function WT(n, e, t, i) {
    const r = {},
        s = new WeakMap;

    function o(h) {
        const f = h.target;
        f.index !== null && e.remove(f.index);
        for (const p in f.attributes) e.remove(f.attributes[p]);
        for (const p in f.morphAttributes) {
            const _ = f.morphAttributes[p];
            for (let g = 0, m = _.length; g < m; g++) e.remove(_[g])
        }
        f.removeEventListener("dispose", o), delete r[f.id];
        const d = s.get(f);
        d && (e.remove(d), s.delete(f)), i.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--
    }

    function a(h, f) {
        return r[f.id] === !0 || (f.addEventListener("dispose", o), r[f.id] = !0, t.memory.geometries++), f
    }

    function l(h) {
        const f = h.attributes;
        for (const p in f) e.update(f[p], n.ARRAY_BUFFER);
        const d = h.morphAttributes;
        for (const p in d) {
            const _ = d[p];
            for (let g = 0, m = _.length; g < m; g++) e.update(_[g], n.ARRAY_BUFFER)
        }
    }

    function c(h) {
        const f = [],
            d = h.index,
            p = h.attributes.position;
        let _ = 0;
        if (d !== null) {
            const y = d.array;
            _ = d.version;
            for (let v = 0, x = y.length; v < x; v += 3) {
                const C = y[v + 0],
                    S = y[v + 1],
                    R = y[v + 2];
                f.push(C, S, S, R, R, C)
            }
        } else if (p !== void 0) {
            const y = p.array;
            _ = p.version;
            for (let v = 0, x = y.length / 3 - 1; v < x; v += 3) {
                const C = v + 0,
                    S = v + 1,
                    R = v + 2;
                f.push(C, S, S, R, R, C)
            }
        } else return;
        const g = new(Cg(f) ? Ng : Og)(f, 1);
        g.version = _;
        const m = s.get(h);
        m && e.remove(m), s.set(h, g)
    }

    function u(h) {
        const f = s.get(h);
        if (f) {
            const d = h.index;
            d !== null && f.version < d.version && c(h)
        } else c(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}

function $T(n, e, t, i) {
    const r = i.isWebGL2;
    let s;

    function o(d) {
        s = d
    }
    let a, l;

    function c(d) {
        a = d.type, l = d.bytesPerElement
    }

    function u(d, p) {
        n.drawElements(s, p, a, d * l), t.update(p, s, 1)
    }

    function h(d, p, _) {
        if (_ === 0) return;
        let g, m;
        if (r) g = n, m = "drawElementsInstanced";
        else if (g = e.get("ANGLE_instanced_arrays"), m = "drawElementsInstancedANGLE", g === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        g[m](s, p, a, d * l, _), t.update(p, s, _)
    }

    function f(d, p, _) {
        if (_ === 0) return;
        const g = e.get("WEBGL_multi_draw");
        if (g === null)
            for (let m = 0; m < _; m++) this.render(d[m] / l, p[m]);
        else {
            g.multiDrawElementsWEBGL(s, p, 0, a, d, 0, _);
            let m = 0;
            for (let y = 0; y < _; y++) m += p[y];
            t.update(m, s, 1)
        }
    }
    this.setMode = o, this.setIndex = c, this.render = u, this.renderInstances = h, this.renderMultiDraw = f
}

function XT(n) {
    const e = {
            geometries: 0,
            textures: 0
        },
        t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

    function i(s, o, a) {
        switch (t.calls++, o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }

    function r() {
        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}

function qT(n, e) {
    return n[0] - e[0]
}

function YT(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}

function KT(n, e, t) {
    const i = {},
        r = new Float32Array(8),
        s = new WeakMap,
        o = new pt,
        a = [];
    for (let c = 0; c < 8; c++) a[c] = [c, 0];

    function l(c, u, h) {
        const f = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const d = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
                p = d !== void 0 ? d.length : 0;
            let _ = s.get(u);
            if (_ === void 0 || _.count !== p) {
                let B = function () {
                    ee.dispose(), s.delete(u), u.removeEventListener("dispose", B)
                };
                _ !== void 0 && _.texture.dispose();
                const y = u.morphAttributes.position !== void 0,
                    v = u.morphAttributes.normal !== void 0,
                    x = u.morphAttributes.color !== void 0,
                    C = u.morphAttributes.position || [],
                    S = u.morphAttributes.normal || [],
                    R = u.morphAttributes.color || [];
                let F = 0;
                y === !0 && (F = 1), v === !0 && (F = 2), x === !0 && (F = 3);
                let T = u.attributes.position.count * F,
                    A = 1;
                T > e.maxTextureSize && (A = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
                const G = new Float32Array(T * A * 4 * p),
                    ee = new Lg(G, T, A, p);
                ee.type = qn, ee.needsUpdate = !0;
                const he = F * 4;
                for (let V = 0; V < p; V++) {
                    const q = C[V],
                        j = S[V],
                        J = R[V],
                        ie = T * A * 4 * V;
                    for (let pe = 0; pe < q.count; pe++) {
                        const de = pe * he;
                        y === !0 && (o.fromBufferAttribute(q, pe), G[ie + de + 0] = o.x, G[ie + de + 1] = o.y, G[ie + de + 2] = o.z, G[ie + de + 3] = 0), v === !0 && (o.fromBufferAttribute(j, pe), G[ie + de + 4] = o.x, G[ie + de + 5] = o.y, G[ie + de + 6] = o.z, G[ie + de + 7] = 0), x === !0 && (o.fromBufferAttribute(J, pe), G[ie + de + 8] = o.x, G[ie + de + 9] = o.y, G[ie + de + 10] = o.z, G[ie + de + 11] = J.itemSize === 4 ? o.w : 1)
                    }
                }
                _ = {
                    count: p,
                    texture: ee,
                    size: new ue(T, A)
                }, s.set(u, _), u.addEventListener("dispose", B)
            }
            let g = 0;
            for (let y = 0; y < f.length; y++) g += f[y];
            const m = u.morphTargetsRelative ? 1 : 1 - g;
            h.getUniforms().setValue(n, "morphTargetBaseInfluence", m), h.getUniforms().setValue(n, "morphTargetInfluences", f), h.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t), h.getUniforms().setValue(n, "morphTargetsTextureSize", _.size)
        } else {
            const d = f === void 0 ? 0 : f.length;
            let p = i[u.id];
            if (p === void 0 || p.length !== d) {
                p = [];
                for (let v = 0; v < d; v++) p[v] = [v, 0];
                i[u.id] = p
            }
            for (let v = 0; v < d; v++) {
                const x = p[v];
                x[0] = v, x[1] = f[v]
            }
            p.sort(YT);
            for (let v = 0; v < 8; v++) v < d && p[v][1] ? (a[v][0] = p[v][0], a[v][1] = p[v][1]) : (a[v][0] = Number.MAX_SAFE_INTEGER, a[v][1] = 0);
            a.sort(qT);
            const _ = u.morphAttributes.position,
                g = u.morphAttributes.normal;
            let m = 0;
            for (let v = 0; v < 8; v++) {
                const x = a[v],
                    C = x[0],
                    S = x[1];
                C !== Number.MAX_SAFE_INTEGER && S ? (_ && u.getAttribute("morphTarget" + v) !== _[C] && u.setAttribute("morphTarget" + v, _[C]), g && u.getAttribute("morphNormal" + v) !== g[C] && u.setAttribute("morphNormal" + v, g[C]), r[v] = S, m += S) : (_ && u.hasAttribute("morphTarget" + v) === !0 && u.deleteAttribute("morphTarget" + v), g && u.hasAttribute("morphNormal" + v) === !0 && u.deleteAttribute("morphNormal" + v), r[v] = 0)
            }
            const y = u.morphTargetsRelative ? 1 : 1 - m;
            h.getUniforms().setValue(n, "morphTargetBaseInfluence", y), h.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: l
    }
}

function jT(n, e, t, i) {
    let r = new WeakMap;

    function s(l) {
        const c = i.render.frame,
            u = l.geometry,
            h = e.get(l, u);
        if (r.get(h) !== c && (e.update(h), r.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), r.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), r.set(l, c))), l.isSkinnedMesh) {
            const f = l.skeleton;
            r.get(f) !== c && (f.update(), r.set(f, c))
        }
        return h
    }

    function o() {
        r = new WeakMap
    }

    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class kg extends zt {
    constructor(e, t, i, r, s, o, a, l, c, u) {
        if (u = u !== void 0 ? u : cr, u !== cr && u !== ms) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && u === cr && (i = Pi), i === void 0 && u === ms && (i = lr), super(null, r, s, o, a, l, u, i, c), this.isDepthTexture = !0, this.image = {
            width: e,
            height: t
        }, this.magFilter = a !== void 0 ? a : It, this.minFilter = l !== void 0 ? l : It, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
    }
    copy(e) {
        return super.copy(e), this.compareFunction = e.compareFunction, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
    }
}
const zg = new zt,
    Gg = new kg(1, 1);
Gg.compareFunction = Rg;
const Vg = new Lg,
    Hg = new OM,
    Wg = new Zu,
    $d = [],
    Xd = [],
    qd = new Float32Array(16),
    Yd = new Float32Array(9),
    Kd = new Float32Array(4);

function bs(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0) return n;
    const r = e * t;
    let s = $d[r];
    if (s === void 0 && (s = new Float32Array(r), $d[r] = s), e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o) a += t, n[o].toArray(s, a)
    }
    return s
}

function Ot(n, e) {
    if (n.length !== e.length) return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t]) return !1;
    return !0
}

function Nt(n, e) {
    for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}

function El(n, e) {
    let t = Xd[e];
    t === void 0 && (t = new Int32Array(e), Xd[e] = t);
    for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
    return t
}

function JT(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e)
}

function ZT(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Ot(t, e)) return;
        n.uniform2fv(this.addr, e), Nt(t, e)
    }
}

function QT(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
        if (Ot(t, e)) return;
        n.uniform3fv(this.addr, e), Nt(t, e)
    }
}

function ew(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Ot(t, e)) return;
        n.uniform4fv(this.addr, e), Nt(t, e)
    }
}

function tw(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Ot(t, e)) return;
        n.uniformMatrix2fv(this.addr, !1, e), Nt(t, e)
    } else {
        if (Ot(t, i)) return;
        Kd.set(i), n.uniformMatrix2fv(this.addr, !1, Kd), Nt(t, i)
    }
}

function nw(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Ot(t, e)) return;
        n.uniformMatrix3fv(this.addr, !1, e), Nt(t, e)
    } else {
        if (Ot(t, i)) return;
        Yd.set(i), n.uniformMatrix3fv(this.addr, !1, Yd), Nt(t, i)
    }
}

function iw(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Ot(t, e)) return;
        n.uniformMatrix4fv(this.addr, !1, e), Nt(t, e)
    } else {
        if (Ot(t, i)) return;
        qd.set(i), n.uniformMatrix4fv(this.addr, !1, qd), Nt(t, i)
    }
}

function rw(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e)
}

function sw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Ot(t, e)) return;
        n.uniform2iv(this.addr, e), Nt(t, e)
    }
}

function ow(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (Ot(t, e)) return;
        n.uniform3iv(this.addr, e), Nt(t, e)
    }
}

function aw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Ot(t, e)) return;
        n.uniform4iv(this.addr, e), Nt(t, e)
    }
}

function lw(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e)
}

function cw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Ot(t, e)) return;
        n.uniform2uiv(this.addr, e), Nt(t, e)
    }
}

function uw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (Ot(t, e)) return;
        n.uniform3uiv(this.addr, e), Nt(t, e)
    }
}

function hw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Ot(t, e)) return;
        n.uniform4uiv(this.addr, e), Nt(t, e)
    }
}

function fw(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r);
    const s = this.type === n.SAMPLER_2D_SHADOW ? Gg : zg;
    t.setTexture2D(e || s, r)
}

function dw(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || Hg, r)
}

function pw(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || Wg, r)
}

function mw(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || Vg, r)
}

function gw(n) {
    switch (n) {
    case 5126:
        return JT;
    case 35664:
        return ZT;
    case 35665:
        return QT;
    case 35666:
        return ew;
    case 35674:
        return tw;
    case 35675:
        return nw;
    case 35676:
        return iw;
    case 5124:
    case 35670:
        return rw;
    case 35667:
    case 35671:
        return sw;
    case 35668:
    case 35672:
        return ow;
    case 35669:
    case 35673:
        return aw;
    case 5125:
        return lw;
    case 36294:
        return cw;
    case 36295:
        return uw;
    case 36296:
        return hw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return fw;
    case 35679:
    case 36299:
    case 36307:
        return dw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return pw;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return mw
    }
}

function _w(n, e) {
    n.uniform1fv(this.addr, e)
}

function vw(n, e) {
    const t = bs(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}

function yw(n, e) {
    const t = bs(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}

function xw(n, e) {
    const t = bs(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}

function Mw(n, e) {
    const t = bs(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}

function bw(n, e) {
    const t = bs(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}

function Sw(n, e) {
    const t = bs(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}

function Tw(n, e) {
    n.uniform1iv(this.addr, e)
}

function ww(n, e) {
    n.uniform2iv(this.addr, e)
}

function Ew(n, e) {
    n.uniform3iv(this.addr, e)
}

function Aw(n, e) {
    n.uniform4iv(this.addr, e)
}

function Rw(n, e) {
    n.uniform1uiv(this.addr, e)
}

function Cw(n, e) {
    n.uniform2uiv(this.addr, e)
}

function Pw(n, e) {
    n.uniform3uiv(this.addr, e)
}

function Lw(n, e) {
    n.uniform4uiv(this.addr, e)
}

function Iw(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = El(t, r);
    Ot(i, s) || (n.uniform1iv(this.addr, s), Nt(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || zg, s[o])
}

function Dw(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = El(t, r);
    Ot(i, s) || (n.uniform1iv(this.addr, s), Nt(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || Hg, s[o])
}

function Ow(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = El(t, r);
    Ot(i, s) || (n.uniform1iv(this.addr, s), Nt(i, s));
    for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || Wg, s[o])
}

function Nw(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = El(t, r);
    Ot(i, s) || (n.uniform1iv(this.addr, s), Nt(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || Vg, s[o])
}

function Uw(n) {
    switch (n) {
    case 5126:
        return _w;
    case 35664:
        return vw;
    case 35665:
        return yw;
    case 35666:
        return xw;
    case 35674:
        return Mw;
    case 35675:
        return bw;
    case 35676:
        return Sw;
    case 5124:
    case 35670:
        return Tw;
    case 35667:
    case 35671:
        return ww;
    case 35668:
    case 35672:
        return Ew;
    case 35669:
    case 35673:
        return Aw;
    case 5125:
        return Rw;
    case 36294:
        return Cw;
    case 36295:
        return Pw;
    case 36296:
        return Lw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return Iw;
    case 35679:
    case 36299:
    case 36307:
        return Dw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Ow;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return Nw
    }
}
class Fw {
    constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = gw(t.type)
    }
}
class Bw {
    constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = Uw(t.type)
    }
}
class kw {
    constructor(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const Ec = /(\w+)(\])?(\[|\.)?/g;

function jd(n, e) {
    n.seq.push(e), n.map[e.id] = e
}

function zw(n, e, t) {
    const i = n.name,
        r = i.length;
    for (Ec.lastIndex = 0;;) {
        const s = Ec.exec(i),
            o = Ec.lastIndex;
        let a = s[1];
        const l = s[2] === "]",
            c = s[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === r) {
            jd(t, c === void 0 ? new Fw(a, n, e) : new Bw(a, n, e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new kw(a), jd(t, h)), t = h
        }
    }
}
class Na {
    constructor(e, t) {
        this.seq = [], this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r),
                o = e.getUniformLocation(t, s.name);
            zw(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s],
                l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}

function Jd(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t), n.compileShader(i), i
}
const Gw = 37297;
let Vw = 0;

function Hw(n, e) {
    const t = n.split(`
`),
        i = [],
        r = Math.max(e - 6, 0),
        s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a===e?">":" "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}

function Ww(n) {
    const e = dt.getPrimaries(dt.workingColorSpace),
        t = dt.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === Qa && t === Za ? i = "LinearDisplayP3ToLinearSRGB" : e === Za && t === Qa && (i = "LinearSRGBToLinearDisplayP3"), n) {
    case mi:
    case Sl:
        return [i, "LinearTransferOETF"];
    case Pt:
    case Ku:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [i, "LinearTransferOETF"]
    }
}

function Zd(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS),
        r = n.getShaderInfoLog(e).trim();
    if (i && r === "") return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + Hw(n.getShaderSource(e), o)
    } else return r
}

function $w(n, e) {
    const t = Ww(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}

function Xw(n, e) {
    let t;
    switch (e) {
    case Hx:
        t = "Linear";
        break;
    case Wx:
        t = "Reinhard";
        break;
    case $x:
        t = "OptimizedCineon";
        break;
    case yg:
        t = "ACESFilmic";
        break;
    case qx:
        t = "AgX";
        break;
    case Xx:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}

function qw(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qr).join(`
`)
}

function Yw(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""].filter(Qr).join(`
`)
}

function Kw(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}

function jw(n, e) {
    const t = {},
        i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r),
            o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2), s.type === n.FLOAT_MAT3 && (a = 3), s.type === n.FLOAT_MAT4 && (a = 4), t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}

function Qr(n) {
    return n !== ""
}

function Qd(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function ep(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Jw = /^[ \t]*#include +<([\w\d./]+)>/gm;

function du(n) {
    return n.replace(Jw, Qw)
}
const Zw = new Map([
    ["encodings_fragment", "colorspace_fragment"],
    ["encodings_pars_fragment", "colorspace_pars_fragment"],
    ["output_fragment", "opaque_fragment"]
]);

function Qw(n, e) {
    let t = je[e];
    if (t === void 0) {
        const i = Zw.get(e);
        if (i !== void 0) t = je[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else throw new Error("Can not resolve #include <" + e + ">")
    }
    return du(t)
}
const eE = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function tp(n) {
    return n.replace(eE, tE)
}

function tE(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}

function np(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function nE(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === vg ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === _x ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === hi && (e = "SHADOWMAP_TYPE_VSM"), e
}

function iE(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap) switch (n.envMapMode) {
    case hr:
    case fr:
        e = "ENVMAP_TYPE_CUBE";
        break;
    case wo:
        e = "ENVMAP_TYPE_CUBE_UV";
        break
    }
    return e
}

function rE(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap) switch (n.envMapMode) {
    case fr:
        e = "ENVMAP_MODE_REFRACTION";
        break
    }
    return e
}

function sE(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap) switch (n.combine) {
    case bl:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
    case Gx:
        e = "ENVMAP_BLENDING_MIX";
        break;
    case Vx:
        e = "ENVMAP_BLENDING_ADD";
        break
    }
    return e
}

function oE(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2,
        i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}

function aE(n, e, t, i) {
    const r = n.getContext(),
        s = t.defines;
    let o = t.vertexShader,
        a = t.fragmentShader;
    const l = nE(t),
        c = iE(t),
        u = rE(t),
        h = sE(t),
        f = oE(t),
        d = t.isWebGL2 ? "" : qw(t),
        p = Yw(t),
        _ = Kw(s),
        g = r.createProgram();
    let m, y, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Qr).join(`
`), m.length > 0 && (m += `
`), y = [d, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Qr).join(`
`), y.length > 0 && (y += `
`)) : (m = [np(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Qr).join(`
`), y = [d, np(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ni ? "#define TONE_MAPPING" : "", t.toneMapping !== Ni ? je.tonemapping_pars_fragment : "", t.toneMapping !== Ni ? Xw("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", je.colorspace_pars_fragment, $w("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Qr).join(`
`)), o = du(o), o = Qd(o, t), o = ep(o, t), a = du(a), a = Qd(a, t), a = ep(a, t), o = tp(o), a = tp(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, m = [p, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m, y = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === xd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === xd ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + y);
    const x = v + m + o,
        C = v + y + a,
        S = Jd(r, r.VERTEX_SHADER, x),
        R = Jd(r, r.FRAGMENT_SHADER, C);
    r.attachShader(g, S), r.attachShader(g, R), t.index0AttributeName !== void 0 ? r.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g);

    function F(ee) {
        if (n.debug.checkShaderErrors) {
            const he = r.getProgramInfoLog(g).trim(),
                B = r.getShaderInfoLog(S).trim(),
                V = r.getShaderInfoLog(R).trim();
            let q = !0,
                j = !0;
            if (r.getProgramParameter(g, r.LINK_STATUS) === !1)
                if (q = !1, typeof n.debug.onShaderError == "function") n.debug.onShaderError(r, g, S, R);
                else {
                    const J = Zd(r, S, "vertex"),
                        ie = Zd(r, R, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + `

Program Info Log: ` + he + `
` + J + `
` + ie)
                }
            else he !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", he) : (B === "" || V === "") && (j = !1);
            j && (ee.diagnostics = {
                runnable: q,
                programLog: he,
                vertexShader: {
                    log: B,
                    prefix: m
                },
                fragmentShader: {
                    log: V,
                    prefix: y
                }
            })
        }
        r.deleteShader(S), r.deleteShader(R), T = new Na(r, g), A = jw(r, g)
    }
    let T;
    this.getUniforms = function () {
        return T === void 0 && F(this), T
    };
    let A;
    this.getAttributes = function () {
        return A === void 0 && F(this), A
    };
    let G = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function () {
        return G === !1 && (G = r.getProgramParameter(g, Gw)), G
    }, this.destroy = function () {
        i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0
    }, this.type = t.shaderType, this.name = t.shaderName, this.id = Vw++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = R, this
}
let lE = 0;
class cE {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader,
            i = e.fragmentShader,
            r = this._getShaderStage(t),
            s = this._getShaderStage(i),
            o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e), this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set, t.set(e, i)), i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new uE(e), t.set(e, i)), i
    }
}
class uE {
    constructor(e) {
        this.id = lE++, this.code = e, this.usedTimes = 0
    }
}

function hE(n, e, t, i, r, s, o) {
    const a = new Ig,
        l = new cE,
        c = [],
        u = r.isWebGL2,
        h = r.logarithmicDepthBuffer,
        f = r.vertexTextures;
    let d = r.precision;
    const p = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function _(T) {
        return T === 0 ? "uv" : `uv${T}`
    }

    function g(T, A, G, ee, he) {
        const B = ee.fog,
            V = he.geometry,
            q = T.isMeshStandardMaterial ? ee.environment : null,
            j = (T.isMeshStandardMaterial ? t : e).get(T.envMap || q),
            J = j && j.mapping === wo ? j.image.height : null,
            ie = p[T.type];
        T.precision !== null && (d = r.getMaxPrecision(T.precision), d !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", d, "instead."));
        const pe = V.morphAttributes.position || V.morphAttributes.normal || V.morphAttributes.color,
            de = pe !== void 0 ? pe.length : 0;
        let xe = 0;
        V.morphAttributes.position !== void 0 && (xe = 1), V.morphAttributes.normal !== void 0 && (xe = 2), V.morphAttributes.color !== void 0 && (xe = 3);
        let te, me, Re, Pe;
        if (ie) {
            const en = Wn[ie];
            te = en.vertexShader, me = en.fragmentShader
        } else te = T.vertexShader, me = T.fragmentShader, l.update(T), Re = l.getVertexShaderID(T), Pe = l.getFragmentShaderID(T);
        const H = n.getRenderTarget(),
            ce = he.isInstancedMesh === !0,
            ae = he.isBatchedMesh === !0,
            le = !!T.map,
            Ce = !!T.matcap,
            I = !!j,
            w = !!T.aoMap,
            E = !!T.lightMap,
            N = !!T.bumpMap,
            U = !!T.normalMap,
            W = !!T.displacementMap,
            Y = !!T.emissiveMap,
            b = !!T.metalnessMap,
            M = !!T.roughnessMap,
            D = T.anisotropy > 0,
            z = T.clearcoat > 0,
            $ = T.iridescence > 0,
            K = T.sheen > 0,
            fe = T.transmission > 0,
            se = D && !!T.anisotropyMap,
            ge = z && !!T.clearcoatMap,
            Ee = z && !!T.clearcoatNormalMap,
            De = z && !!T.clearcoatRoughnessMap,
            oe = $ && !!T.iridescenceMap,
            Be = $ && !!T.iridescenceThicknessMap,
            O = K && !!T.sheenColorMap,
            _e = K && !!T.sheenRoughnessMap,
            Me = !!T.specularMap,
            ye = !!T.specularColorMap,
            Le = !!T.specularIntensityMap,
            ze = fe && !!T.transmissionMap,
            et = fe && !!T.thicknessMap,
            Je = !!T.gradientMap,
            we = !!T.alphaMap,
            k = T.alphaTest > 0,
            Se = !!T.alphaHash,
            Te = !!T.extensions,
            ke = !!V.attributes.uv1,
            Ne = !!V.attributes.uv2,
            st = !!V.attributes.uv3;
        let at = Ni;
        return T.toneMapped && (H === null || H.isXRRenderTarget === !0) && (at = n.toneMapping), {
            isWebGL2: u,
            shaderID: ie,
            shaderType: T.type,
            shaderName: T.name,
            vertexShader: te,
            fragmentShader: me,
            defines: T.defines,
            customVertexShaderID: Re,
            customFragmentShaderID: Pe,
            isRawShaderMaterial: T.isRawShaderMaterial === !0,
            glslVersion: T.glslVersion,
            precision: d,
            batching: ae,
            instancing: ce,
            instancingColor: ce && he.instanceColor !== null,
            supportsVertexTextures: f,
            outputColorSpace: H === null ? n.outputColorSpace : H.isXRRenderTarget === !0 ? H.texture.colorSpace : mi,
            map: le,
            matcap: Ce,
            envMap: I,
            envMapMode: I && j.mapping,
            envMapCubeUVHeight: J,
            aoMap: w,
            lightMap: E,
            bumpMap: N,
            normalMap: U,
            displacementMap: f && W,
            emissiveMap: Y,
            normalMapObjectSpace: U && T.normalMapType === oM,
            normalMapTangentSpace: U && T.normalMapType === xr,
            metalnessMap: b,
            roughnessMap: M,
            anisotropy: D,
            anisotropyMap: se,
            clearcoat: z,
            clearcoatMap: ge,
            clearcoatNormalMap: Ee,
            clearcoatRoughnessMap: De,
            iridescence: $,
            iridescenceMap: oe,
            iridescenceThicknessMap: Be,
            sheen: K,
            sheenColorMap: O,
            sheenRoughnessMap: _e,
            specularMap: Me,
            specularColorMap: ye,
            specularIntensityMap: Le,
            transmission: fe,
            transmissionMap: ze,
            thicknessMap: et,
            gradientMap: Je,
            opaque: T.transparent === !1 && T.blending === as,
            alphaMap: we,
            alphaTest: k,
            alphaHash: Se,
            combine: T.combine,
            mapUv: le && _(T.map.channel),
            aoMapUv: w && _(T.aoMap.channel),
            lightMapUv: E && _(T.lightMap.channel),
            bumpMapUv: N && _(T.bumpMap.channel),
            normalMapUv: U && _(T.normalMap.channel),
            displacementMapUv: W && _(T.displacementMap.channel),
            emissiveMapUv: Y && _(T.emissiveMap.channel),
            metalnessMapUv: b && _(T.metalnessMap.channel),
            roughnessMapUv: M && _(T.roughnessMap.channel),
            anisotropyMapUv: se && _(T.anisotropyMap.channel),
            clearcoatMapUv: ge && _(T.clearcoatMap.channel),
            clearcoatNormalMapUv: Ee && _(T.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: De && _(T.clearcoatRoughnessMap.channel),
            iridescenceMapUv: oe && _(T.iridescenceMap.channel),
            iridescenceThicknessMapUv: Be && _(T.iridescenceThicknessMap.channel),
            sheenColorMapUv: O && _(T.sheenColorMap.channel),
            sheenRoughnessMapUv: _e && _(T.sheenRoughnessMap.channel),
            specularMapUv: Me && _(T.specularMap.channel),
            specularColorMapUv: ye && _(T.specularColorMap.channel),
            specularIntensityMapUv: Le && _(T.specularIntensityMap.channel),
            transmissionMapUv: ze && _(T.transmissionMap.channel),
            thicknessMapUv: et && _(T.thicknessMap.channel),
            alphaMapUv: we && _(T.alphaMap.channel),
            vertexTangents: !!V.attributes.tangent && (U || D),
            vertexColors: T.vertexColors,
            vertexAlphas: T.vertexColors === !0 && !!V.attributes.color && V.attributes.color.itemSize === 4,
            vertexUv1s: ke,
            vertexUv2s: Ne,
            vertexUv3s: st,
            pointsUvs: he.isPoints === !0 && !!V.attributes.uv && (le || we),
            fog: !!B,
            useFog: T.fog === !0,
            fogExp2: B && B.isFogExp2,
            flatShading: T.flatShading === !0,
            sizeAttenuation: T.sizeAttenuation === !0,
            logarithmicDepthBuffer: h,
            skinning: he.isSkinnedMesh === !0,
            morphTargets: V.morphAttributes.position !== void 0,
            morphNormals: V.morphAttributes.normal !== void 0,
            morphColors: V.morphAttributes.color !== void 0,
            morphTargetsCount: de,
            morphTextureStride: xe,
            numDirLights: A.directional.length,
            numPointLights: A.point.length,
            numSpotLights: A.spot.length,
            numSpotLightMaps: A.spotLightMap.length,
            numRectAreaLights: A.rectArea.length,
            numHemiLights: A.hemi.length,
            numDirLightShadows: A.directionalShadowMap.length,
            numPointLightShadows: A.pointShadowMap.length,
            numSpotLightShadows: A.spotShadowMap.length,
            numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
            numLightProbes: A.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: T.dithering,
            shadowMapEnabled: n.shadowMap.enabled && G.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: at,
            useLegacyLights: n._useLegacyLights,
            decodeVideoTexture: le && T.map.isVideoTexture === !0 && dt.getTransfer(T.map.colorSpace) === vt,
            premultipliedAlpha: T.premultipliedAlpha,
            doubleSided: T.side === En,
            flipSided: T.side === un,
            useDepthPacking: T.depthPacking >= 0,
            depthPacking: T.depthPacking || 0,
            index0AttributeName: T.index0AttributeName,
            extensionDerivatives: Te && T.extensions.derivatives === !0,
            extensionFragDepth: Te && T.extensions.fragDepth === !0,
            extensionDrawBuffers: Te && T.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: Te && T.extensions.shaderTextureLOD === !0,
            extensionClipCullDistance: Te && T.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
            rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: T.customProgramCacheKey()
        }
    }

    function m(T) {
        const A = [];
        if (T.shaderID ? A.push(T.shaderID) : (A.push(T.customVertexShaderID), A.push(T.customFragmentShaderID)), T.defines !== void 0)
            for (const G in T.defines) A.push(G), A.push(T.defines[G]);
        return T.isRawShaderMaterial === !1 && (y(A, T), v(A, T), A.push(n.outputColorSpace)), A.push(T.customProgramCacheKey), A.join()
    }

    function y(T, A) {
        T.push(A.precision), T.push(A.outputColorSpace), T.push(A.envMapMode), T.push(A.envMapCubeUVHeight), T.push(A.mapUv), T.push(A.alphaMapUv), T.push(A.lightMapUv), T.push(A.aoMapUv), T.push(A.bumpMapUv), T.push(A.normalMapUv), T.push(A.displacementMapUv), T.push(A.emissiveMapUv), T.push(A.metalnessMapUv), T.push(A.roughnessMapUv), T.push(A.anisotropyMapUv), T.push(A.clearcoatMapUv), T.push(A.clearcoatNormalMapUv), T.push(A.clearcoatRoughnessMapUv), T.push(A.iridescenceMapUv), T.push(A.iridescenceThicknessMapUv), T.push(A.sheenColorMapUv), T.push(A.sheenRoughnessMapUv), T.push(A.specularMapUv), T.push(A.specularColorMapUv), T.push(A.specularIntensityMapUv), T.push(A.transmissionMapUv), T.push(A.thicknessMapUv), T.push(A.combine), T.push(A.fogExp2), T.push(A.sizeAttenuation), T.push(A.morphTargetsCount), T.push(A.morphAttributeCount), T.push(A.numDirLights), T.push(A.numPointLights), T.push(A.numSpotLights), T.push(A.numSpotLightMaps), T.push(A.numHemiLights), T.push(A.numRectAreaLights), T.push(A.numDirLightShadows), T.push(A.numPointLightShadows), T.push(A.numSpotLightShadows), T.push(A.numSpotLightShadowsWithMaps), T.push(A.numLightProbes), T.push(A.shadowMapType), T.push(A.toneMapping), T.push(A.numClippingPlanes), T.push(A.numClipIntersection), T.push(A.depthPacking)
    }

    function v(T, A) {
        a.disableAll(), A.isWebGL2 && a.enable(0), A.supportsVertexTextures && a.enable(1), A.instancing && a.enable(2), A.instancingColor && a.enable(3), A.matcap && a.enable(4), A.envMap && a.enable(5), A.normalMapObjectSpace && a.enable(6), A.normalMapTangentSpace && a.enable(7), A.clearcoat && a.enable(8), A.iridescence && a.enable(9), A.alphaTest && a.enable(10), A.vertexColors && a.enable(11), A.vertexAlphas && a.enable(12), A.vertexUv1s && a.enable(13), A.vertexUv2s && a.enable(14), A.vertexUv3s && a.enable(15), A.vertexTangents && a.enable(16), A.anisotropy && a.enable(17), A.alphaHash && a.enable(18), A.batching && a.enable(19), T.push(a.mask), a.disableAll(), A.fog && a.enable(0), A.useFog && a.enable(1), A.flatShading && a.enable(2), A.logarithmicDepthBuffer && a.enable(3), A.skinning && a.enable(4), A.morphTargets && a.enable(5), A.morphNormals && a.enable(6), A.morphColors && a.enable(7), A.premultipliedAlpha && a.enable(8), A.shadowMapEnabled && a.enable(9), A.useLegacyLights && a.enable(10), A.doubleSided && a.enable(11), A.flipSided && a.enable(12), A.useDepthPacking && a.enable(13), A.dithering && a.enable(14), A.transmission && a.enable(15), A.sheen && a.enable(16), A.opaque && a.enable(17), A.pointsUvs && a.enable(18), A.decodeVideoTexture && a.enable(19), T.push(a.mask)
    }

    function x(T) {
        const A = p[T.type];
        let G;
        if (A) {
            const ee = Wn[A];
            G = qM.clone(ee.uniforms)
        } else G = T.uniforms;
        return G
    }

    function C(T, A) {
        let G;
        for (let ee = 0, he = c.length; ee < he; ee++) {
            const B = c[ee];
            if (B.cacheKey === A) {
                G = B, ++G.usedTimes;
                break
            }
        }
        return G === void 0 && (G = new aE(n, A, T, s), c.push(G)), G
    }

    function S(T) {
        if (--T.usedTimes === 0) {
            const A = c.indexOf(T);
            c[A] = c[c.length - 1], c.pop(), T.destroy()
        }
    }

    function R(T) {
        l.remove(T)
    }

    function F() {
        l.dispose()
    }
    return {
        getParameters: g,
        getProgramCacheKey: m,
        getUniforms: x,
        acquireProgram: C,
        releaseProgram: S,
        releaseShaderCache: R,
        programs: c,
        dispose: F
    }
}

function fE() {
    let n = new WeakMap;

    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {}, n.set(s, o)), o
    }

    function t(s) {
        n.delete(s)
    }

    function i(s, o, a) {
        n.get(s)[o] = a
    }

    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}

function dE(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}

function ip(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}

function rp() {
    const n = [];
    let e = 0;
    const t = [],
        i = [],
        r = [];

    function s() {
        e = 0, t.length = 0, i.length = 0, r.length = 0
    }

    function o(h, f, d, p, _, g) {
        let m = n[e];
        return m === void 0 ? (m = {
            id: h.id,
            object: h,
            geometry: f,
            material: d,
            groupOrder: p,
            renderOrder: h.renderOrder,
            z: _,
            group: g
        }, n[e] = m) : (m.id = h.id, m.object = h, m.geometry = f, m.material = d, m.groupOrder = p, m.renderOrder = h.renderOrder, m.z = _, m.group = g), e++, m
    }

    function a(h, f, d, p, _, g) {
        const m = o(h, f, d, p, _, g);
        d.transmission > 0 ? i.push(m) : d.transparent === !0 ? r.push(m) : t.push(m)
    }

    function l(h, f, d, p, _, g) {
        const m = o(h, f, d, p, _, g);
        d.transmission > 0 ? i.unshift(m) : d.transparent === !0 ? r.unshift(m) : t.unshift(m)
    }

    function c(h, f) {
        t.length > 1 && t.sort(h || dE), i.length > 1 && i.sort(f || ip), r.length > 1 && r.sort(f || ip)
    }

    function u() {
        for (let h = e, f = n.length; h < f; h++) {
            const d = n[h];
            if (d.id === null) break;
            d.id = null, d.object = null, d.geometry = null, d.material = null, d.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}

function pE() {
    let n = new WeakMap;

    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new rp, n.set(i, [o])) : r >= s.length ? (o = new rp, s.push(o)) : o = s[r], o
    }

    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}

function mE() {
    const n = {};
    return {
        get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new L,
                    color: new Fe
                };
                break;
            case "SpotLight":
                t = {
                    position: new L,
                    direction: new L,
                    color: new Fe,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new L,
                    color: new Fe,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new L,
                    skyColor: new Fe,
                    groundColor: new Fe
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Fe,
                    position: new L,
                    halfWidth: new L,
                    halfHeight: new L
                };
                break
            }
            return n[e.id] = t, t
        }
    }
}

function gE() {
    const n = {};
    return {
        get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ue
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ue
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ue,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t, t
        }
    }
}
let _E = 0;

function vE(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}

function yE(n, e) {
    const t = new mE,
        i = gE(),
        r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let u = 0; u < 9; u++) r.probe.push(new L);
    const s = new L,
        o = new qe,
        a = new qe;

    function l(u, h) {
        let f = 0,
            d = 0,
            p = 0;
        for (let ee = 0; ee < 9; ee++) r.probe[ee].set(0, 0, 0);
        let _ = 0,
            g = 0,
            m = 0,
            y = 0,
            v = 0,
            x = 0,
            C = 0,
            S = 0,
            R = 0,
            F = 0,
            T = 0;
        u.sort(vE);
        const A = h === !0 ? Math.PI : 1;
        for (let ee = 0, he = u.length; ee < he; ee++) {
            const B = u[ee],
                V = B.color,
                q = B.intensity,
                j = B.distance,
                J = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
            if (B.isAmbientLight) f += V.r * q * A, d += V.g * q * A, p += V.b * q * A;
            else if (B.isLightProbe) {
                for (let ie = 0; ie < 9; ie++) r.probe[ie].addScaledVector(B.sh.coefficients[ie], q);
                T++
            } else if (B.isDirectionalLight) {
                const ie = t.get(B);
                if (ie.color.copy(B.color).multiplyScalar(B.intensity * A), B.castShadow) {
                    const pe = B.shadow,
                        de = i.get(B);
                    de.shadowBias = pe.bias, de.shadowNormalBias = pe.normalBias, de.shadowRadius = pe.radius, de.shadowMapSize = pe.mapSize, r.directionalShadow[_] = de, r.directionalShadowMap[_] = J, r.directionalShadowMatrix[_] = B.shadow.matrix, x++
                }
                r.directional[_] = ie, _++
            } else if (B.isSpotLight) {
                const ie = t.get(B);
                ie.position.setFromMatrixPosition(B.matrixWorld), ie.color.copy(V).multiplyScalar(q * A), ie.distance = j, ie.coneCos = Math.cos(B.angle), ie.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)), ie.decay = B.decay, r.spot[m] = ie;
                const pe = B.shadow;
                if (B.map && (r.spotLightMap[R] = B.map, R++, pe.updateMatrices(B), B.castShadow && F++), r.spotLightMatrix[m] = pe.matrix, B.castShadow) {
                    const de = i.get(B);
                    de.shadowBias = pe.bias, de.shadowNormalBias = pe.normalBias, de.shadowRadius = pe.radius, de.shadowMapSize = pe.mapSize, r.spotShadow[m] = de, r.spotShadowMap[m] = J, S++
                }
                m++
            } else if (B.isRectAreaLight) {
                const ie = t.get(B);
                ie.color.copy(V).multiplyScalar(q), ie.halfWidth.set(B.width * .5, 0, 0), ie.halfHeight.set(0, B.height * .5, 0), r.rectArea[y] = ie, y++
            } else if (B.isPointLight) {
                const ie = t.get(B);
                if (ie.color.copy(B.color).multiplyScalar(B.intensity * A), ie.distance = B.distance, ie.decay = B.decay, B.castShadow) {
                    const pe = B.shadow,
                        de = i.get(B);
                    de.shadowBias = pe.bias, de.shadowNormalBias = pe.normalBias, de.shadowRadius = pe.radius, de.shadowMapSize = pe.mapSize, de.shadowCameraNear = pe.camera.near, de.shadowCameraFar = pe.camera.far, r.pointShadow[g] = de, r.pointShadowMap[g] = J, r.pointShadowMatrix[g] = B.shadow.matrix, C++
                }
                r.point[g] = ie, g++
            } else if (B.isHemisphereLight) {
                const ie = t.get(B);
                ie.skyColor.copy(B.color).multiplyScalar(q * A), ie.groundColor.copy(B.groundColor).multiplyScalar(q * A), r.hemi[v] = ie, v++
            }
        }
        y > 0 && (e.isWebGL2 ? n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ae.LTC_FLOAT_1, r.rectAreaLTC2 = Ae.LTC_FLOAT_2) : (r.rectAreaLTC1 = Ae.LTC_HALF_1, r.rectAreaLTC2 = Ae.LTC_HALF_2) : n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ae.LTC_FLOAT_1, r.rectAreaLTC2 = Ae.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Ae.LTC_HALF_1, r.rectAreaLTC2 = Ae.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = f, r.ambient[1] = d, r.ambient[2] = p;
        const G = r.hash;
        (G.directionalLength !== _ || G.pointLength !== g || G.spotLength !== m || G.rectAreaLength !== y || G.hemiLength !== v || G.numDirectionalShadows !== x || G.numPointShadows !== C || G.numSpotShadows !== S || G.numSpotMaps !== R || G.numLightProbes !== T) && (r.directional.length = _, r.spot.length = m, r.rectArea.length = y, r.point.length = g, r.hemi.length = v, r.directionalShadow.length = x, r.directionalShadowMap.length = x, r.pointShadow.length = C, r.pointShadowMap.length = C, r.spotShadow.length = S, r.spotShadowMap.length = S, r.directionalShadowMatrix.length = x, r.pointShadowMatrix.length = C, r.spotLightMatrix.length = S + R - F, r.spotLightMap.length = R, r.numSpotLightShadowsWithMaps = F, r.numLightProbes = T, G.directionalLength = _, G.pointLength = g, G.spotLength = m, G.rectAreaLength = y, G.hemiLength = v, G.numDirectionalShadows = x, G.numPointShadows = C, G.numSpotShadows = S, G.numSpotMaps = R, G.numLightProbes = T, r.version = _E++)
    }

    function c(u, h) {
        let f = 0,
            d = 0,
            p = 0,
            _ = 0,
            g = 0;
        const m = h.matrixWorldInverse;
        for (let y = 0, v = u.length; y < v; y++) {
            const x = u[y];
            if (x.isDirectionalLight) {
                const C = r.directional[f];
                C.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(m), f++
            } else if (x.isSpotLight) {
                const C = r.spot[p];
                C.position.setFromMatrixPosition(x.matrixWorld), C.position.applyMatrix4(m), C.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(m), p++
            } else if (x.isRectAreaLight) {
                const C = r.rectArea[_];
                C.position.setFromMatrixPosition(x.matrixWorld), C.position.applyMatrix4(m), a.identity(), o.copy(x.matrixWorld), o.premultiply(m), a.extractRotation(o), C.halfWidth.set(x.width * .5, 0, 0), C.halfHeight.set(0, x.height * .5, 0), C.halfWidth.applyMatrix4(a), C.halfHeight.applyMatrix4(a), _++
            } else if (x.isPointLight) {
                const C = r.point[d];
                C.position.setFromMatrixPosition(x.matrixWorld), C.position.applyMatrix4(m), d++
            } else if (x.isHemisphereLight) {
                const C = r.hemi[g];
                C.direction.setFromMatrixPosition(x.matrixWorld), C.direction.transformDirection(m), g++
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: r
    }
}

function sp(n, e) {
    const t = new yE(n, e),
        i = [],
        r = [];

    function s() {
        i.length = 0, r.length = 0
    }

    function o(h) {
        i.push(h)
    }

    function a(h) {
        r.push(h)
    }

    function l(h) {
        t.setup(i, h)
    }

    function c(h) {
        t.setupView(i, h)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}

function xE(n, e) {
    let t = new WeakMap;

    function i(s, o = 0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new sp(n, e), t.set(s, [l])) : o >= a.length ? (l = new sp(n, e), a.push(l)) : l = a[o], l
    }

    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class $g extends Vt {
    constructor(e) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = rM, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }
}
class Xg extends Vt {
    constructor(e) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }
}
const ME = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    bE = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function SE(n, e, t) {
    let i = new wl;
    const r = new ue,
        s = new ue,
        o = new pt,
        a = new $g({
            depthPacking: sM
        }),
        l = new Xg,
        c = {},
        u = t.maxTextureSize,
        h = {
            [zi]: un,
            [un]: zi,
            [En]: En
        },
        f = new Qn({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new ue
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: ME,
            fragmentShader: bE
        }),
        d = f.clone();
    d.defines.HORIZONTAL_PASS = 1;
    const p = new ht;
    p.setAttribute("position", new ut(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const _ = new xt(p, f),
        g = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = vg;
    let m = this.type;
    this.render = function (S, R, F) {
        if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || S.length === 0) return;
        const T = n.getRenderTarget(),
            A = n.getActiveCubeFace(),
            G = n.getActiveMipmapLevel(),
            ee = n.state;
        ee.setBlending(Oi), ee.buffers.color.setClear(1, 1, 1, 1), ee.buffers.depth.setTest(!0), ee.setScissorTest(!1);
        const he = m !== hi && this.type === hi,
            B = m === hi && this.type !== hi;
        for (let V = 0, q = S.length; V < q; V++) {
            const j = S[V],
                J = j.shadow;
            if (J === void 0) {
                console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
                continue
            }
            if (J.autoUpdate === !1 && J.needsUpdate === !1) continue;
            r.copy(J.mapSize);
            const ie = J.getFrameExtents();
            if (r.multiply(ie), s.copy(J.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / ie.x), r.x = s.x * ie.x, J.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / ie.y), r.y = s.y * ie.y, J.mapSize.y = s.y)), J.map === null || he === !0 || B === !0) {
                const de = this.type !== hi ? {
                    minFilter: It,
                    magFilter: It
                } : {};
                J.map !== null && J.map.dispose(), J.map = new pr(r.x, r.y, de), J.map.texture.name = j.name + ".shadowMap", J.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(J.map), n.clear();
            const pe = J.getViewportCount();
            for (let de = 0; de < pe; de++) {
                const xe = J.getViewport(de);
                o.set(s.x * xe.x, s.y * xe.y, s.x * xe.z, s.y * xe.w), ee.viewport(o), J.updateMatrices(j, de), i = J.getFrustum(), x(R, F, J.camera, j, this.type)
            }
            J.isPointLightShadow !== !0 && this.type === hi && y(J, F), J.needsUpdate = !1
        }
        m = this.type, g.needsUpdate = !1, n.setRenderTarget(T, A, G)
    };

    function y(S, R) {
        const F = e.update(_);
        f.defines.VSM_SAMPLES !== S.blurSamples && (f.defines.VSM_SAMPLES = S.blurSamples, d.defines.VSM_SAMPLES = S.blurSamples, f.needsUpdate = !0, d.needsUpdate = !0), S.mapPass === null && (S.mapPass = new pr(r.x, r.y)), f.uniforms.shadow_pass.value = S.map.texture, f.uniforms.resolution.value = S.mapSize, f.uniforms.radius.value = S.radius, n.setRenderTarget(S.mapPass), n.clear(), n.renderBufferDirect(R, null, F, f, _, null), d.uniforms.shadow_pass.value = S.mapPass.texture, d.uniforms.resolution.value = S.mapSize, d.uniforms.radius.value = S.radius, n.setRenderTarget(S.map), n.clear(), n.renderBufferDirect(R, null, F, d, _, null)
    }

    function v(S, R, F, T) {
        let A = null;
        const G = F.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
        if (G !== void 0) A = G;
        else if (A = F.isPointLight === !0 ? l : a, n.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
            const ee = A.uuid,
                he = R.uuid;
            let B = c[ee];
            B === void 0 && (B = {}, c[ee] = B);
            let V = B[he];
            V === void 0 && (V = A.clone(), B[he] = V, R.addEventListener("dispose", C)), A = V
        }
        if (A.visible = R.visible, A.wireframe = R.wireframe, T === hi ? A.side = R.shadowSide !== null ? R.shadowSide : R.side : A.side = R.shadowSide !== null ? R.shadowSide : h[R.side], A.alphaMap = R.alphaMap, A.alphaTest = R.alphaTest, A.map = R.map, A.clipShadows = R.clipShadows, A.clippingPlanes = R.clippingPlanes, A.clipIntersection = R.clipIntersection, A.displacementMap = R.displacementMap, A.displacementScale = R.displacementScale, A.displacementBias = R.displacementBias, A.wireframeLinewidth = R.wireframeLinewidth, A.linewidth = R.linewidth, F.isPointLight === !0 && A.isMeshDistanceMaterial === !0) {
            const ee = n.properties.get(A);
            ee.light = F
        }
        return A
    }

    function x(S, R, F, T, A) {
        if (S.visible === !1) return;
        if (S.layers.test(R.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && A === hi) && (!S.frustumCulled || i.intersectsObject(S))) {
            S.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, S.matrixWorld);
            const he = e.update(S),
                B = S.material;
            if (Array.isArray(B)) {
                const V = he.groups;
                for (let q = 0, j = V.length; q < j; q++) {
                    const J = V[q],
                        ie = B[J.materialIndex];
                    if (ie && ie.visible) {
                        const pe = v(S, ie, T, A);
                        S.onBeforeShadow(n, S, R, F, he, pe, J), n.renderBufferDirect(F, null, he, pe, S, J), S.onAfterShadow(n, S, R, F, he, pe, J)
                    }
                }
            } else if (B.visible) {
                const V = v(S, B, T, A);
                S.onBeforeShadow(n, S, R, F, he, V, null), n.renderBufferDirect(F, null, he, V, S, null), S.onAfterShadow(n, S, R, F, he, V, null)
            }
        }
        const ee = S.children;
        for (let he = 0, B = ee.length; he < B; he++) x(ee[he], R, F, T, A)
    }

    function C(S) {
        S.target.removeEventListener("dispose", C);
        for (const F in c) {
            const T = c[F],
                A = S.target.uuid;
            A in T && (T[A].dispose(), delete T[A])
        }
    }
}

function TE(n, e, t) {
    const i = t.isWebGL2;

    function r() {
        let k = !1;
        const Se = new pt;
        let Te = null;
        const ke = new pt(0, 0, 0, 0);
        return {
            setMask: function (Ne) {
                Te !== Ne && !k && (n.colorMask(Ne, Ne, Ne, Ne), Te = Ne)
            },
            setLocked: function (Ne) {
                k = Ne
            },
            setClear: function (Ne, st, at, Ut, en) {
                en === !0 && (Ne *= Ut, st *= Ut, at *= Ut), Se.set(Ne, st, at, Ut), ke.equals(Se) === !1 && (n.clearColor(Ne, st, at, Ut), ke.copy(Se))
            },
            reset: function () {
                k = !1, Te = null, ke.set(-1, 0, 0, 0)
            }
        }
    }

    function s() {
        let k = !1,
            Se = null,
            Te = null,
            ke = null;
        return {
            setTest: function (Ne) {
                Ne ? ae(n.DEPTH_TEST) : le(n.DEPTH_TEST)
            },
            setMask: function (Ne) {
                Se !== Ne && !k && (n.depthMask(Ne), Se = Ne)
            },
            setFunc: function (Ne) {
                if (Te !== Ne) {
                    switch (Ne) {
                    case Ox:
                        n.depthFunc(n.NEVER);
                        break;
                    case Nx:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case Ux:
                        n.depthFunc(n.LESS);
                        break;
                    case qa:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case Fx:
                        n.depthFunc(n.EQUAL);
                        break;
                    case Bx:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case kx:
                        n.depthFunc(n.GREATER);
                        break;
                    case zx:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    Te = Ne
                }
            },
            setLocked: function (Ne) {
                k = Ne
            },
            setClear: function (Ne) {
                ke !== Ne && (n.clearDepth(Ne), ke = Ne)
            },
            reset: function () {
                k = !1, Se = null, Te = null, ke = null
            }
        }
    }

    function o() {
        let k = !1,
            Se = null,
            Te = null,
            ke = null,
            Ne = null,
            st = null,
            at = null,
            Ut = null,
            en = null;
        return {
            setTest: function (gt) {
                k || (gt ? ae(n.STENCIL_TEST) : le(n.STENCIL_TEST))
            },
            setMask: function (gt) {
                Se !== gt && !k && (n.stencilMask(gt), Se = gt)
            },
            setFunc: function (gt, tn, zn) {
                (Te !== gt || ke !== tn || Ne !== zn) && (n.stencilFunc(gt, tn, zn), Te = gt, ke = tn, Ne = zn)
            },
            setOp: function (gt, tn, zn) {
                (st !== gt || at !== tn || Ut !== zn) && (n.stencilOp(gt, tn, zn), st = gt, at = tn, Ut = zn)
            },
            setLocked: function (gt) {
                k = gt
            },
            setClear: function (gt) {
                en !== gt && (n.clearStencil(gt), en = gt)
            },
            reset: function () {
                k = !1, Se = null, Te = null, ke = null, Ne = null, st = null, at = null, Ut = null, en = null
            }
        }
    }
    const a = new r,
        l = new s,
        c = new o,
        u = new WeakMap,
        h = new WeakMap;
    let f = {},
        d = {},
        p = new WeakMap,
        _ = [],
        g = null,
        m = !1,
        y = null,
        v = null,
        x = null,
        C = null,
        S = null,
        R = null,
        F = null,
        T = new Fe(0, 0, 0),
        A = 0,
        G = !1,
        ee = null,
        he = null,
        B = null,
        V = null,
        q = null;
    const j = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let J = !1,
        ie = 0;
    const pe = n.getParameter(n.VERSION);
    pe.indexOf("WebGL") !== -1 ? (ie = parseFloat(/^WebGL (\d)/.exec(pe)[1]), J = ie >= 1) : pe.indexOf("OpenGL ES") !== -1 && (ie = parseFloat(/^OpenGL ES (\d)/.exec(pe)[1]), J = ie >= 2);
    let de = null,
        xe = {};
    const te = n.getParameter(n.SCISSOR_BOX),
        me = n.getParameter(n.VIEWPORT),
        Re = new pt().fromArray(te),
        Pe = new pt().fromArray(me);

    function H(k, Se, Te, ke) {
        const Ne = new Uint8Array(4),
            st = n.createTexture();
        n.bindTexture(k, st), n.texParameteri(k, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(k, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let at = 0; at < Te; at++) i && (k === n.TEXTURE_3D || k === n.TEXTURE_2D_ARRAY) ? n.texImage3D(Se, 0, n.RGBA, 1, 1, ke, 0, n.RGBA, n.UNSIGNED_BYTE, Ne) : n.texImage2D(Se + at, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Ne);
        return st
    }
    const ce = {};
    ce[n.TEXTURE_2D] = H(n.TEXTURE_2D, n.TEXTURE_2D, 1), ce[n.TEXTURE_CUBE_MAP] = H(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (ce[n.TEXTURE_2D_ARRAY] = H(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), ce[n.TEXTURE_3D] = H(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ae(n.DEPTH_TEST), l.setFunc(qa), Y(!1), b(Bf), ae(n.CULL_FACE), U(Oi);

    function ae(k) {
        f[k] !== !0 && (n.enable(k), f[k] = !0)
    }

    function le(k) {
        f[k] !== !1 && (n.disable(k), f[k] = !1)
    }

    function Ce(k, Se) {
        return d[k] !== Se ? (n.bindFramebuffer(k, Se), d[k] = Se, i && (k === n.DRAW_FRAMEBUFFER && (d[n.FRAMEBUFFER] = Se), k === n.FRAMEBUFFER && (d[n.DRAW_FRAMEBUFFER] = Se)), !0) : !1
    }

    function I(k, Se) {
        let Te = _,
            ke = !1;
        if (k)
            if (Te = p.get(Se), Te === void 0 && (Te = [], p.set(Se, Te)), k.isWebGLMultipleRenderTargets) {
                const Ne = k.texture;
                if (Te.length !== Ne.length || Te[0] !== n.COLOR_ATTACHMENT0) {
                    for (let st = 0, at = Ne.length; st < at; st++) Te[st] = n.COLOR_ATTACHMENT0 + st;
                    Te.length = Ne.length, ke = !0
                }
            } else Te[0] !== n.COLOR_ATTACHMENT0 && (Te[0] = n.COLOR_ATTACHMENT0, ke = !0);
        else Te[0] !== n.BACK && (Te[0] = n.BACK, ke = !0);
        ke && (t.isWebGL2 ? n.drawBuffers(Te) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Te))
    }

    function w(k) {
        return g !== k ? (n.useProgram(k), g = k, !0) : !1
    }
    const E = {
        [Qi]: n.FUNC_ADD,
        [yx]: n.FUNC_SUBTRACT,
        [xx]: n.FUNC_REVERSE_SUBTRACT
    };
    if (i) E[Vf] = n.MIN, E[Hf] = n.MAX;
    else {
        const k = e.get("EXT_blend_minmax");
        k !== null && (E[Vf] = k.MIN_EXT, E[Hf] = k.MAX_EXT)
    }
    const N = {
        [Mx]: n.ZERO,
        [bx]: n.ONE,
        [Sx]: n.SRC_COLOR,
        [lu]: n.SRC_ALPHA,
        [Cx]: n.SRC_ALPHA_SATURATE,
        [Ax]: n.DST_COLOR,
        [wx]: n.DST_ALPHA,
        [Tx]: n.ONE_MINUS_SRC_COLOR,
        [cu]: n.ONE_MINUS_SRC_ALPHA,
        [Rx]: n.ONE_MINUS_DST_COLOR,
        [Ex]: n.ONE_MINUS_DST_ALPHA,
        [Px]: n.CONSTANT_COLOR,
        [Lx]: n.ONE_MINUS_CONSTANT_COLOR,
        [Ix]: n.CONSTANT_ALPHA,
        [Dx]: n.ONE_MINUS_CONSTANT_ALPHA
    };

    function U(k, Se, Te, ke, Ne, st, at, Ut, en, gt) {
        if (k === Oi) {
            m === !0 && (le(n.BLEND), m = !1);
            return
        }
        if (m === !1 && (ae(n.BLEND), m = !0), k !== vx) {
            if (k !== y || gt !== G) {
                if ((v !== Qi || S !== Qi) && (n.blendEquation(n.FUNC_ADD), v = Qi, S = Qi), gt) switch (k) {
                case as:
                    n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                    break;
                case kf:
                    n.blendFunc(n.ONE, n.ONE);
                    break;
                case zf:
                    n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                    break;
                case Gf:
                    n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                    break;
                default:
                    console.error("THREE.WebGLState: Invalid blending: ", k);
                    break
                } else switch (k) {
                case as:
                    n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                    break;
                case kf:
                    n.blendFunc(n.SRC_ALPHA, n.ONE);
                    break;
                case zf:
                    n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                    break;
                case Gf:
                    n.blendFunc(n.ZERO, n.SRC_COLOR);
                    break;
                default:
                    console.error("THREE.WebGLState: Invalid blending: ", k);
                    break
                }
                x = null, C = null, R = null, F = null, T.set(0, 0, 0), A = 0, y = k, G = gt
            }
            return
        }
        Ne = Ne || Se, st = st || Te, at = at || ke, (Se !== v || Ne !== S) && (n.blendEquationSeparate(E[Se], E[Ne]), v = Se, S = Ne), (Te !== x || ke !== C || st !== R || at !== F) && (n.blendFuncSeparate(N[Te], N[ke], N[st], N[at]), x = Te, C = ke, R = st, F = at), (Ut.equals(T) === !1 || en !== A) && (n.blendColor(Ut.r, Ut.g, Ut.b, en), T.copy(Ut), A = en), y = k, G = !1
    }

    function W(k, Se) {
        k.side === En ? le(n.CULL_FACE) : ae(n.CULL_FACE);
        let Te = k.side === un;
        Se && (Te = !Te), Y(Te), k.blending === as && k.transparent === !1 ? U(Oi) : U(k.blending, k.blendEquation, k.blendSrc, k.blendDst, k.blendEquationAlpha, k.blendSrcAlpha, k.blendDstAlpha, k.blendColor, k.blendAlpha, k.premultipliedAlpha), l.setFunc(k.depthFunc), l.setTest(k.depthTest), l.setMask(k.depthWrite), a.setMask(k.colorWrite);
        const ke = k.stencilWrite;
        c.setTest(ke), ke && (c.setMask(k.stencilWriteMask), c.setFunc(k.stencilFunc, k.stencilRef, k.stencilFuncMask), c.setOp(k.stencilFail, k.stencilZFail, k.stencilZPass)), D(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits), k.alphaToCoverage === !0 ? ae(n.SAMPLE_ALPHA_TO_COVERAGE) : le(n.SAMPLE_ALPHA_TO_COVERAGE)
    }

    function Y(k) {
        ee !== k && (k ? n.frontFace(n.CW) : n.frontFace(n.CCW), ee = k)
    }

    function b(k) {
        k !== mx ? (ae(n.CULL_FACE), k !== he && (k === Bf ? n.cullFace(n.BACK) : k === gx ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : le(n.CULL_FACE), he = k
    }

    function M(k) {
        k !== B && (J && n.lineWidth(k), B = k)
    }

    function D(k, Se, Te) {
        k ? (ae(n.POLYGON_OFFSET_FILL), (V !== Se || q !== Te) && (n.polygonOffset(Se, Te), V = Se, q = Te)) : le(n.POLYGON_OFFSET_FILL)
    }

    function z(k) {
        k ? ae(n.SCISSOR_TEST) : le(n.SCISSOR_TEST)
    }

    function $(k) {
        k === void 0 && (k = n.TEXTURE0 + j - 1), de !== k && (n.activeTexture(k), de = k)
    }

    function K(k, Se, Te) {
        Te === void 0 && (de === null ? Te = n.TEXTURE0 + j - 1 : Te = de);
        let ke = xe[Te];
        ke === void 0 && (ke = {
            type: void 0,
            texture: void 0
        }, xe[Te] = ke), (ke.type !== k || ke.texture !== Se) && (de !== Te && (n.activeTexture(Te), de = Te), n.bindTexture(k, Se || ce[k]), ke.type = k, ke.texture = Se)
    }

    function fe() {
        const k = xe[de];
        k !== void 0 && k.type !== void 0 && (n.bindTexture(k.type, null), k.type = void 0, k.texture = void 0)
    }

    function se() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function ge() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function Ee() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function De() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function oe() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function Be() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function O() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function _e() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function Me() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function ye() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (k) {
            console.error("THREE.WebGLState:", k)
        }
    }

    function Le(k) {
        Re.equals(k) === !1 && (n.scissor(k.x, k.y, k.z, k.w), Re.copy(k))
    }

    function ze(k) {
        Pe.equals(k) === !1 && (n.viewport(k.x, k.y, k.z, k.w), Pe.copy(k))
    }

    function et(k, Se) {
        let Te = h.get(Se);
        Te === void 0 && (Te = new WeakMap, h.set(Se, Te));
        let ke = Te.get(k);
        ke === void 0 && (ke = n.getUniformBlockIndex(Se, k.name), Te.set(k, ke))
    }

    function Je(k, Se) {
        const ke = h.get(Se).get(k);
        u.get(Se) !== ke && (n.uniformBlockBinding(Se, ke, k.__bindingPointIndex), u.set(Se, ke))
    }

    function we() {
        n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), f = {}, de = null, xe = {}, d = {}, p = new WeakMap, _ = [], g = null, m = !1, y = null, v = null, x = null, C = null, S = null, R = null, F = null, T = new Fe(0, 0, 0), A = 0, G = !1, ee = null, he = null, B = null, V = null, q = null, Re.set(0, 0, n.canvas.width, n.canvas.height), Pe.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), c.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: ae,
        disable: le,
        bindFramebuffer: Ce,
        drawBuffers: I,
        useProgram: w,
        setBlending: U,
        setMaterial: W,
        setFlipSided: Y,
        setCullFace: b,
        setLineWidth: M,
        setPolygonOffset: D,
        setScissorTest: z,
        activeTexture: $,
        bindTexture: K,
        unbindTexture: fe,
        compressedTexImage2D: se,
        compressedTexImage3D: ge,
        texImage2D: Me,
        texImage3D: ye,
        updateUBOMapping: et,
        uniformBlockBinding: Je,
        texStorage2D: O,
        texStorage3D: _e,
        texSubImage2D: Ee,
        texSubImage3D: De,
        compressedTexSubImage2D: oe,
        compressedTexSubImage3D: Be,
        scissor: Le,
        viewport: ze,
        reset: we
    }
}

function wE(n, e, t, i, r, s, o) {
    const a = r.isWebGL2,
        l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
        c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        u = new WeakMap;
    let h;
    const f = new WeakMap;
    let d = !1;
    try {
        d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {}

    function p(b, M) {
        return d ? new OffscreenCanvas(b, M) : go("canvas")
    }

    function _(b, M, D, z) {
        let $ = 1;
        if ((b.width > z || b.height > z) && ($ = z / Math.max(b.width, b.height)), $ < 1 || M === !0)
            if (typeof HTMLImageElement < "u" && b instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && b instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && b instanceof ImageBitmap) {
                const K = M ? el : Math.floor,
                    fe = K($ * b.width),
                    se = K($ * b.height);
                h === void 0 && (h = p(fe, se));
                const ge = D ? p(fe, se) : h;
                return ge.width = fe, ge.height = se, ge.getContext("2d").drawImage(b, 0, 0, fe, se), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + b.width + "x" + b.height + ") to (" + fe + "x" + se + ")."), ge
            } else return "data" in b && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + b.width + "x" + b.height + ")."), b;
        return b
    }

    function g(b) {
        return fu(b.width) && fu(b.height)
    }

    function m(b) {
        return a ? !1 : b.wrapS !== _n || b.wrapT !== _n || b.minFilter !== It && b.minFilter !== cn
    }

    function y(b, M) {
        return b.generateMipmaps && M && b.minFilter !== It && b.minFilter !== cn
    }

    function v(b) {
        n.generateMipmap(b)
    }

    function x(b, M, D, z, $ = !1) {
        if (a === !1) return M;
        if (b !== null) {
            if (n[b] !== void 0) return n[b];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + b + "'")
        }
        let K = M;
        if (M === n.RED && (D === n.FLOAT && (K = n.R32F), D === n.HALF_FLOAT && (K = n.R16F), D === n.UNSIGNED_BYTE && (K = n.R8)), M === n.RED_INTEGER && (D === n.UNSIGNED_BYTE && (K = n.R8UI), D === n.UNSIGNED_SHORT && (K = n.R16UI), D === n.UNSIGNED_INT && (K = n.R32UI), D === n.BYTE && (K = n.R8I), D === n.SHORT && (K = n.R16I), D === n.INT && (K = n.R32I)), M === n.RG && (D === n.FLOAT && (K = n.RG32F), D === n.HALF_FLOAT && (K = n.RG16F), D === n.UNSIGNED_BYTE && (K = n.RG8)), M === n.RGBA) {
            const fe = $ ? Ja : dt.getTransfer(z);
            D === n.FLOAT && (K = n.RGBA32F), D === n.HALF_FLOAT && (K = n.RGBA16F), D === n.UNSIGNED_BYTE && (K = fe === vt ? n.SRGB8_ALPHA8 : n.RGBA8), D === n.UNSIGNED_SHORT_4_4_4_4 && (K = n.RGBA4), D === n.UNSIGNED_SHORT_5_5_5_1 && (K = n.RGB5_A1)
        }
        return (K === n.R16F || K === n.R32F || K === n.RG16F || K === n.RG32F || K === n.RGBA16F || K === n.RGBA32F) && e.get("EXT_color_buffer_float"), K
    }

    function C(b, M, D) {
        return y(b, D) === !0 || b.isFramebufferTexture && b.minFilter !== It && b.minFilter !== cn ? Math.log2(Math.max(M.width, M.height)) + 1 : b.mipmaps !== void 0 && b.mipmaps.length > 0 ? b.mipmaps.length : b.isCompressedTexture && Array.isArray(b.image) ? M.mipmaps.length : 1
    }

    function S(b) {
        return b === It || b === ja || b === Js ? n.NEAREST : n.LINEAR
    }

    function R(b) {
        const M = b.target;
        M.removeEventListener("dispose", R), T(M), M.isVideoTexture && u.delete(M)
    }

    function F(b) {
        const M = b.target;
        M.removeEventListener("dispose", F), G(M)
    }

    function T(b) {
        const M = i.get(b);
        if (M.__webglInit === void 0) return;
        const D = b.source,
            z = f.get(D);
        if (z) {
            const $ = z[M.__cacheKey];
            $.usedTimes--, $.usedTimes === 0 && A(b), Object.keys(z).length === 0 && f.delete(D)
        }
        i.remove(b)
    }

    function A(b) {
        const M = i.get(b);
        n.deleteTexture(M.__webglTexture);
        const D = b.source,
            z = f.get(D);
        delete z[M.__cacheKey], o.memory.textures--
    }

    function G(b) {
        const M = b.texture,
            D = i.get(b),
            z = i.get(M);
        if (z.__webglTexture !== void 0 && (n.deleteTexture(z.__webglTexture), o.memory.textures--), b.depthTexture && b.depthTexture.dispose(), b.isWebGLCubeRenderTarget)
            for (let $ = 0; $ < 6; $++) {
                if (Array.isArray(D.__webglFramebuffer[$]))
                    for (let K = 0; K < D.__webglFramebuffer[$].length; K++) n.deleteFramebuffer(D.__webglFramebuffer[$][K]);
                else n.deleteFramebuffer(D.__webglFramebuffer[$]);
                D.__webglDepthbuffer && n.deleteRenderbuffer(D.__webglDepthbuffer[$])
            } else {
                if (Array.isArray(D.__webglFramebuffer))
                    for (let $ = 0; $ < D.__webglFramebuffer.length; $++) n.deleteFramebuffer(D.__webglFramebuffer[$]);
                else n.deleteFramebuffer(D.__webglFramebuffer);
                if (D.__webglDepthbuffer && n.deleteRenderbuffer(D.__webglDepthbuffer), D.__webglMultisampledFramebuffer && n.deleteFramebuffer(D.__webglMultisampledFramebuffer), D.__webglColorRenderbuffer)
                    for (let $ = 0; $ < D.__webglColorRenderbuffer.length; $++) D.__webglColorRenderbuffer[$] && n.deleteRenderbuffer(D.__webglColorRenderbuffer[$]);
                D.__webglDepthRenderbuffer && n.deleteRenderbuffer(D.__webglDepthRenderbuffer)
            }
        if (b.isWebGLMultipleRenderTargets)
            for (let $ = 0, K = M.length; $ < K; $++) {
                const fe = i.get(M[$]);
                fe.__webglTexture && (n.deleteTexture(fe.__webglTexture), o.memory.textures--), i.remove(M[$])
            }
        i.remove(M), i.remove(b)
    }
    let ee = 0;

    function he() {
        ee = 0
    }

    function B() {
        const b = ee;
        return b >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + b + " texture units while this GPU supports only " + r.maxTextures), ee += 1, b
    }

    function V(b) {
        const M = [];
        return M.push(b.wrapS), M.push(b.wrapT), M.push(b.wrapR || 0), M.push(b.magFilter), M.push(b.minFilter), M.push(b.anisotropy), M.push(b.internalFormat), M.push(b.format), M.push(b.type), M.push(b.generateMipmaps), M.push(b.premultiplyAlpha), M.push(b.flipY), M.push(b.unpackAlignment), M.push(b.colorSpace), M.join()
    }

    function q(b, M) {
        const D = i.get(b);
        if (b.isVideoTexture && W(b), b.isRenderTargetTexture === !1 && b.version > 0 && D.__version !== b.version) {
            const z = b.image;
            if (z === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (z.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Re(D, b, M);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, D.__webglTexture, n.TEXTURE0 + M)
    }

    function j(b, M) {
        const D = i.get(b);
        if (b.version > 0 && D.__version !== b.version) {
            Re(D, b, M);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, D.__webglTexture, n.TEXTURE0 + M)
    }

    function J(b, M) {
        const D = i.get(b);
        if (b.version > 0 && D.__version !== b.version) {
            Re(D, b, M);
            return
        }
        t.bindTexture(n.TEXTURE_3D, D.__webglTexture, n.TEXTURE0 + M)
    }

    function ie(b, M) {
        const D = i.get(b);
        if (b.version > 0 && D.__version !== b.version) {
            Pe(D, b, M);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, D.__webglTexture, n.TEXTURE0 + M)
    }
    const pe = {
            [co]: n.REPEAT,
            [_n]: n.CLAMP_TO_EDGE,
            [uo]: n.MIRRORED_REPEAT
        },
        de = {
            [It]: n.NEAREST,
            [ja]: n.NEAREST_MIPMAP_NEAREST,
            [Js]: n.NEAREST_MIPMAP_LINEAR,
            [cn]: n.LINEAR,
            [qu]: n.LINEAR_MIPMAP_NEAREST,
            [dr]: n.LINEAR_MIPMAP_LINEAR
        },
        xe = {
            [aM]: n.NEVER,
            [dM]: n.ALWAYS,
            [lM]: n.LESS,
            [Rg]: n.LEQUAL,
            [cM]: n.EQUAL,
            [fM]: n.GEQUAL,
            [uM]: n.GREATER,
            [hM]: n.NOTEQUAL
        };

    function te(b, M, D) {
        if (D ? (n.texParameteri(b, n.TEXTURE_WRAP_S, pe[M.wrapS]), n.texParameteri(b, n.TEXTURE_WRAP_T, pe[M.wrapT]), (b === n.TEXTURE_3D || b === n.TEXTURE_2D_ARRAY) && n.texParameteri(b, n.TEXTURE_WRAP_R, pe[M.wrapR]), n.texParameteri(b, n.TEXTURE_MAG_FILTER, de[M.magFilter]), n.texParameteri(b, n.TEXTURE_MIN_FILTER, de[M.minFilter])) : (n.texParameteri(b, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(b, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (b === n.TEXTURE_3D || b === n.TEXTURE_2D_ARRAY) && n.texParameteri(b, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (M.wrapS !== _n || M.wrapT !== _n) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(b, n.TEXTURE_MAG_FILTER, S(M.magFilter)), n.texParameteri(b, n.TEXTURE_MIN_FILTER, S(M.minFilter)), M.minFilter !== It && M.minFilter !== cn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), M.compareFunction && (n.texParameteri(b, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(b, n.TEXTURE_COMPARE_FUNC, xe[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
            const z = e.get("EXT_texture_filter_anisotropic");
            if (M.magFilter === It || M.minFilter !== Js && M.minFilter !== dr || M.type === qn && e.has("OES_texture_float_linear") === !1 || a === !1 && M.type === ho && e.has("OES_texture_half_float_linear") === !1) return;
            (M.anisotropy > 1 || i.get(M).__currentAnisotropy) && (n.texParameterf(b, z.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, r.getMaxAnisotropy())), i.get(M).__currentAnisotropy = M.anisotropy)
        }
    }

    function me(b, M) {
        let D = !1;
        b.__webglInit === void 0 && (b.__webglInit = !0, M.addEventListener("dispose", R));
        const z = M.source;
        let $ = f.get(z);
        $ === void 0 && ($ = {}, f.set(z, $));
        const K = V(M);
        if (K !== b.__cacheKey) {
            $[K] === void 0 && ($[K] = {
                texture: n.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, D = !0), $[K].usedTimes++;
            const fe = $[b.__cacheKey];
            fe !== void 0 && ($[b.__cacheKey].usedTimes--, fe.usedTimes === 0 && A(M)), b.__cacheKey = K, b.__webglTexture = $[K].texture
        }
        return D
    }

    function Re(b, M, D) {
        let z = n.TEXTURE_2D;
        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (z = n.TEXTURE_2D_ARRAY), M.isData3DTexture && (z = n.TEXTURE_3D);
        const $ = me(b, M),
            K = M.source;
        t.bindTexture(z, b.__webglTexture, n.TEXTURE0 + D);
        const fe = i.get(K);
        if (K.version !== fe.__version || $ === !0) {
            t.activeTexture(n.TEXTURE0 + D);
            const se = dt.getPrimaries(dt.workingColorSpace),
                ge = M.colorSpace === vn ? null : dt.getPrimaries(M.colorSpace),
                Ee = M.colorSpace === vn || se === ge ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, M.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, M.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
            const De = m(M) && g(M.image) === !1;
            let oe = _(M.image, De, !1, r.maxTextureSize);
            oe = Y(M, oe);
            const Be = g(oe) || a,
                O = s.convert(M.format, M.colorSpace);
            let _e = s.convert(M.type),
                Me = x(M.internalFormat, O, _e, M.colorSpace, M.isVideoTexture);
            te(z, M, Be);
            let ye;
            const Le = M.mipmaps,
                ze = a && M.isVideoTexture !== !0 && Me !== Eg,
                et = fe.__version === void 0 || $ === !0,
                Je = C(M, oe, Be);
            if (M.isDepthTexture) Me = n.DEPTH_COMPONENT, a ? M.type === qn ? Me = n.DEPTH_COMPONENT32F : M.type === Pi ? Me = n.DEPTH_COMPONENT24 : M.type === lr ? Me = n.DEPTH24_STENCIL8 : Me = n.DEPTH_COMPONENT16 : M.type === qn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), M.format === cr && Me === n.DEPTH_COMPONENT && M.type !== Yu && M.type !== Pi && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), M.type = Pi, _e = s.convert(M.type)), M.format === ms && Me === n.DEPTH_COMPONENT && (Me = n.DEPTH_STENCIL, M.type !== lr && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), M.type = lr, _e = s.convert(M.type))), et && (ze ? t.texStorage2D(n.TEXTURE_2D, 1, Me, oe.width, oe.height) : t.texImage2D(n.TEXTURE_2D, 0, Me, oe.width, oe.height, 0, O, _e, null));
            else if (M.isDataTexture)
                if (Le.length > 0 && Be) {
                    ze && et && t.texStorage2D(n.TEXTURE_2D, Je, Me, Le[0].width, Le[0].height);
                    for (let we = 0, k = Le.length; we < k; we++) ye = Le[we], ze ? t.texSubImage2D(n.TEXTURE_2D, we, 0, 0, ye.width, ye.height, O, _e, ye.data) : t.texImage2D(n.TEXTURE_2D, we, Me, ye.width, ye.height, 0, O, _e, ye.data);
                    M.generateMipmaps = !1
                } else ze ? (et && t.texStorage2D(n.TEXTURE_2D, Je, Me, oe.width, oe.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, oe.width, oe.height, O, _e, oe.data)) : t.texImage2D(n.TEXTURE_2D, 0, Me, oe.width, oe.height, 0, O, _e, oe.data);
            else if (M.isCompressedTexture)
                if (M.isCompressedArrayTexture) {
                    ze && et && t.texStorage3D(n.TEXTURE_2D_ARRAY, Je, Me, Le[0].width, Le[0].height, oe.depth);
                    for (let we = 0, k = Le.length; we < k; we++) ye = Le[we], M.format !== on ? O !== null ? ze ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, we, 0, 0, 0, ye.width, ye.height, oe.depth, O, ye.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, we, Me, ye.width, ye.height, oe.depth, 0, ye.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ze ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, we, 0, 0, 0, ye.width, ye.height, oe.depth, O, _e, ye.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, we, Me, ye.width, ye.height, oe.depth, 0, O, _e, ye.data)
                } else {
                    ze && et && t.texStorage2D(n.TEXTURE_2D, Je, Me, Le[0].width, Le[0].height);
                    for (let we = 0, k = Le.length; we < k; we++) ye = Le[we], M.format !== on ? O !== null ? ze ? t.compressedTexSubImage2D(n.TEXTURE_2D, we, 0, 0, ye.width, ye.height, O, ye.data) : t.compressedTexImage2D(n.TEXTURE_2D, we, Me, ye.width, ye.height, 0, ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ze ? t.texSubImage2D(n.TEXTURE_2D, we, 0, 0, ye.width, ye.height, O, _e, ye.data) : t.texImage2D(n.TEXTURE_2D, we, Me, ye.width, ye.height, 0, O, _e, ye.data)
                }
            else if (M.isDataArrayTexture) ze ? (et && t.texStorage3D(n.TEXTURE_2D_ARRAY, Je, Me, oe.width, oe.height, oe.depth), t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, oe.width, oe.height, oe.depth, O, _e, oe.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Me, oe.width, oe.height, oe.depth, 0, O, _e, oe.data);
            else if (M.isData3DTexture) ze ? (et && t.texStorage3D(n.TEXTURE_3D, Je, Me, oe.width, oe.height, oe.depth), t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, oe.width, oe.height, oe.depth, O, _e, oe.data)) : t.texImage3D(n.TEXTURE_3D, 0, Me, oe.width, oe.height, oe.depth, 0, O, _e, oe.data);
            else if (M.isFramebufferTexture) {
                if (et)
                    if (ze) t.texStorage2D(n.TEXTURE_2D, Je, Me, oe.width, oe.height);
                    else {
                        let we = oe.width,
                            k = oe.height;
                        for (let Se = 0; Se < Je; Se++) t.texImage2D(n.TEXTURE_2D, Se, Me, we, k, 0, O, _e, null), we >>= 1, k >>= 1
                    }
            } else if (Le.length > 0 && Be) {
                ze && et && t.texStorage2D(n.TEXTURE_2D, Je, Me, Le[0].width, Le[0].height);
                for (let we = 0, k = Le.length; we < k; we++) ye = Le[we], ze ? t.texSubImage2D(n.TEXTURE_2D, we, 0, 0, O, _e, ye) : t.texImage2D(n.TEXTURE_2D, we, Me, O, _e, ye);
                M.generateMipmaps = !1
            } else ze ? (et && t.texStorage2D(n.TEXTURE_2D, Je, Me, oe.width, oe.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, O, _e, oe)) : t.texImage2D(n.TEXTURE_2D, 0, Me, O, _e, oe);
            y(M, Be) && v(z), fe.__version = K.version, M.onUpdate && M.onUpdate(M)
        }
        b.__version = M.version
    }

    function Pe(b, M, D) {
        if (M.image.length !== 6) return;
        const z = me(b, M),
            $ = M.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, b.__webglTexture, n.TEXTURE0 + D);
        const K = i.get($);
        if ($.version !== K.__version || z === !0) {
            t.activeTexture(n.TEXTURE0 + D);
            const fe = dt.getPrimaries(dt.workingColorSpace),
                se = M.colorSpace === vn ? null : dt.getPrimaries(M.colorSpace),
                ge = M.colorSpace === vn || fe === se ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, M.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, M.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ge);
            const Ee = M.isCompressedTexture || M.image[0].isCompressedTexture,
                De = M.image[0] && M.image[0].isDataTexture,
                oe = [];
            for (let we = 0; we < 6; we++) !Ee && !De ? oe[we] = _(M.image[we], !1, !0, r.maxCubemapSize) : oe[we] = De ? M.image[we].image : M.image[we], oe[we] = Y(M, oe[we]);
            const Be = oe[0],
                O = g(Be) || a,
                _e = s.convert(M.format, M.colorSpace),
                Me = s.convert(M.type),
                ye = x(M.internalFormat, _e, Me, M.colorSpace),
                Le = a && M.isVideoTexture !== !0,
                ze = K.__version === void 0 || z === !0;
            let et = C(M, Be, O);
            te(n.TEXTURE_CUBE_MAP, M, O);
            let Je;
            if (Ee) {
                Le && ze && t.texStorage2D(n.TEXTURE_CUBE_MAP, et, ye, Be.width, Be.height);
                for (let we = 0; we < 6; we++) {
                    Je = oe[we].mipmaps;
                    for (let k = 0; k < Je.length; k++) {
                        const Se = Je[k];
                        M.format !== on ? _e !== null ? Le ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k, 0, 0, Se.width, Se.height, _e, Se.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k, ye, Se.width, Se.height, 0, Se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Le ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k, 0, 0, Se.width, Se.height, _e, Me, Se.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k, ye, Se.width, Se.height, 0, _e, Me, Se.data)
                    }
                }
            } else {
                Je = M.mipmaps, Le && ze && (Je.length > 0 && et++, t.texStorage2D(n.TEXTURE_CUBE_MAP, et, ye, oe[0].width, oe[0].height));
                for (let we = 0; we < 6; we++)
                    if (De) {
                        Le ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0, 0, 0, oe[we].width, oe[we].height, _e, Me, oe[we].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0, ye, oe[we].width, oe[we].height, 0, _e, Me, oe[we].data);
                        for (let k = 0; k < Je.length; k++) {
                            const Te = Je[k].image[we].image;
                            Le ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k + 1, 0, 0, Te.width, Te.height, _e, Me, Te.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k + 1, ye, Te.width, Te.height, 0, _e, Me, Te.data)
                        }
                    } else {
                        Le ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0, 0, 0, _e, Me, oe[we]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0, ye, _e, Me, oe[we]);
                        for (let k = 0; k < Je.length; k++) {
                            const Se = Je[k];
                            Le ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k + 1, 0, 0, _e, Me, Se.image[we]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + we, k + 1, ye, _e, Me, Se.image[we])
                        }
                    }
            }
            y(M, O) && v(n.TEXTURE_CUBE_MAP), K.__version = $.version, M.onUpdate && M.onUpdate(M)
        }
        b.__version = M.version
    }

    function H(b, M, D, z, $, K) {
        const fe = s.convert(D.format, D.colorSpace),
            se = s.convert(D.type),
            ge = x(D.internalFormat, fe, se, D.colorSpace);
        if (!i.get(M).__hasExternalTextures) {
            const De = Math.max(1, M.width >> K),
                oe = Math.max(1, M.height >> K);
            $ === n.TEXTURE_3D || $ === n.TEXTURE_2D_ARRAY ? t.texImage3D($, K, ge, De, oe, M.depth, 0, fe, se, null) : t.texImage2D($, K, ge, De, oe, 0, fe, se, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, b), U(M) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, z, $, i.get(D).__webglTexture, 0, N(M)) : ($ === n.TEXTURE_2D || $ >= n.TEXTURE_CUBE_MAP_POSITIVE_X && $ <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, z, $, i.get(D).__webglTexture, K), t.bindFramebuffer(n.FRAMEBUFFER, null)
    }

    function ce(b, M, D) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, b), M.depthBuffer && !M.stencilBuffer) {
            let z = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
            if (D || U(M)) {
                const $ = M.depthTexture;
                $ && $.isDepthTexture && ($.type === qn ? z = n.DEPTH_COMPONENT32F : $.type === Pi && (z = n.DEPTH_COMPONENT24));
                const K = N(M);
                U(M) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, K, z, M.width, M.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, K, z, M.width, M.height)
            } else n.renderbufferStorage(n.RENDERBUFFER, z, M.width, M.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, b)
        } else if (M.depthBuffer && M.stencilBuffer) {
            const z = N(M);
            D && U(M) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, z, n.DEPTH24_STENCIL8, M.width, M.height) : U(M) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, z, n.DEPTH24_STENCIL8, M.width, M.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, M.width, M.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, b)
        } else {
            const z = M.isWebGLMultipleRenderTargets === !0 ? M.texture : [M.texture];
            for (let $ = 0; $ < z.length; $++) {
                const K = z[$],
                    fe = s.convert(K.format, K.colorSpace),
                    se = s.convert(K.type),
                    ge = x(K.internalFormat, fe, se, K.colorSpace),
                    Ee = N(M);
                D && U(M) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Ee, ge, M.width, M.height) : U(M) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Ee, ge, M.width, M.height) : n.renderbufferStorage(n.RENDERBUFFER, ge, M.width, M.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }

    function ae(b, M) {
        if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, b), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(M.depthTexture).__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = !0), q(M.depthTexture, 0);
        const z = i.get(M.depthTexture).__webglTexture,
            $ = N(M);
        if (M.depthTexture.format === cr) U(M) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, z, 0, $) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, z, 0);
        else if (M.depthTexture.format === ms) U(M) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, z, 0, $) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, z, 0);
        else throw new Error("Unknown depthTexture format")
    }

    function le(b) {
        const M = i.get(b),
            D = b.isWebGLCubeRenderTarget === !0;
        if (b.depthTexture && !M.__autoAllocateDepthBuffer) {
            if (D) throw new Error("target.depthTexture not supported in Cube render targets");
            ae(M.__webglFramebuffer, b)
        } else if (D) {
            M.__webglDepthbuffer = [];
            for (let z = 0; z < 6; z++) t.bindFramebuffer(n.FRAMEBUFFER, M.__webglFramebuffer[z]), M.__webglDepthbuffer[z] = n.createRenderbuffer(), ce(M.__webglDepthbuffer[z], b, !1)
        } else t.bindFramebuffer(n.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer = n.createRenderbuffer(), ce(M.__webglDepthbuffer, b, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }

    function Ce(b, M, D) {
        const z = i.get(b);
        M !== void 0 && H(z.__webglFramebuffer, b, b.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), D !== void 0 && le(b)
    }

    function I(b) {
        const M = b.texture,
            D = i.get(b),
            z = i.get(M);
        b.addEventListener("dispose", F), b.isWebGLMultipleRenderTargets !== !0 && (z.__webglTexture === void 0 && (z.__webglTexture = n.createTexture()), z.__version = M.version, o.memory.textures++);
        const $ = b.isWebGLCubeRenderTarget === !0,
            K = b.isWebGLMultipleRenderTargets === !0,
            fe = g(b) || a;
        if ($) {
            D.__webglFramebuffer = [];
            for (let se = 0; se < 6; se++)
                if (a && M.mipmaps && M.mipmaps.length > 0) {
                    D.__webglFramebuffer[se] = [];
                    for (let ge = 0; ge < M.mipmaps.length; ge++) D.__webglFramebuffer[se][ge] = n.createFramebuffer()
                } else D.__webglFramebuffer[se] = n.createFramebuffer()
        } else {
            if (a && M.mipmaps && M.mipmaps.length > 0) {
                D.__webglFramebuffer = [];
                for (let se = 0; se < M.mipmaps.length; se++) D.__webglFramebuffer[se] = n.createFramebuffer()
            } else D.__webglFramebuffer = n.createFramebuffer();
            if (K)
                if (r.drawBuffers) {
                    const se = b.texture;
                    for (let ge = 0, Ee = se.length; ge < Ee; ge++) {
                        const De = i.get(se[ge]);
                        De.__webglTexture === void 0 && (De.__webglTexture = n.createTexture(), o.memory.textures++)
                    }
                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && b.samples > 0 && U(b) === !1) {
                const se = K ? M : [M];
                D.__webglMultisampledFramebuffer = n.createFramebuffer(), D.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, D.__webglMultisampledFramebuffer);
                for (let ge = 0; ge < se.length; ge++) {
                    const Ee = se[ge];
                    D.__webglColorRenderbuffer[ge] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, D.__webglColorRenderbuffer[ge]);
                    const De = s.convert(Ee.format, Ee.colorSpace),
                        oe = s.convert(Ee.type),
                        Be = x(Ee.internalFormat, De, oe, Ee.colorSpace, b.isXRRenderTarget === !0),
                        O = N(b);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, O, Be, b.width, b.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ge, n.RENDERBUFFER, D.__webglColorRenderbuffer[ge])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null), b.depthBuffer && (D.__webglDepthRenderbuffer = n.createRenderbuffer(), ce(D.__webglDepthRenderbuffer, b, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if ($) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, z.__webglTexture), te(n.TEXTURE_CUBE_MAP, M, fe);
            for (let se = 0; se < 6; se++)
                if (a && M.mipmaps && M.mipmaps.length > 0)
                    for (let ge = 0; ge < M.mipmaps.length; ge++) H(D.__webglFramebuffer[se][ge], b, M, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + se, ge);
                else H(D.__webglFramebuffer[se], b, M, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0);
            y(M, fe) && v(n.TEXTURE_CUBE_MAP), t.unbindTexture()
        } else if (K) {
            const se = b.texture;
            for (let ge = 0, Ee = se.length; ge < Ee; ge++) {
                const De = se[ge],
                    oe = i.get(De);
                t.bindTexture(n.TEXTURE_2D, oe.__webglTexture), te(n.TEXTURE_2D, De, fe), H(D.__webglFramebuffer, b, De, n.COLOR_ATTACHMENT0 + ge, n.TEXTURE_2D, 0), y(De, fe) && v(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let se = n.TEXTURE_2D;
            if ((b.isWebGL3DRenderTarget || b.isWebGLArrayRenderTarget) && (a ? se = b.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(se, z.__webglTexture), te(se, M, fe), a && M.mipmaps && M.mipmaps.length > 0)
                for (let ge = 0; ge < M.mipmaps.length; ge++) H(D.__webglFramebuffer[ge], b, M, n.COLOR_ATTACHMENT0, se, ge);
            else H(D.__webglFramebuffer, b, M, n.COLOR_ATTACHMENT0, se, 0);
            y(M, fe) && v(se), t.unbindTexture()
        }
        b.depthBuffer && le(b)
    }

    function w(b) {
        const M = g(b) || a,
            D = b.isWebGLMultipleRenderTargets === !0 ? b.texture : [b.texture];
        for (let z = 0, $ = D.length; z < $; z++) {
            const K = D[z];
            if (y(K, M)) {
                const fe = b.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D,
                    se = i.get(K).__webglTexture;
                t.bindTexture(fe, se), v(fe), t.unbindTexture()
            }
        }
    }

    function E(b) {
        if (a && b.samples > 0 && U(b) === !1) {
            const M = b.isWebGLMultipleRenderTargets ? b.texture : [b.texture],
                D = b.width,
                z = b.height;
            let $ = n.COLOR_BUFFER_BIT;
            const K = [],
                fe = b.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                se = i.get(b),
                ge = b.isWebGLMultipleRenderTargets === !0;
            if (ge)
                for (let Ee = 0; Ee < M.length; Ee++) t.bindFramebuffer(n.FRAMEBUFFER, se.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, se.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, se.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, se.__webglFramebuffer);
            for (let Ee = 0; Ee < M.length; Ee++) {
                K.push(n.COLOR_ATTACHMENT0 + Ee), b.depthBuffer && K.push(fe);
                const De = se.__ignoreDepthValues !== void 0 ? se.__ignoreDepthValues : !1;
                if (De === !1 && (b.depthBuffer && ($ |= n.DEPTH_BUFFER_BIT), b.stencilBuffer && ($ |= n.STENCIL_BUFFER_BIT)), ge && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, se.__webglColorRenderbuffer[Ee]), De === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [fe]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [fe])), ge) {
                    const oe = i.get(M[Ee]).__webglTexture;
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, oe, 0)
                }
                n.blitFramebuffer(0, 0, D, z, 0, 0, D, z, $, n.NEAREST), c && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, K)
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), ge)
                for (let Ee = 0; Ee < M.length; Ee++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, se.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.RENDERBUFFER, se.__webglColorRenderbuffer[Ee]);
                    const De = i.get(M[Ee]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, se.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.TEXTURE_2D, De, 0)
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, se.__webglMultisampledFramebuffer)
        }
    }

    function N(b) {
        return Math.min(r.maxSamples, b.samples)
    }

    function U(b) {
        const M = i.get(b);
        return a && b.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1
    }

    function W(b) {
        const M = o.render.frame;
        u.get(b) !== M && (u.set(b, M), b.update())
    }

    function Y(b, M) {
        const D = b.colorSpace,
            z = b.format,
            $ = b.type;
        return b.isCompressedTexture === !0 || b.isVideoTexture === !0 || b.format === hu || D !== mi && D !== vn && (dt.getTransfer(D) === vt ? a === !1 ? e.has("EXT_sRGB") === !0 && z === on ? (b.format = hu, b.minFilter = cn, b.generateMipmaps = !1) : M = Pg.sRGBToLinear(M) : (z !== on || $ !== Ui) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", D)), M
    }
    this.allocateTextureUnit = B, this.resetTextureUnits = he, this.setTexture2D = q, this.setTexture2DArray = j, this.setTexture3D = J, this.setTextureCube = ie, this.rebindTextures = Ce, this.setupRenderTarget = I, this.updateRenderTargetMipmap = w, this.updateMultisampleRenderTarget = E, this.setupDepthRenderbuffer = le, this.setupFrameBufferTexture = H, this.useMultisampledRTT = U
}

function EE(n, e, t) {
    const i = t.isWebGL2;

    function r(s, o = vn) {
        let a;
        const l = dt.getTransfer(o);
        if (s === Ui) return n.UNSIGNED_BYTE;
        if (s === Mg) return n.UNSIGNED_SHORT_4_4_4_4;
        if (s === bg) return n.UNSIGNED_SHORT_5_5_5_1;
        if (s === Kx) return n.BYTE;
        if (s === jx) return n.SHORT;
        if (s === Yu) return n.UNSIGNED_SHORT;
        if (s === xg) return n.INT;
        if (s === Pi) return n.UNSIGNED_INT;
        if (s === qn) return n.FLOAT;
        if (s === ho) return i ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
        if (s === Jx) return n.ALPHA;
        if (s === on) return n.RGBA;
        if (s === Zx) return n.LUMINANCE;
        if (s === Qx) return n.LUMINANCE_ALPHA;
        if (s === cr) return n.DEPTH_COMPONENT;
        if (s === ms) return n.DEPTH_STENCIL;
        if (s === hu) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === eM) return n.RED;
        if (s === Sg) return n.RED_INTEGER;
        if (s === tM) return n.RG;
        if (s === Tg) return n.RG_INTEGER;
        if (s === wg) return n.RGBA_INTEGER;
        if (s === Ql || s === ec || s === tc || s === nc)
            if (l === vt)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
                    if (s === Ql) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === ec) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === tc) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === nc) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else return null;
        else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
            if (s === Ql) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (s === ec) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (s === tc) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (s === nc) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null;
        if (s === $f || s === Xf || s === qf || s === Yf)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
                if (s === $f) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === Xf) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === qf) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === Yf) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
        if (s === Eg) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === Kf || s === jf)
            if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
                if (s === Kf) return l === vt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === jf) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
        if (s === Jf || s === Zf || s === Qf || s === ed || s === td || s === nd || s === id || s === rd || s === sd || s === od || s === ad || s === ld || s === cd || s === ud)
            if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
                if (s === Jf) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === Zf) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === Qf) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === ed) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === td) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === nd) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === id) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === rd) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === sd) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === od) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === ad) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === ld) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === cd) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === ud) return l === vt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
        if (s === ic || s === hd || s === fd)
            if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
                if (s === ic) return l === vt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (s === hd) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (s === fd) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else return null;
        if (s === nM || s === dd || s === pd || s === md)
            if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
                if (s === ic) return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === dd) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === pd) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === md) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
        return s === lr ? i ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class AE extends qt {
    constructor(e = []) {
        super(), this.isArrayCamera = !0, this.cameras = e
    }
}
class es extends Mt {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
}
const RE = {
    type: "move"
};
class Ac {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new es, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new es, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new L, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new L), this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new es, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new L, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new L), this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values()) this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }), this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(e, t, i) {
        let r = null,
            s = null,
            o = null;
        const a = this._targetRay,
            l = this._grip,
            c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const _ of e.hand.values()) {
                    const g = t.getJointPose(_, i),
                        m = this._getHandJoint(c, _);
                    g !== null && (m.matrix.fromArray(g.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = g.radius), m.visible = g !== null
                }
                const u = c.joints["index-finger-tip"],
                    h = c.joints["thumb-tip"],
                    f = u.position.distanceTo(h.position),
                    d = .02,
                    p = .005;
                c.inputState.pinching && f > d + p ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && f <= d - p && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(RE)))
        }
        return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new es;
            i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class CE extends Mr {
    constructor(e, t) {
        super();
        const i = this;
        let r = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            u = null,
            h = null,
            f = null,
            d = null,
            p = null;
        const _ = t.getContextAttributes();
        let g = null,
            m = null;
        const y = [],
            v = [],
            x = new ue;
        let C = null;
        const S = new qt;
        S.layers.enable(1), S.viewport = new pt;
        const R = new qt;
        R.layers.enable(2), R.viewport = new pt;
        const F = [S, R],
            T = new AE;
        T.layers.enable(1), T.layers.enable(2);
        let A = null,
            G = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (te) {
            let me = y[te];
            return me === void 0 && (me = new Ac, y[te] = me), me.getTargetRaySpace()
        }, this.getControllerGrip = function (te) {
            let me = y[te];
            return me === void 0 && (me = new Ac, y[te] = me), me.getGripSpace()
        }, this.getHand = function (te) {
            let me = y[te];
            return me === void 0 && (me = new Ac, y[te] = me), me.getHandSpace()
        };

        function ee(te) {
            const me = v.indexOf(te.inputSource);
            if (me === -1) return;
            const Re = y[me];
            Re !== void 0 && (Re.update(te.inputSource, te.frame, c || o), Re.dispatchEvent({
                type: te.type,
                data: te.inputSource
            }))
        }

        function he() {
            r.removeEventListener("select", ee), r.removeEventListener("selectstart", ee), r.removeEventListener("selectend", ee), r.removeEventListener("squeeze", ee), r.removeEventListener("squeezestart", ee), r.removeEventListener("squeezeend", ee), r.removeEventListener("end", he), r.removeEventListener("inputsourceschange", B);
            for (let te = 0; te < y.length; te++) {
                const me = v[te];
                me !== null && (v[te] = null, y[te].disconnect(me))
            }
            A = null, G = null, e.setRenderTarget(g), d = null, f = null, h = null, r = null, m = null, xe.stop(), i.isPresenting = !1, e.setPixelRatio(C), e.setSize(x.width, x.height, !1), i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function (te) {
            s = te, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function (te) {
            a = te, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function () {
            return c || o
        }, this.setReferenceSpace = function (te) {
            c = te
        }, this.getBaseLayer = function () {
            return f !== null ? f : d
        }, this.getBinding = function () {
            return h
        }, this.getFrame = function () {
            return p
        }, this.getSession = function () {
            return r
        }, this.setSession = async function (te) {
            if (r = te, r !== null) {
                if (g = e.getRenderTarget(), r.addEventListener("select", ee), r.addEventListener("selectstart", ee), r.addEventListener("selectend", ee), r.addEventListener("squeeze", ee), r.addEventListener("squeezestart", ee), r.addEventListener("squeezeend", ee), r.addEventListener("end", he), r.addEventListener("inputsourceschange", B), _.xrCompatible !== !0 && await t.makeXRCompatible(), C = e.getPixelRatio(), e.getSize(x), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const me = {
                        antialias: r.renderState.layers === void 0 ? _.antialias : !0,
                        alpha: !0,
                        depth: _.depth,
                        stencil: _.stencil,
                        framebufferScaleFactor: s
                    };
                    d = new XRWebGLLayer(r, t, me), r.updateRenderState({
                        baseLayer: d
                    }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), m = new pr(d.framebufferWidth, d.framebufferHeight, {
                        format: on,
                        type: Ui,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: _.stencil
                    })
                } else {
                    let me = null,
                        Re = null,
                        Pe = null;
                    _.depth && (Pe = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, me = _.stencil ? ms : cr, Re = _.stencil ? lr : Pi);
                    const H = {
                        colorFormat: t.RGBA8,
                        depthFormat: Pe,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r, t), f = h.createProjectionLayer(H), r.updateRenderState({
                        layers: [f]
                    }), e.setPixelRatio(1), e.setSize(f.textureWidth, f.textureHeight, !1), m = new pr(f.textureWidth, f.textureHeight, {
                        format: on,
                        type: Ui,
                        depthTexture: new kg(f.textureWidth, f.textureHeight, Re, void 0, void 0, void 0, void 0, void 0, void 0, me),
                        stencilBuffer: _.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: _.antialias ? 4 : 0
                    });
                    const ce = e.properties.get(m);
                    ce.__ignoreDepthValues = f.ignoreDepthValues
                }
                m.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await r.requestReferenceSpace(a), xe.setContext(r), xe.start(), i.isPresenting = !0, i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }, this.getEnvironmentBlendMode = function () {
            if (r !== null) return r.environmentBlendMode
        };

        function B(te) {
            for (let me = 0; me < te.removed.length; me++) {
                const Re = te.removed[me],
                    Pe = v.indexOf(Re);
                Pe >= 0 && (v[Pe] = null, y[Pe].disconnect(Re))
            }
            for (let me = 0; me < te.added.length; me++) {
                const Re = te.added[me];
                let Pe = v.indexOf(Re);
                if (Pe === -1) {
                    for (let ce = 0; ce < y.length; ce++)
                        if (ce >= v.length) {
                            v.push(Re), Pe = ce;
                            break
                        } else if (v[ce] === null) {
                        v[ce] = Re, Pe = ce;
                        break
                    }
                    if (Pe === -1) break
                }
                const H = y[Pe];
                H && H.connect(Re)
            }
        }
        const V = new L,
            q = new L;

        function j(te, me, Re) {
            V.setFromMatrixPosition(me.matrixWorld), q.setFromMatrixPosition(Re.matrixWorld);
            const Pe = V.distanceTo(q),
                H = me.projectionMatrix.elements,
                ce = Re.projectionMatrix.elements,
                ae = H[14] / (H[10] - 1),
                le = H[14] / (H[10] + 1),
                Ce = (H[9] + 1) / H[5],
                I = (H[9] - 1) / H[5],
                w = (H[8] - 1) / H[0],
                E = (ce[8] + 1) / ce[0],
                N = ae * w,
                U = ae * E,
                W = Pe / (-w + E),
                Y = W * -w;
            me.matrixWorld.decompose(te.position, te.quaternion, te.scale), te.translateX(Y), te.translateZ(W), te.matrixWorld.compose(te.position, te.quaternion, te.scale), te.matrixWorldInverse.copy(te.matrixWorld).invert();
            const b = ae + W,
                M = le + W,
                D = N - Y,
                z = U + (Pe - Y),
                $ = Ce * le / M * b,
                K = I * le / M * b;
            te.projectionMatrix.makePerspective(D, z, $, K, b, M), te.projectionMatrixInverse.copy(te.projectionMatrix).invert()
        }

        function J(te, me) {
            me === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(me.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert()
        }
        this.updateCamera = function (te) {
            if (r === null) return;
            T.near = R.near = S.near = te.near, T.far = R.far = S.far = te.far, (A !== T.near || G !== T.far) && (r.updateRenderState({
                depthNear: T.near,
                depthFar: T.far
            }), A = T.near, G = T.far);
            const me = te.parent,
                Re = T.cameras;
            J(T, me);
            for (let Pe = 0; Pe < Re.length; Pe++) J(Re[Pe], me);
            Re.length === 2 ? j(T, S, R) : T.projectionMatrix.copy(S.projectionMatrix), ie(te, T, me)
        };

        function ie(te, me, Re) {
            Re === null ? te.matrix.copy(me.matrixWorld) : (te.matrix.copy(Re.matrixWorld), te.matrix.invert(), te.matrix.multiply(me.matrixWorld)), te.matrix.decompose(te.position, te.quaternion, te.scale), te.updateMatrixWorld(!0), te.projectionMatrix.copy(me.projectionMatrix), te.projectionMatrixInverse.copy(me.projectionMatrixInverse), te.isPerspectiveCamera && (te.fov = gs * 2 * Math.atan(1 / te.projectionMatrix.elements[5]), te.zoom = 1)
        }
        this.getCamera = function () {
            return T
        }, this.getFoveation = function () {
            if (!(f === null && d === null)) return l
        }, this.setFoveation = function (te) {
            l = te, f !== null && (f.fixedFoveation = te), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = te)
        };
        let pe = null;

        function de(te, me) {
            if (u = me.getViewerPose(c || o), p = me, u !== null) {
                const Re = u.views;
                d !== null && (e.setRenderTargetFramebuffer(m, d.framebuffer), e.setRenderTarget(m));
                let Pe = !1;
                Re.length !== T.cameras.length && (T.cameras.length = 0, Pe = !0);
                for (let H = 0; H < Re.length; H++) {
                    const ce = Re[H];
                    let ae = null;
                    if (d !== null) ae = d.getViewport(ce);
                    else {
                        const Ce = h.getViewSubImage(f, ce);
                        ae = Ce.viewport, H === 0 && (e.setRenderTargetTextures(m, Ce.colorTexture, f.ignoreDepthValues ? void 0 : Ce.depthStencilTexture), e.setRenderTarget(m))
                    }
                    let le = F[H];
                    le === void 0 && (le = new qt, le.layers.enable(H), le.viewport = new pt, F[H] = le), le.matrix.fromArray(ce.transform.matrix), le.matrix.decompose(le.position, le.quaternion, le.scale), le.projectionMatrix.fromArray(ce.projectionMatrix), le.projectionMatrixInverse.copy(le.projectionMatrix).invert(), le.viewport.set(ae.x, ae.y, ae.width, ae.height), H === 0 && (T.matrix.copy(le.matrix), T.matrix.decompose(T.position, T.quaternion, T.scale)), Pe === !0 && T.cameras.push(le)
                }
            }
            for (let Re = 0; Re < y.length; Re++) {
                const Pe = v[Re],
                    H = y[Re];
                Pe !== null && H !== void 0 && H.update(Pe, me, c || o)
            }
            pe && pe(te, me), me.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: me
            }), p = null
        }
        const xe = new Bg;
        xe.setAnimationLoop(de), this.setAnimationLoop = function (te) {
            pe = te
        }, this.dispose = function () {}
    }
}

function PE(n, e) {
    function t(g, m) {
        g.matrixAutoUpdate === !0 && g.updateMatrix(), m.value.copy(g.matrix)
    }

    function i(g, m) {
        m.color.getRGB(g.fogColor.value, Ug(n)), m.isFog ? (g.fogNear.value = m.near, g.fogFar.value = m.far) : m.isFogExp2 && (g.fogDensity.value = m.density)
    }

    function r(g, m, y, v, x) {
        m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(g, m) : m.isMeshToonMaterial ? (s(g, m), h(g, m)) : m.isMeshPhongMaterial ? (s(g, m), u(g, m)) : m.isMeshStandardMaterial ? (s(g, m), f(g, m), m.isMeshPhysicalMaterial && d(g, m, x)) : m.isMeshMatcapMaterial ? (s(g, m), p(g, m)) : m.isMeshDepthMaterial ? s(g, m) : m.isMeshDistanceMaterial ? (s(g, m), _(g, m)) : m.isMeshNormalMaterial ? s(g, m) : m.isLineBasicMaterial ? (o(g, m), m.isLineDashedMaterial && a(g, m)) : m.isPointsMaterial ? l(g, m, y, v) : m.isSpriteMaterial ? c(g, m) : m.isShadowMaterial ? (g.color.value.copy(m.color), g.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1)
    }

    function s(g, m) {
        g.opacity.value = m.opacity, m.color && g.diffuse.value.copy(m.color), m.emissive && g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.bumpMap && (g.bumpMap.value = m.bumpMap, t(m.bumpMap, g.bumpMapTransform), g.bumpScale.value = m.bumpScale, m.side === un && (g.bumpScale.value *= -1)), m.normalMap && (g.normalMap.value = m.normalMap, t(m.normalMap, g.normalMapTransform), g.normalScale.value.copy(m.normalScale), m.side === un && g.normalScale.value.negate()), m.displacementMap && (g.displacementMap.value = m.displacementMap, t(m.displacementMap, g.displacementMapTransform), g.displacementScale.value = m.displacementScale, g.displacementBias.value = m.displacementBias), m.emissiveMap && (g.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, g.emissiveMapTransform)), m.specularMap && (g.specularMap.value = m.specularMap, t(m.specularMap, g.specularMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
        const y = e.get(m).envMap;
        if (y && (g.envMap.value = y, g.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = m.reflectivity, g.ior.value = m.ior, g.refractionRatio.value = m.refractionRatio), m.lightMap) {
            g.lightMap.value = m.lightMap;
            const v = n._useLegacyLights === !0 ? Math.PI : 1;
            g.lightMapIntensity.value = m.lightMapIntensity * v, t(m.lightMap, g.lightMapTransform)
        }
        m.aoMap && (g.aoMap.value = m.aoMap, g.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, g.aoMapTransform))
    }

    function o(g, m) {
        g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, m.map && (g.map.value = m.map, t(m.map, g.mapTransform))
    }

    function a(g, m) {
        g.dashSize.value = m.dashSize, g.totalSize.value = m.dashSize + m.gapSize, g.scale.value = m.scale
    }

    function l(g, m, y, v) {
        g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.size.value = m.size * y, g.scale.value = v * .5, m.map && (g.map.value = m.map, t(m.map, g.uvTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest)
    }

    function c(g, m) {
        g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.rotation.value = m.rotation, m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest)
    }

    function u(g, m) {
        g.specular.value.copy(m.specular), g.shininess.value = Math.max(m.shininess, 1e-4)
    }

    function h(g, m) {
        m.gradientMap && (g.gradientMap.value = m.gradientMap)
    }

    function f(g, m) {
        g.metalness.value = m.metalness, m.metalnessMap && (g.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, g.metalnessMapTransform)), g.roughness.value = m.roughness, m.roughnessMap && (g.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, g.roughnessMapTransform)), e.get(m).envMap && (g.envMapIntensity.value = m.envMapIntensity)
    }

    function d(g, m, y) {
        g.ior.value = m.ior, m.sheen > 0 && (g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), g.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (g.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, g.sheenColorMapTransform)), m.sheenRoughnessMap && (g.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, g.sheenRoughnessMapTransform))), m.clearcoat > 0 && (g.clearcoat.value = m.clearcoat, g.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (g.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, g.clearcoatMapTransform)), m.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (g.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === un && g.clearcoatNormalScale.value.negate())), m.iridescence > 0 && (g.iridescence.value = m.iridescence, g.iridescenceIOR.value = m.iridescenceIOR, g.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (g.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, g.iridescenceMapTransform)), m.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), m.transmission > 0 && (g.transmission.value = m.transmission, g.transmissionSamplerMap.value = y.texture, g.transmissionSamplerSize.value.set(y.width, y.height), m.transmissionMap && (g.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, g.transmissionMapTransform)), g.thickness.value = m.thickness, m.thicknessMap && (g.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = m.attenuationDistance, g.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (g.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (g.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = m.specularIntensity, g.specularColor.value.copy(m.specularColor), m.specularColorMap && (g.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, g.specularColorMapTransform)), m.specularIntensityMap && (g.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, g.specularIntensityMapTransform))
    }

    function p(g, m) {
        m.matcap && (g.matcap.value = m.matcap)
    }

    function _(g, m) {
        const y = e.get(m).light;
        g.referencePosition.value.setFromMatrixPosition(y.matrixWorld), g.nearDistance.value = y.shadow.camera.near, g.farDistance.value = y.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}

function LE(n, e, t, i) {
    let r = {},
        s = {},
        o = [];
    const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

    function l(y, v) {
        const x = v.program;
        i.uniformBlockBinding(y, x)
    }

    function c(y, v) {
        let x = r[y.id];
        x === void 0 && (p(y), x = u(y), r[y.id] = x, y.addEventListener("dispose", g));
        const C = v.program;
        i.updateUBOMapping(y, C);
        const S = e.render.frame;
        s[y.id] !== S && (f(y), s[y.id] = S)
    }

    function u(y) {
        const v = h();
        y.__bindingPointIndex = v;
        const x = n.createBuffer(),
            C = y.__size,
            S = y.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, x), n.bufferData(n.UNIFORM_BUFFER, C, S), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, v, x), x
    }

    function h() {
        for (let y = 0; y < a; y++)
            if (o.indexOf(y) === -1) return o.push(y), y;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function f(y) {
        const v = r[y.id],
            x = y.uniforms,
            C = y.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, v);
        for (let S = 0, R = x.length; S < R; S++) {
            const F = Array.isArray(x[S]) ? x[S] : [x[S]];
            for (let T = 0, A = F.length; T < A; T++) {
                const G = F[T];
                if (d(G, S, T, C) === !0) {
                    const ee = G.__offset,
                        he = Array.isArray(G.value) ? G.value : [G.value];
                    let B = 0;
                    for (let V = 0; V < he.length; V++) {
                        const q = he[V],
                            j = _(q);
                        typeof q == "number" || typeof q == "boolean" ? (G.__data[0] = q, n.bufferSubData(n.UNIFORM_BUFFER, ee + B, G.__data)) : q.isMatrix3 ? (G.__data[0] = q.elements[0], G.__data[1] = q.elements[1], G.__data[2] = q.elements[2], G.__data[3] = 0, G.__data[4] = q.elements[3], G.__data[5] = q.elements[4], G.__data[6] = q.elements[5], G.__data[7] = 0, G.__data[8] = q.elements[6], G.__data[9] = q.elements[7], G.__data[10] = q.elements[8], G.__data[11] = 0) : (q.toArray(G.__data, B), B += j.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, ee, G.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }

    function d(y, v, x, C) {
        const S = y.value,
            R = v + "_" + x;
        if (C[R] === void 0) return typeof S == "number" || typeof S == "boolean" ? C[R] = S : C[R] = S.clone(), !0; {
            const F = C[R];
            if (typeof S == "number" || typeof S == "boolean") {
                if (F !== S) return C[R] = S, !0
            } else if (F.equals(S) === !1) return F.copy(S), !0
        }
        return !1
    }

    function p(y) {
        const v = y.uniforms;
        let x = 0;
        const C = 16;
        for (let R = 0, F = v.length; R < F; R++) {
            const T = Array.isArray(v[R]) ? v[R] : [v[R]];
            for (let A = 0, G = T.length; A < G; A++) {
                const ee = T[A],
                    he = Array.isArray(ee.value) ? ee.value : [ee.value];
                for (let B = 0, V = he.length; B < V; B++) {
                    const q = he[B],
                        j = _(q),
                        J = x % C;
                    J !== 0 && C - J < j.boundary && (x += C - J), ee.__data = new Float32Array(j.storage / Float32Array.BYTES_PER_ELEMENT), ee.__offset = x, x += j.storage
                }
            }
        }
        const S = x % C;
        return S > 0 && (x += C - S), y.__size = x, y.__cache = {}, this
    }

    function _(y) {
        const v = {
            boundary: 0,
            storage: 0
        };
        return typeof y == "number" || typeof y == "boolean" ? (v.boundary = 4, v.storage = 4) : y.isVector2 ? (v.boundary = 8, v.storage = 8) : y.isVector3 || y.isColor ? (v.boundary = 16, v.storage = 12) : y.isVector4 ? (v.boundary = 16, v.storage = 16) : y.isMatrix3 ? (v.boundary = 48, v.storage = 48) : y.isMatrix4 ? (v.boundary = 64, v.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), v
    }

    function g(y) {
        const v = y.target;
        v.removeEventListener("dispose", g);
        const x = o.indexOf(v.__bindingPointIndex);
        o.splice(x, 1), n.deleteBuffer(r[v.id]), delete r[v.id], delete s[v.id]
    }

    function m() {
        for (const y in r) n.deleteBuffer(r[y]);
        o = [], r = {}, s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: m
    }
}
class th {
    constructor(e = {}) {
        const {
            canvas: t = CM(),
            context: i = null,
            depth: r = !0,
            stencil: s = !0,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: u = "default",
            failIfMajorPerformanceCaveat: h = !1
        } = e;
        this.isWebGLRenderer = !0;
        let f;
        i !== null ? f = i.getContextAttributes().alpha : f = o;
        const d = new Uint32Array(4),
            p = new Int32Array(4);
        let _ = null,
            g = null;
        const m = [],
            y = [];
        this.domElement = t, this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Pt, this._useLegacyLights = !1, this.toneMapping = Ni, this.toneMappingExposure = 1;
        const v = this;
        let x = !1,
            C = 0,
            S = 0,
            R = null,
            F = -1,
            T = null;
        const A = new pt,
            G = new pt;
        let ee = null;
        const he = new Fe(0);
        let B = 0,
            V = t.width,
            q = t.height,
            j = 1,
            J = null,
            ie = null;
        const pe = new pt(0, 0, V, q),
            de = new pt(0, 0, V, q);
        let xe = !1;
        const te = new wl;
        let me = !1,
            Re = !1,
            Pe = null;
        const H = new qe,
            ce = new ue,
            ae = new L,
            le = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };

        function Ce() {
            return R === null ? j : 1
        }
        let I = i;

        function w(P, X) {
            for (let Q = 0; Q < P.length; Q++) {
                const ne = P[Q],
                    Z = t.getContext(ne, X);
                if (Z !== null) return Z
            }
            return null
        }
        try {
            const P = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${$u}`), t.addEventListener("webglcontextlost", we, !1), t.addEventListener("webglcontextrestored", k, !1), t.addEventListener("webglcontextcreationerror", Se, !1), I === null) {
                const X = ["webgl2", "webgl", "experimental-webgl"];
                if (v.isWebGL1Renderer === !0 && X.shift(), I = w(X, P), I === null) throw w(X) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && I instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), I.getShaderPrecisionFormat === void 0 && (I.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (P) {
            throw console.error("THREE.WebGLRenderer: " + P.message), P
        }
        let E, N, U, W, Y, b, M, D, z, $, K, fe, se, ge, Ee, De, oe, Be, O, _e, Me, ye, Le, ze;

        function et() {
            E = new HT(I), N = new FT(I, E, e), E.init(N), ye = new EE(I, E, N), U = new TE(I, E, N), W = new XT(I), Y = new fE, b = new wE(I, E, U, Y, N, ye, W), M = new kT(v), D = new VT(v), z = new eb(I, N), Le = new NT(I, E, z, N), $ = new WT(I, z, W, Le), K = new jT(I, $, z, W), O = new KT(I, N, b), De = new BT(Y), fe = new hE(v, M, D, E, N, Le, De), se = new PE(v, Y), ge = new pE, Ee = new xE(E, N), Be = new OT(v, M, D, U, K, f, l), oe = new SE(v, K, N), ze = new LE(I, W, N, U), _e = new UT(I, E, W, N), Me = new $T(I, E, W, N), W.programs = fe.programs, v.capabilities = N, v.extensions = E, v.properties = Y, v.renderLists = ge, v.shadowMap = oe, v.state = U, v.info = W
        }
        et();
        const Je = new CE(v, I);
        this.xr = Je, this.getContext = function () {
            return I
        }, this.getContextAttributes = function () {
            return I.getContextAttributes()
        }, this.forceContextLoss = function () {
            const P = E.get("WEBGL_lose_context");
            P && P.loseContext()
        }, this.forceContextRestore = function () {
            const P = E.get("WEBGL_lose_context");
            P && P.restoreContext()
        }, this.getPixelRatio = function () {
            return j
        }, this.setPixelRatio = function (P) {
            P !== void 0 && (j = P, this.setSize(V, q, !1))
        }, this.getSize = function (P) {
            return P.set(V, q)
        }, this.setSize = function (P, X, Q = !0) {
            if (Je.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            V = P, q = X, t.width = Math.floor(P * j), t.height = Math.floor(X * j), Q === !0 && (t.style.width = P + "px", t.style.height = X + "px"), this.setViewport(0, 0, P, X)
        }, this.getDrawingBufferSize = function (P) {
            return P.set(V * j, q * j).floor()
        }, this.setDrawingBufferSize = function (P, X, Q) {
            V = P, q = X, j = Q, t.width = Math.floor(P * Q), t.height = Math.floor(X * Q), this.setViewport(0, 0, P, X)
        }, this.getCurrentViewport = function (P) {
            return P.copy(A)
        }, this.getViewport = function (P) {
            return P.copy(pe)
        }, this.setViewport = function (P, X, Q, ne) {
            P.isVector4 ? pe.set(P.x, P.y, P.z, P.w) : pe.set(P, X, Q, ne), U.viewport(A.copy(pe).multiplyScalar(j).floor())
        }, this.getScissor = function (P) {
            return P.copy(de)
        }, this.setScissor = function (P, X, Q, ne) {
            P.isVector4 ? de.set(P.x, P.y, P.z, P.w) : de.set(P, X, Q, ne), U.scissor(G.copy(de).multiplyScalar(j).floor())
        }, this.getScissorTest = function () {
            return xe
        }, this.setScissorTest = function (P) {
            U.setScissorTest(xe = P)
        }, this.setOpaqueSort = function (P) {
            J = P
        }, this.setTransparentSort = function (P) {
            ie = P
        }, this.getClearColor = function (P) {
            return P.copy(Be.getClearColor())
        }, this.setClearColor = function () {
            Be.setClearColor.apply(Be, arguments)
        }, this.getClearAlpha = function () {
            return Be.getClearAlpha()
        }, this.setClearAlpha = function () {
            Be.setClearAlpha.apply(Be, arguments)
        }, this.clear = function (P = !0, X = !0, Q = !0) {
            let ne = 0;
            if (P) {
                let Z = !1;
                if (R !== null) {
                    const Oe = R.texture.format;
                    Z = Oe === wg || Oe === Tg || Oe === Sg
                }
                if (Z) {
                    const Oe = R.texture.type,
                        Ue = Oe === Ui || Oe === Pi || Oe === Yu || Oe === lr || Oe === Mg || Oe === bg,
                        Ve = Be.getClearColor(),
                        We = Be.getClearAlpha(),
                        Ze = Ve.r,
                        Ye = Ve.g,
                        Ke = Ve.b;
                    Ue ? (d[0] = Ze, d[1] = Ye, d[2] = Ke, d[3] = We, I.clearBufferuiv(I.COLOR, 0, d)) : (p[0] = Ze, p[1] = Ye, p[2] = Ke, p[3] = We, I.clearBufferiv(I.COLOR, 0, p))
                } else ne |= I.COLOR_BUFFER_BIT
            }
            X && (ne |= I.DEPTH_BUFFER_BIT), Q && (ne |= I.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), I.clear(ne)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            t.removeEventListener("webglcontextlost", we, !1), t.removeEventListener("webglcontextrestored", k, !1), t.removeEventListener("webglcontextcreationerror", Se, !1), ge.dispose(), Ee.dispose(), Y.dispose(), M.dispose(), D.dispose(), K.dispose(), Le.dispose(), ze.dispose(), fe.dispose(), Je.dispose(), Je.removeEventListener("sessionstart", en), Je.removeEventListener("sessionend", gt), Pe && (Pe.dispose(), Pe = null), tn.stop()
        };

        function we(P) {
            P.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
        }

        function k() {
            console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
            const P = W.autoReset,
                X = oe.enabled,
                Q = oe.autoUpdate,
                ne = oe.needsUpdate,
                Z = oe.type;
            et(), W.autoReset = P, oe.enabled = X, oe.autoUpdate = Q, oe.needsUpdate = ne, oe.type = Z
        }

        function Se(P) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", P.statusMessage)
        }

        function Te(P) {
            const X = P.target;
            X.removeEventListener("dispose", Te), ke(X)
        }

        function ke(P) {
            Ne(P), Y.remove(P)
        }

        function Ne(P) {
            const X = Y.get(P).programs;
            X !== void 0 && (X.forEach(function (Q) {
                fe.releaseProgram(Q)
            }), P.isShaderMaterial && fe.releaseShaderCache(P))
        }
        this.renderBufferDirect = function (P, X, Q, ne, Z, Oe) {
            X === null && (X = le);
            const Ue = Z.isMesh && Z.matrixWorld.determinant() < 0,
                Ve = O_(P, X, Q, ne, Z);
            U.setMaterial(ne, Ue);
            let We = Q.index,
                Ze = 1;
            if (ne.wireframe === !0) {
                if (We = $.getWireframeAttribute(Q), We === void 0) return;
                Ze = 2
            }
            const Ye = Q.drawRange,
                Ke = Q.attributes.position;
            let At = Ye.start * Ze,
                dn = (Ye.start + Ye.count) * Ze;
            Oe !== null && (At = Math.max(At, Oe.start * Ze), dn = Math.min(dn, (Oe.start + Oe.count) * Ze)), We !== null ? (At = Math.max(At, 0), dn = Math.min(dn, We.count)) : Ke != null && (At = Math.max(At, 0), dn = Math.min(dn, Ke.count));
            const Ft = dn - At;
            if (Ft < 0 || Ft === 1 / 0) return;
            Le.setup(Z, ne, Ve, Q, We);
            let ni, St = _e;
            if (We !== null && (ni = z.get(We), St = Me, St.setIndex(ni)), Z.isMesh) ne.wireframe === !0 ? (U.setLineWidth(ne.wireframeLinewidth * Ce()), St.setMode(I.LINES)) : St.setMode(I.TRIANGLES);
            else if (Z.isLine) {
                let tt = ne.linewidth;
                tt === void 0 && (tt = 1), U.setLineWidth(tt * Ce()), Z.isLineSegments ? St.setMode(I.LINES) : Z.isLineLoop ? St.setMode(I.LINE_LOOP) : St.setMode(I.LINE_STRIP)
            } else Z.isPoints ? St.setMode(I.POINTS) : Z.isSprite && St.setMode(I.TRIANGLES);
            if (Z.isBatchedMesh) St.renderMultiDraw(Z._multiDrawStarts, Z._multiDrawCounts, Z._multiDrawCount);
            else if (Z.isInstancedMesh) St.renderInstances(At, Ft, Z.count);
            else if (Q.isInstancedBufferGeometry) {
                const tt = Q._maxInstanceCount !== void 0 ? Q._maxInstanceCount : 1 / 0,
                    Bl = Math.min(Q.instanceCount, tt);
                St.renderInstances(At, Ft, Bl)
            } else St.render(At, Ft)
        };

        function st(P, X, Q) {
            P.transparent === !0 && P.side === En && P.forceSinglePass === !1 ? (P.side = un, P.needsUpdate = !0, Io(P, X, Q), P.side = zi, P.needsUpdate = !0, Io(P, X, Q), P.side = En) : Io(P, X, Q)
        }
        this.compile = function (P, X, Q = null) {
            Q === null && (Q = P), g = Ee.get(Q), g.init(), y.push(g), Q.traverseVisible(function (Z) {
                Z.isLight && Z.layers.test(X.layers) && (g.pushLight(Z), Z.castShadow && g.pushShadow(Z))
            }), P !== Q && P.traverseVisible(function (Z) {
                Z.isLight && Z.layers.test(X.layers) && (g.pushLight(Z), Z.castShadow && g.pushShadow(Z))
            }), g.setupLights(v._useLegacyLights);
            const ne = new Set;
            return P.traverse(function (Z) {
                const Oe = Z.material;
                if (Oe)
                    if (Array.isArray(Oe))
                        for (let Ue = 0; Ue < Oe.length; Ue++) {
                            const Ve = Oe[Ue];
                            st(Ve, Q, Z), ne.add(Ve)
                        } else st(Oe, Q, Z), ne.add(Oe)
            }), y.pop(), g = null, ne
        }, this.compileAsync = function (P, X, Q = null) {
            const ne = this.compile(P, X, Q);
            return new Promise(Z => {
                function Oe() {
                    if (ne.forEach(function (Ue) {
                            Y.get(Ue).currentProgram.isReady() && ne.delete(Ue)
                        }), ne.size === 0) {
                        Z(P);
                        return
                    }
                    setTimeout(Oe, 10)
                }
                E.get("KHR_parallel_shader_compile") !== null ? Oe() : setTimeout(Oe, 10)
            })
        };
        let at = null;

        function Ut(P) {
            at && at(P)
        }

        function en() {
            tn.stop()
        }

        function gt() {
            tn.start()
        }
        const tn = new Bg;
        tn.setAnimationLoop(Ut), typeof self < "u" && tn.setContext(self), this.setAnimationLoop = function (P) {
            at = P, Je.setAnimationLoop(P), P === null ? tn.stop() : tn.start()
        }, Je.addEventListener("sessionstart", en), Je.addEventListener("sessionend", gt), this.render = function (P, X) {
            if (X !== void 0 && X.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (x === !0) return;
            P.matrixWorldAutoUpdate === !0 && P.updateMatrixWorld(), X.parent === null && X.matrixWorldAutoUpdate === !0 && X.updateMatrixWorld(), Je.enabled === !0 && Je.isPresenting === !0 && (Je.cameraAutoUpdate === !0 && Je.updateCamera(X), X = Je.getCamera()), P.isScene === !0 && P.onBeforeRender(v, P, X, R), g = Ee.get(P, y.length), g.init(), y.push(g), H.multiplyMatrices(X.projectionMatrix, X.matrixWorldInverse), te.setFromProjectionMatrix(H), Re = this.localClippingEnabled, me = De.init(this.clippingPlanes, Re), _ = ge.get(P, m.length), _.init(), m.push(_), zn(P, X, 0, v.sortObjects), _.finish(), v.sortObjects === !0 && _.sort(J, ie), this.info.render.frame++, me === !0 && De.beginShadows();
            const Q = g.state.shadowsArray;
            if (oe.render(Q, P, X), me === !0 && De.endShadows(), this.info.autoReset === !0 && this.info.reset(), Be.render(_, P), g.setupLights(v._useLegacyLights), X.isArrayCamera) {
                const ne = X.cameras;
                for (let Z = 0, Oe = ne.length; Z < Oe; Z++) {
                    const Ue = ne[Z];
                    Fh(_, P, Ue, Ue.viewport)
                }
            } else Fh(_, P, X);
            R !== null && (b.updateMultisampleRenderTarget(R), b.updateRenderTargetMipmap(R)), P.isScene === !0 && P.onAfterRender(v, P, X), Le.resetDefaultState(), F = -1, T = null, y.pop(), y.length > 0 ? g = y[y.length - 1] : g = null, m.pop(), m.length > 0 ? _ = m[m.length - 1] : _ = null
        };

        function zn(P, X, Q, ne) {
            if (P.visible === !1) return;
            if (P.layers.test(X.layers)) {
                if (P.isGroup) Q = P.renderOrder;
                else if (P.isLOD) P.autoUpdate === !0 && P.update(X);
                else if (P.isLight) g.pushLight(P), P.castShadow && g.pushShadow(P);
                else if (P.isSprite) {
                    if (!P.frustumCulled || te.intersectsSprite(P)) {
                        ne && ae.setFromMatrixPosition(P.matrixWorld).applyMatrix4(H);
                        const Ue = K.update(P),
                            Ve = P.material;
                        Ve.visible && _.push(P, Ue, Ve, Q, ae.z, null)
                    }
                } else if ((P.isMesh || P.isLine || P.isPoints) && (!P.frustumCulled || te.intersectsObject(P))) {
                    const Ue = K.update(P),
                        Ve = P.material;
                    if (ne && (P.boundingSphere !== void 0 ? (P.boundingSphere === null && P.computeBoundingSphere(), ae.copy(P.boundingSphere.center)) : (Ue.boundingSphere === null && Ue.computeBoundingSphere(), ae.copy(Ue.boundingSphere.center)), ae.applyMatrix4(P.matrixWorld).applyMatrix4(H)), Array.isArray(Ve)) {
                        const We = Ue.groups;
                        for (let Ze = 0, Ye = We.length; Ze < Ye; Ze++) {
                            const Ke = We[Ze],
                                At = Ve[Ke.materialIndex];
                            At && At.visible && _.push(P, Ue, At, Q, ae.z, Ke)
                        }
                    } else Ve.visible && _.push(P, Ue, Ve, Q, ae.z, null)
                }
            }
            const Oe = P.children;
            for (let Ue = 0, Ve = Oe.length; Ue < Ve; Ue++) zn(Oe[Ue], X, Q, ne)
        }

        function Fh(P, X, Q, ne) {
            const Z = P.opaque,
                Oe = P.transmissive,
                Ue = P.transparent;
            g.setupLightsView(Q), me === !0 && De.setGlobalState(v.clippingPlanes, Q), Oe.length > 0 && D_(Z, Oe, X, Q), ne && U.viewport(A.copy(ne)), Z.length > 0 && Lo(Z, X, Q), Oe.length > 0 && Lo(Oe, X, Q), Ue.length > 0 && Lo(Ue, X, Q), U.buffers.depth.setTest(!0), U.buffers.depth.setMask(!0), U.buffers.color.setMask(!0), U.setPolygonOffset(!1)
        }

        function D_(P, X, Q, ne) {
            if ((Q.isScene === !0 ? Q.overrideMaterial : null) !== null) return;
            const Oe = N.isWebGL2;
            Pe === null && (Pe = new pr(1, 1, {
                generateMipmaps: !0,
                type: E.has("EXT_color_buffer_half_float") ? ho : Ui,
                minFilter: dr,
                samples: Oe ? 4 : 0
            })), v.getDrawingBufferSize(ce), Oe ? Pe.setSize(ce.x, ce.y) : Pe.setSize(el(ce.x), el(ce.y));
            const Ue = v.getRenderTarget();
            v.setRenderTarget(Pe), v.getClearColor(he), B = v.getClearAlpha(), B < 1 && v.setClearColor(16777215, .5), v.clear();
            const Ve = v.toneMapping;
            v.toneMapping = Ni, Lo(P, Q, ne), b.updateMultisampleRenderTarget(Pe), b.updateRenderTargetMipmap(Pe);
            let We = !1;
            for (let Ze = 0, Ye = X.length; Ze < Ye; Ze++) {
                const Ke = X[Ze],
                    At = Ke.object,
                    dn = Ke.geometry,
                    Ft = Ke.material,
                    ni = Ke.group;
                if (Ft.side === En && At.layers.test(ne.layers)) {
                    const St = Ft.side;
                    Ft.side = un, Ft.needsUpdate = !0, Bh(At, Q, ne, dn, Ft, ni), Ft.side = St, Ft.needsUpdate = !0, We = !0
                }
            }
            We === !0 && (b.updateMultisampleRenderTarget(Pe), b.updateRenderTargetMipmap(Pe)), v.setRenderTarget(Ue), v.setClearColor(he, B), v.toneMapping = Ve
        }

        function Lo(P, X, Q) {
            const ne = X.isScene === !0 ? X.overrideMaterial : null;
            for (let Z = 0, Oe = P.length; Z < Oe; Z++) {
                const Ue = P[Z],
                    Ve = Ue.object,
                    We = Ue.geometry,
                    Ze = ne === null ? Ue.material : ne,
                    Ye = Ue.group;
                Ve.layers.test(Q.layers) && Bh(Ve, X, Q, We, Ze, Ye)
            }
        }

        function Bh(P, X, Q, ne, Z, Oe) {
            P.onBeforeRender(v, X, Q, ne, Z, Oe), P.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse, P.matrixWorld), P.normalMatrix.getNormalMatrix(P.modelViewMatrix), Z.onBeforeRender(v, X, Q, ne, P, Oe), Z.transparent === !0 && Z.side === En && Z.forceSinglePass === !1 ? (Z.side = un, Z.needsUpdate = !0, v.renderBufferDirect(Q, X, ne, Z, P, Oe), Z.side = zi, Z.needsUpdate = !0, v.renderBufferDirect(Q, X, ne, Z, P, Oe), Z.side = En) : v.renderBufferDirect(Q, X, ne, Z, P, Oe), P.onAfterRender(v, X, Q, ne, Z, Oe)
        }

        function Io(P, X, Q) {
            X.isScene !== !0 && (X = le);
            const ne = Y.get(P),
                Z = g.state.lights,
                Oe = g.state.shadowsArray,
                Ue = Z.state.version,
                Ve = fe.getParameters(P, Z.state, Oe, X, Q),
                We = fe.getProgramCacheKey(Ve);
            let Ze = ne.programs;
            ne.environment = P.isMeshStandardMaterial ? X.environment : null, ne.fog = X.fog, ne.envMap = (P.isMeshStandardMaterial ? D : M).get(P.envMap || ne.environment), Ze === void 0 && (P.addEventListener("dispose", Te), Ze = new Map, ne.programs = Ze);
            let Ye = Ze.get(We);
            if (Ye !== void 0) {
                if (ne.currentProgram === Ye && ne.lightsStateVersion === Ue) return zh(P, Ve), Ye
            } else Ve.uniforms = fe.getUniforms(P), P.onBuild(Q, Ve, v), P.onBeforeCompile(Ve, v), Ye = fe.acquireProgram(Ve, We), Ze.set(We, Ye), ne.uniforms = Ve.uniforms;
            const Ke = ne.uniforms;
            return (!P.isShaderMaterial && !P.isRawShaderMaterial || P.clipping === !0) && (Ke.clippingPlanes = De.uniform), zh(P, Ve), ne.needsLights = U_(P), ne.lightsStateVersion = Ue, ne.needsLights && (Ke.ambientLightColor.value = Z.state.ambient, Ke.lightProbe.value = Z.state.probe, Ke.directionalLights.value = Z.state.directional, Ke.directionalLightShadows.value = Z.state.directionalShadow, Ke.spotLights.value = Z.state.spot, Ke.spotLightShadows.value = Z.state.spotShadow, Ke.rectAreaLights.value = Z.state.rectArea, Ke.ltc_1.value = Z.state.rectAreaLTC1, Ke.ltc_2.value = Z.state.rectAreaLTC2, Ke.pointLights.value = Z.state.point, Ke.pointLightShadows.value = Z.state.pointShadow, Ke.hemisphereLights.value = Z.state.hemi, Ke.directionalShadowMap.value = Z.state.directionalShadowMap, Ke.directionalShadowMatrix.value = Z.state.directionalShadowMatrix, Ke.spotShadowMap.value = Z.state.spotShadowMap, Ke.spotLightMatrix.value = Z.state.spotLightMatrix, Ke.spotLightMap.value = Z.state.spotLightMap, Ke.pointShadowMap.value = Z.state.pointShadowMap, Ke.pointShadowMatrix.value = Z.state.pointShadowMatrix), ne.currentProgram = Ye, ne.uniformsList = null, Ye
        }

        function kh(P) {
            if (P.uniformsList === null) {
                const X = P.currentProgram.getUniforms();
                P.uniformsList = Na.seqWithValue(X.seq, P.uniforms)
            }
            return P.uniformsList
        }

        function zh(P, X) {
            const Q = Y.get(P);
            Q.outputColorSpace = X.outputColorSpace, Q.batching = X.batching, Q.instancing = X.instancing, Q.instancingColor = X.instancingColor, Q.skinning = X.skinning, Q.morphTargets = X.morphTargets, Q.morphNormals = X.morphNormals, Q.morphColors = X.morphColors, Q.morphTargetsCount = X.morphTargetsCount, Q.numClippingPlanes = X.numClippingPlanes, Q.numIntersection = X.numClipIntersection, Q.vertexAlphas = X.vertexAlphas, Q.vertexTangents = X.vertexTangents, Q.toneMapping = X.toneMapping
        }

        function O_(P, X, Q, ne, Z) {
            X.isScene !== !0 && (X = le), b.resetTextureUnits();
            const Oe = X.fog,
                Ue = ne.isMeshStandardMaterial ? X.environment : null,
                Ve = R === null ? v.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : mi,
                We = (ne.isMeshStandardMaterial ? D : M).get(ne.envMap || Ue),
                Ze = ne.vertexColors === !0 && !!Q.attributes.color && Q.attributes.color.itemSize === 4,
                Ye = !!Q.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0),
                Ke = !!Q.morphAttributes.position,
                At = !!Q.morphAttributes.normal,
                dn = !!Q.morphAttributes.color;
            let Ft = Ni;
            ne.toneMapped && (R === null || R.isXRRenderTarget === !0) && (Ft = v.toneMapping);
            const ni = Q.morphAttributes.position || Q.morphAttributes.normal || Q.morphAttributes.color,
                St = ni !== void 0 ? ni.length : 0,
                tt = Y.get(ne),
                Bl = g.state.lights;
            if (me === !0 && (Re === !0 || P !== T)) {
                const Sn = P === T && ne.id === F;
                De.setState(ne, P, Sn)
            }
            let wt = !1;
            ne.version === tt.__version ? (tt.needsLights && tt.lightsStateVersion !== Bl.state.version || tt.outputColorSpace !== Ve || Z.isBatchedMesh && tt.batching === !1 || !Z.isBatchedMesh && tt.batching === !0 || Z.isInstancedMesh && tt.instancing === !1 || !Z.isInstancedMesh && tt.instancing === !0 || Z.isSkinnedMesh && tt.skinning === !1 || !Z.isSkinnedMesh && tt.skinning === !0 || Z.isInstancedMesh && tt.instancingColor === !0 && Z.instanceColor === null || Z.isInstancedMesh && tt.instancingColor === !1 && Z.instanceColor !== null || tt.envMap !== We || ne.fog === !0 && tt.fog !== Oe || tt.numClippingPlanes !== void 0 && (tt.numClippingPlanes !== De.numPlanes || tt.numIntersection !== De.numIntersection) || tt.vertexAlphas !== Ze || tt.vertexTangents !== Ye || tt.morphTargets !== Ke || tt.morphNormals !== At || tt.morphColors !== dn || tt.toneMapping !== Ft || N.isWebGL2 === !0 && tt.morphTargetsCount !== St) && (wt = !0) : (wt = !0, tt.__version = ne.version);
            let Vi = tt.currentProgram;
            wt === !0 && (Vi = Io(ne, X, Z));
            let Gh = !1,
                As = !1,
                kl = !1;
            const Ht = Vi.getUniforms(),
                Hi = tt.uniforms;
            if (U.useProgram(Vi.program) && (Gh = !0, As = !0, kl = !0), ne.id !== F && (F = ne.id, As = !0), Gh || T !== P) {
                Ht.setValue(I, "projectionMatrix", P.projectionMatrix), Ht.setValue(I, "viewMatrix", P.matrixWorldInverse);
                const Sn = Ht.map.cameraPosition;
                Sn !== void 0 && Sn.setValue(I, ae.setFromMatrixPosition(P.matrixWorld)), N.logarithmicDepthBuffer && Ht.setValue(I, "logDepthBufFC", 2 / (Math.log(P.far + 1) / Math.LN2)), (ne.isMeshPhongMaterial || ne.isMeshToonMaterial || ne.isMeshLambertMaterial || ne.isMeshBasicMaterial || ne.isMeshStandardMaterial || ne.isShaderMaterial) && Ht.setValue(I, "isOrthographic", P.isOrthographicCamera === !0), T !== P && (T = P, As = !0, kl = !0)
            }
            if (Z.isSkinnedMesh) {
                Ht.setOptional(I, Z, "bindMatrix"), Ht.setOptional(I, Z, "bindMatrixInverse");
                const Sn = Z.skeleton;
                Sn && (N.floatVertexTextures ? (Sn.boneTexture === null && Sn.computeBoneTexture(), Ht.setValue(I, "boneTexture", Sn.boneTexture, b)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            Z.isBatchedMesh && (Ht.setOptional(I, Z, "batchingTexture"), Ht.setValue(I, "batchingTexture", Z._matricesTexture, b));
            const zl = Q.morphAttributes;
            if ((zl.position !== void 0 || zl.normal !== void 0 || zl.color !== void 0 && N.isWebGL2 === !0) && O.update(Z, Q, Vi), (As || tt.receiveShadow !== Z.receiveShadow) && (tt.receiveShadow = Z.receiveShadow, Ht.setValue(I, "receiveShadow", Z.receiveShadow)), ne.isMeshGouraudMaterial && ne.envMap !== null && (Hi.envMap.value = We, Hi.flipEnvMap.value = We.isCubeTexture && We.isRenderTargetTexture === !1 ? -1 : 1), As && (Ht.setValue(I, "toneMappingExposure", v.toneMappingExposure), tt.needsLights && N_(Hi, kl), Oe && ne.fog === !0 && se.refreshFogUniforms(Hi, Oe), se.refreshMaterialUniforms(Hi, ne, j, q, Pe), Na.upload(I, kh(tt), Hi, b)), ne.isShaderMaterial && ne.uniformsNeedUpdate === !0 && (Na.upload(I, kh(tt), Hi, b), ne.uniformsNeedUpdate = !1), ne.isSpriteMaterial && Ht.setValue(I, "center", Z.center), Ht.setValue(I, "modelViewMatrix", Z.modelViewMatrix), Ht.setValue(I, "normalMatrix", Z.normalMatrix), Ht.setValue(I, "modelMatrix", Z.matrixWorld), ne.isShaderMaterial || ne.isRawShaderMaterial) {
                const Sn = ne.uniformsGroups;
                for (let Gl = 0, F_ = Sn.length; Gl < F_; Gl++)
                    if (N.isWebGL2) {
                        const Vh = Sn[Gl];
                        ze.update(Vh, Vi), ze.bind(Vh, Vi)
                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return Vi
        }

        function N_(P, X) {
            P.ambientLightColor.needsUpdate = X, P.lightProbe.needsUpdate = X, P.directionalLights.needsUpdate = X, P.directionalLightShadows.needsUpdate = X, P.pointLights.needsUpdate = X, P.pointLightShadows.needsUpdate = X, P.spotLights.needsUpdate = X, P.spotLightShadows.needsUpdate = X, P.rectAreaLights.needsUpdate = X, P.hemisphereLights.needsUpdate = X
        }

        function U_(P) {
            return P.isMeshLambertMaterial || P.isMeshToonMaterial || P.isMeshPhongMaterial || P.isMeshStandardMaterial || P.isShadowMaterial || P.isShaderMaterial && P.lights === !0
        }
        this.getActiveCubeFace = function () {
            return C
        }, this.getActiveMipmapLevel = function () {
            return S
        }, this.getRenderTarget = function () {
            return R
        }, this.setRenderTargetTextures = function (P, X, Q) {
            Y.get(P.texture).__webglTexture = X, Y.get(P.depthTexture).__webglTexture = Q;
            const ne = Y.get(P);
            ne.__hasExternalTextures = !0, ne.__hasExternalTextures && (ne.__autoAllocateDepthBuffer = Q === void 0, ne.__autoAllocateDepthBuffer || E.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ne.__useRenderToTexture = !1))
        }, this.setRenderTargetFramebuffer = function (P, X) {
            const Q = Y.get(P);
            Q.__webglFramebuffer = X, Q.__useDefaultFramebuffer = X === void 0
        }, this.setRenderTarget = function (P, X = 0, Q = 0) {
            R = P, C = X, S = Q;
            let ne = !0,
                Z = null,
                Oe = !1,
                Ue = !1;
            if (P) {
                const We = Y.get(P);
                We.__useDefaultFramebuffer !== void 0 ? (U.bindFramebuffer(I.FRAMEBUFFER, null), ne = !1) : We.__webglFramebuffer === void 0 ? b.setupRenderTarget(P) : We.__hasExternalTextures && b.rebindTextures(P, Y.get(P.texture).__webglTexture, Y.get(P.depthTexture).__webglTexture);
                const Ze = P.texture;
                (Ze.isData3DTexture || Ze.isDataArrayTexture || Ze.isCompressedArrayTexture) && (Ue = !0);
                const Ye = Y.get(P).__webglFramebuffer;
                P.isWebGLCubeRenderTarget ? (Array.isArray(Ye[X]) ? Z = Ye[X][Q] : Z = Ye[X], Oe = !0) : N.isWebGL2 && P.samples > 0 && b.useMultisampledRTT(P) === !1 ? Z = Y.get(P).__webglMultisampledFramebuffer : Array.isArray(Ye) ? Z = Ye[Q] : Z = Ye, A.copy(P.viewport), G.copy(P.scissor), ee = P.scissorTest
            } else A.copy(pe).multiplyScalar(j).floor(), G.copy(de).multiplyScalar(j).floor(), ee = xe;
            if (U.bindFramebuffer(I.FRAMEBUFFER, Z) && N.drawBuffers && ne && U.drawBuffers(P, Z), U.viewport(A), U.scissor(G), U.setScissorTest(ee), Oe) {
                const We = Y.get(P.texture);
                I.framebufferTexture2D(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_CUBE_MAP_POSITIVE_X + X, We.__webglTexture, Q)
            } else if (Ue) {
                const We = Y.get(P.texture),
                    Ze = X || 0;
                I.framebufferTextureLayer(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, We.__webglTexture, Q || 0, Ze)
            }
            F = -1
        }, this.readRenderTargetPixels = function (P, X, Q, ne, Z, Oe, Ue) {
            if (!(P && P.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Ve = Y.get(P).__webglFramebuffer;
            if (P.isWebGLCubeRenderTarget && Ue !== void 0 && (Ve = Ve[Ue]), Ve) {
                U.bindFramebuffer(I.FRAMEBUFFER, Ve);
                try {
                    const We = P.texture,
                        Ze = We.format,
                        Ye = We.type;
                    if (Ze !== on && ye.convert(Ze) !== I.getParameter(I.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const Ke = Ye === ho && (E.has("EXT_color_buffer_half_float") || N.isWebGL2 && E.has("EXT_color_buffer_float"));
                    if (Ye !== Ui && ye.convert(Ye) !== I.getParameter(I.IMPLEMENTATION_COLOR_READ_TYPE) && !(Ye === qn && (N.isWebGL2 || E.has("OES_texture_float") || E.has("WEBGL_color_buffer_float"))) && !Ke) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    X >= 0 && X <= P.width - ne && Q >= 0 && Q <= P.height - Z && I.readPixels(X, Q, ne, Z, ye.convert(Ze), ye.convert(Ye), Oe)
                } finally {
                    const We = R !== null ? Y.get(R).__webglFramebuffer : null;
                    U.bindFramebuffer(I.FRAMEBUFFER, We)
                }
            }
        }, this.copyFramebufferToTexture = function (P, X, Q = 0) {
            const ne = Math.pow(2, -Q),
                Z = Math.floor(X.image.width * ne),
                Oe = Math.floor(X.image.height * ne);
            b.setTexture2D(X, 0), I.copyTexSubImage2D(I.TEXTURE_2D, Q, 0, 0, P.x, P.y, Z, Oe), U.unbindTexture()
        }, this.copyTextureToTexture = function (P, X, Q, ne = 0) {
            const Z = X.image.width,
                Oe = X.image.height,
                Ue = ye.convert(Q.format),
                Ve = ye.convert(Q.type);
            b.setTexture2D(Q, 0), I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, Q.flipY), I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), I.pixelStorei(I.UNPACK_ALIGNMENT, Q.unpackAlignment), X.isDataTexture ? I.texSubImage2D(I.TEXTURE_2D, ne, P.x, P.y, Z, Oe, Ue, Ve, X.image.data) : X.isCompressedTexture ? I.compressedTexSubImage2D(I.TEXTURE_2D, ne, P.x, P.y, X.mipmaps[0].width, X.mipmaps[0].height, Ue, X.mipmaps[0].data) : I.texSubImage2D(I.TEXTURE_2D, ne, P.x, P.y, Ue, Ve, X.image), ne === 0 && Q.generateMipmaps && I.generateMipmap(I.TEXTURE_2D), U.unbindTexture()
        }, this.copyTextureToTexture3D = function (P, X, Q, ne, Z = 0) {
            if (v.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const Oe = P.max.x - P.min.x + 1,
                Ue = P.max.y - P.min.y + 1,
                Ve = P.max.z - P.min.z + 1,
                We = ye.convert(ne.format),
                Ze = ye.convert(ne.type);
            let Ye;
            if (ne.isData3DTexture) b.setTexture3D(ne, 0), Ye = I.TEXTURE_3D;
            else if (ne.isDataArrayTexture || ne.isCompressedArrayTexture) b.setTexture2DArray(ne, 0), Ye = I.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, ne.flipY), I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha), I.pixelStorei(I.UNPACK_ALIGNMENT, ne.unpackAlignment);
            const Ke = I.getParameter(I.UNPACK_ROW_LENGTH),
                At = I.getParameter(I.UNPACK_IMAGE_HEIGHT),
                dn = I.getParameter(I.UNPACK_SKIP_PIXELS),
                Ft = I.getParameter(I.UNPACK_SKIP_ROWS),
                ni = I.getParameter(I.UNPACK_SKIP_IMAGES),
                St = Q.isCompressedTexture ? Q.mipmaps[Z] : Q.image;
            I.pixelStorei(I.UNPACK_ROW_LENGTH, St.width), I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, St.height), I.pixelStorei(I.UNPACK_SKIP_PIXELS, P.min.x), I.pixelStorei(I.UNPACK_SKIP_ROWS, P.min.y), I.pixelStorei(I.UNPACK_SKIP_IMAGES, P.min.z), Q.isDataTexture || Q.isData3DTexture ? I.texSubImage3D(Ye, Z, X.x, X.y, X.z, Oe, Ue, Ve, We, Ze, St.data) : Q.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), I.compressedTexSubImage3D(Ye, Z, X.x, X.y, X.z, Oe, Ue, Ve, We, St.data)) : I.texSubImage3D(Ye, Z, X.x, X.y, X.z, Oe, Ue, Ve, We, Ze, St), I.pixelStorei(I.UNPACK_ROW_LENGTH, Ke), I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, At), I.pixelStorei(I.UNPACK_SKIP_PIXELS, dn), I.pixelStorei(I.UNPACK_SKIP_ROWS, Ft), I.pixelStorei(I.UNPACK_SKIP_IMAGES, ni), Z === 0 && ne.generateMipmaps && I.generateMipmap(Ye), U.unbindTexture()
        }, this.initTexture = function (P) {
            P.isCubeTexture ? b.setTextureCube(P, 0) : P.isData3DTexture ? b.setTexture3D(P, 0) : P.isDataArrayTexture || P.isCompressedArrayTexture ? b.setTexture2DArray(P, 0) : b.setTexture2D(P, 0), U.unbindTexture()
        }, this.resetState = function () {
            C = 0, S = 0, R = null, U.reset(), Le.reset()
        }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem() {
        return Yn
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === Ku ? "display-p3" : "srgb", t.unpackColorSpace = dt.workingColorSpace === Sl ? "display-p3" : "srgb"
    }
    get outputEncoding() {
        return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Pt ? ur : Ag
    }
    set outputEncoding(e) {
        console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === ur ? Pt : mi
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
    }
}
class IE extends th {}
IE.prototype.isWebGL1Renderer = !0;
class nh {
    constructor(e, t = 25e-5) {
        this.isFogExp2 = !0, this.name = "", this.color = new Fe(e), this.density = t
    }
    clone() {
        return new nh(this.color, this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class ih {
    constructor(e, t = 1, i = 1e3) {
        this.isFog = !0, this.name = "", this.color = new Fe(e), this.near = t, this.far = i
    }
    clone() {
        return new ih(this.color, this.near, this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class vs extends Mt {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t
    }
}
class qg {
    constructor(e, t) {
        this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = uu, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.version = 0, this.uuid = Rn()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(e) {
        return this.usage = e, this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
    }
    copyAt(e, t, i) {
        e *= this.stride, i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Rn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Rn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const nn = new L;
class ys {
    constructor(e, t, i, r = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++) nn.fromBufferAttribute(this, t), nn.applyMatrix4(e), this.setXYZ(t, nn.x, nn.y, nn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) nn.fromBufferAttribute(this, t), nn.applyNormalMatrix(e), this.setXYZ(t, nn.x, nn.y, nn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) nn.fromBufferAttribute(this, t), nn.transformDirection(e), this.setXYZ(t, nn.x, nn.y, nn.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
    }
    setY(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
    }
    setZ(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
    }
    setW(e, t) {
        return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Xn(t, this.array)), t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = ft(t, this.array), i = ft(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), r = ft(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), r = ft(r, this.array), s = ft(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
            }
            return new ut(new this.array.constructor(t), this.itemSize, this.normalized)
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ys(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class Yg extends Vt {
    constructor(e) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Fe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
let Hr;
const Ns = new L,
    Wr = new L,
    $r = new L,
    Xr = new ue,
    Us = new ue,
    Kg = new qe,
    aa = new L,
    Fs = new L,
    la = new L,
    op = new ue,
    Rc = new ue,
    ap = new ue;
class DE extends Mt {
    constructor(e = new Yg) {
        if (super(), this.isSprite = !0, this.type = "Sprite", Hr === void 0) {
            Hr = new ht;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                i = new qg(t, 5);
            Hr.setIndex([0, 1, 2, 0, 2, 3]), Hr.setAttribute("position", new ys(i, 3, 0, !1)), Hr.setAttribute("uv", new ys(i, 2, 3, !1))
        }
        this.geometry = Hr, this.material = e, this.center = new ue(.5, .5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Wr.setFromMatrixScale(this.matrixWorld), Kg.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), $r.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Wr.multiplyScalar(-$r.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i), r = Math.sin(i));
        const o = this.center;
        ca(aa.set(-.5, -.5, 0), $r, o, Wr, r, s), ca(Fs.set(.5, -.5, 0), $r, o, Wr, r, s), ca(la.set(.5, .5, 0), $r, o, Wr, r, s), op.set(0, 0), Rc.set(1, 0), ap.set(1, 1);
        let a = e.ray.intersectTriangle(aa, Fs, la, !1, Ns);
        if (a === null && (ca(Fs.set(-.5, .5, 0), $r, o, Wr, r, s), Rc.set(0, 1), a = e.ray.intersectTriangle(aa, la, Fs, !1, Ns), a === null)) return;
        const l = e.ray.origin.distanceTo(Ns);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: Ns.clone(),
            uv: gn.getInterpolation(Ns, aa, Fs, la, op, Rc, ap, new ue),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
    }
}

function ca(n, e, t, i, r, s) {
    Xr.subVectors(n, t).addScalar(.5).multiply(i), r !== void 0 ? (Us.x = s * Xr.x - r * Xr.y, Us.y = r * Xr.x + s * Xr.y) : Us.copy(Xr), n.copy(e), n.x += Us.x, n.y += Us.y, n.applyMatrix4(Kg)
}
const ua = new L,
    lp = new L;
class OE extends Mt {
    constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }), this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate, this
    }
    addLevel(e, t = 0, i = 0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++);
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }), this.add(e), this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1, r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s) break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            ua.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(ua);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            ua.setFromMatrixPosition(e.matrixWorld), lp.setFromMatrixPosition(this.matrixWorld);
            const i = ua.distanceTo(lp) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1, s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                else break
            }
            for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const cp = new L,
    up = new pt,
    hp = new pt,
    NE = new L,
    fp = new qe,
    ha = new L,
    Cc = new an,
    dp = new qe,
    Pc = new Eo;
class UE extends xt {
    constructor(e, t) {
        super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Wf, this.bindMatrix = new qe, this.bindMatrixInverse = new qe, this.boundingBox = null, this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Mn), this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++) this.getVertexPosition(i, ha), this.boundingBox.expandByPoint(ha)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new an), this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++) this.getVertexPosition(i, ha), this.boundingSphere.expandByPoint(ha)
    }
    copy(e, t) {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    raycast(e, t) {
        const i = this.material,
            r = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Cc.copy(this.boundingSphere), Cc.applyMatrix4(r), e.ray.intersectsSphere(Cc) !== !1 && (dp.copy(r).invert(), Pc.copy(e.ray).applyMatrix4(dp), !(this.boundingBox !== null && Pc.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Pc)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
    }
    bind(e, t) {
        this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new pt,
            t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === Wf ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Yx ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton,
            r = this.geometry;
        up.fromBufferAttribute(r.attributes.skinIndex, e), hp.fromBufferAttribute(r.attributes.skinWeight, e), cp.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = hp.getComponent(s);
            if (o !== 0) {
                const a = up.getComponent(s);
                fp.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(NE.copy(cp).applyMatrix4(fp), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
    boneTransform(e, t) {
        return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t)
    }
}
class jg extends Mt {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class eo extends zt {
    constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = It, u = It, h, f) {
        super(null, o, a, l, c, u, r, s, h, f), this.isDataTexture = !0, this.image = {
            data: e,
            width: t,
            height: i
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const pp = new qe,
    FE = new qe;
class rh {
    constructor(e = [], t = []) {
        this.uuid = Rn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
    }
    init() {
        const e = this.bones,
            t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new qe)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new qe;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones,
            t = this.boneInverses,
            i = this.boneMatrices,
            r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : FE;
            pp.multiplyMatrices(a, t[s]), pp.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new rh(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new eo(t, e, e, on, qn);
        return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e) return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new jg), this.bones.push(o), this.boneInverses.push(new qe().fromArray(e.boneInverses[i]))
        }
        return this.init(), this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones,
            i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class _o extends ut {
    constructor(e, t, i, r = 1) {
        super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
    }
}
const qr = new qe,
    mp = new qe,
    fa = [],
    gp = new Mn,
    BE = new qe,
    Bs = new xt,
    ks = new an;
class kE extends xt {
    constructor(e, t, i) {
        super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new _o(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
        for (let r = 0; r < i; r++) this.setMatrixAt(r, BE)
    }
    computeBoundingBox() {
        const e = this.geometry,
            t = this.count;
        this.boundingBox === null && (this.boundingBox = new Mn), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++) this.getMatrixAt(i, qr), gp.copy(e.boundingBox).applyMatrix4(qr), this.boundingBox.union(gp)
    }
    computeBoundingSphere() {
        const e = this.geometry,
            t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new an), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++) this.getMatrixAt(i, qr), ks.copy(e.boundingSphere).applyMatrix4(qr), this.boundingSphere.union(ks)
    }
    copy(e, t) {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const i = this.matrixWorld,
            r = this.count;
        if (Bs.geometry = this.geometry, Bs.material = this.material, Bs.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ks.copy(this.boundingSphere), ks.applyMatrix4(i), e.ray.intersectsSphere(ks) !== !1))
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, qr), mp.multiplyMatrices(i, qr), Bs.matrixWorld = mp, Bs.raycast(e, fa);
                for (let o = 0, a = fa.length; o < a; o++) {
                    const l = fa[o];
                    l.instanceId = s, l.object = this, t.push(l)
                }
                fa.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new _o(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}

function zE(n, e) {
    return n.z - e.z
}

function GE(n, e) {
    return e.z - n.z
}
class VE {
    constructor() {
        this.index = 0, this.pool = [], this.list = []
    }
    push(e, t) {
        const i = this.pool,
            r = this.list;
        this.index >= i.length && i.push({
            start: -1,
            count: -1,
            z: -1
        });
        const s = i[this.index];
        r.push(s), this.index++, s.start = e.start, s.count = e.count, s.z = t
    }
    reset() {
        this.list.length = 0, this.index = 0
    }
}
const Yr = "batchId",
    Ti = new qe,
    _p = new qe,
    HE = new qe,
    vp = new qe,
    Lc = new wl,
    da = new Mn,
    ji = new an,
    zs = new L,
    Ic = new VE,
    Xt = new xt,
    pa = [];

function WE(n, e, t = 0) {
    const i = e.itemSize;
    if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
        const r = n.count;
        for (let s = 0; s < r; s++)
            for (let o = 0; o < i; o++) e.setComponent(s + t, o, n.getComponent(s, o))
    } else e.array.set(n.array, t * i);
    e.needsUpdate = !0
}
class $E extends xt {
    get maxGeometryCount() {
        return this._maxGeometryCount
    }
    constructor(e, t, i = t * 2, r) {
        super(new ht, r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = i, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxGeometryCount * 4);
        e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4),
            i = new eo(t, e, e, on, qn);
        this._matricesTexture = i
    }
    _initializeGeometry(e) {
        const t = this.geometry,
            i = this._maxVertexCount,
            r = this._maxGeometryCount,
            s = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const a in e.attributes) {
                const l = e.getAttribute(a),
                    {
                        array: c,
                        itemSize: u,
                        normalized: h
                    } = l,
                    f = new c.constructor(i * u),
                    d = new l.constructor(f, u, h);
                d.setUsage(l.usage), t.setAttribute(a, d)
            }
            if (e.getIndex() !== null) {
                const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
                t.setIndex(new ut(a, 1))
            }
            const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
            t.setAttribute(Yr, new ut(o, 1)), this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        if (e.getAttribute(Yr)) throw new Error(`BatchedMesh: Geometry cannot use attribute "${Yr}"`);
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const i in t.attributes) {
            if (i === Yr) continue;
            if (!e.hasAttribute(i)) throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
            const r = e.getAttribute(i),
                s = t.getAttribute(i);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e, this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Mn);
        const e = this._geometryCount,
            t = this.boundingBox,
            i = this._active;
        t.makeEmpty();
        for (let r = 0; r < e; r++) i[r] !== !1 && (this.getMatrixAt(r, Ti), this.getBoundingBoxAt(r, da).applyMatrix4(Ti), t.union(da))
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new an);
        const e = this._geometryCount,
            t = this.boundingSphere,
            i = this._active;
        t.makeEmpty();
        for (let r = 0; r < e; r++) i[r] !== !1 && (this.getMatrixAt(r, Ti), this.getBoundingSphereAt(r, ji).applyMatrix4(Ti), t.union(ji))
    }
    addGeometry(e, t = -1, i = -1) {
        if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
        const r = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let s = null;
        const o = this._reservedRanges,
            a = this._drawRanges,
            l = this._bounds;
        this._geometryCount !== 0 && (s = o[o.length - 1]), t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t, s === null ? r.vertexStart = 0 : r.vertexStart = s.vertexStart + s.vertexCount;
        const c = e.getIndex(),
            u = c !== null;
        if (u && (i === -1 ? r.indexCount = c.count : r.indexCount = i, s === null ? r.indexStart = 0 : r.indexStart = s.indexStart + s.indexCount), r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        const h = this._visibility,
            f = this._active,
            d = this._matricesTexture,
            p = this._matricesTexture.image.data;
        h.push(!0), f.push(!0);
        const _ = this._geometryCount;
        this._geometryCount++, HE.toArray(p, _ * 16), d.needsUpdate = !0, o.push(r), a.push({
            start: u ? r.indexStart : r.vertexStart,
            count: -1
        }), l.push({
            boxInitialized: !1,
            box: new Mn,
            sphereInitialized: !1,
            sphere: new an
        });
        const g = this.geometry.getAttribute(Yr);
        for (let m = 0; m < r.vertexCount; m++) g.setX(r.vertexStart + m, _);
        return g.needsUpdate = !0, this.setGeometryAt(_, e), _
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const i = this.geometry,
            r = i.getIndex() !== null,
            s = i.getIndex(),
            o = t.getIndex(),
            a = this._reservedRanges[e];
        if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const l = a.vertexStart,
            c = a.vertexCount;
        for (const d in i.attributes) {
            if (d === Yr) continue;
            const p = t.getAttribute(d),
                _ = i.getAttribute(d);
            WE(p, _, l);
            const g = p.itemSize;
            for (let m = p.count, y = c; m < y; m++) {
                const v = l + m;
                for (let x = 0; x < g; x++) _.setComponent(v, x, 0)
            }
            _.needsUpdate = !0
        }
        if (r) {
            const d = a.indexStart;
            for (let p = 0; p < o.count; p++) s.setX(d + p, l + o.getX(p));
            for (let p = o.count, _ = a.indexCount; p < _; p++) s.setX(d + p, l);
            s.needsUpdate = !0
        }
        const u = this._bounds[e];
        t.boundingBox !== null ? (u.box.copy(t.boundingBox), u.boxInitialized = !0) : u.boxInitialized = !1, t.boundingSphere !== null ? (u.sphere.copy(t.boundingSphere), u.sphereInitialized = !0) : u.sphereInitialized = !1;
        const h = this._drawRanges[e],
            f = t.getAttribute("position");
        return h.count = r ? o.count : f.count, this._visibilityChanged = !0, e
    }
    deleteGeometry(e) {
        const t = this._active;
        return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this)
    }
    getBoundingBoxAt(e, t) {
        if (this._active[e] === !1) return this;
        const r = this._bounds[e],
            s = r.box,
            o = this.geometry;
        if (r.boxInitialized === !1) {
            s.makeEmpty();
            const a = o.index,
                l = o.attributes.position,
                c = this._drawRanges[e];
            for (let u = c.start, h = c.start + c.count; u < h; u++) {
                let f = u;
                a && (f = a.getX(f)), s.expandByPoint(zs.fromBufferAttribute(l, f))
            }
            r.boxInitialized = !0
        }
        return t.copy(s), t
    }
    getBoundingSphereAt(e, t) {
        if (this._active[e] === !1) return this;
        const r = this._bounds[e],
            s = r.sphere,
            o = this.geometry;
        if (r.sphereInitialized === !1) {
            s.makeEmpty(), this.getBoundingBoxAt(e, da), da.getCenter(s.center);
            const a = o.index,
                l = o.attributes.position,
                c = this._drawRanges[e];
            let u = 0;
            for (let h = c.start, f = c.start + c.count; h < f; h++) {
                let d = h;
                a && (d = a.getX(d)), zs.fromBufferAttribute(l, d), u = Math.max(u, s.center.distanceToSquared(zs))
            }
            s.radius = Math.sqrt(u), r.sphereInitialized = !0
        }
        return t.copy(s), t
    }
    setMatrixAt(e, t) {
        const i = this._active,
            r = this._matricesTexture,
            s = this._matricesTexture.image.data,
            o = this._geometryCount;
        return e >= o || i[e] === !1 ? this : (t.toArray(s, e * 16), r.needsUpdate = !0, this)
    }
    getMatrixAt(e, t) {
        const i = this._active,
            r = this._matricesTexture.image.data,
            s = this._geometryCount;
        return e >= s || i[e] === !1 ? null : t.fromArray(r, e * 16)
    }
    setVisibleAt(e, t) {
        const i = this._visibility,
            r = this._active,
            s = this._geometryCount;
        return e >= s || r[e] === !1 || i[e] === t ? this : (i[e] = t, this._visibilityChanged = !0, this)
    }
    getVisibleAt(e) {
        const t = this._visibility,
            i = this._active,
            r = this._geometryCount;
        return e >= r || i[e] === !1 ? !1 : t[e]
    }
    raycast(e, t) {
        const i = this._visibility,
            r = this._active,
            s = this._drawRanges,
            o = this._geometryCount,
            a = this.matrixWorld,
            l = this.geometry;
        Xt.material = this.material, Xt.geometry.index = l.index, Xt.geometry.attributes = l.attributes, Xt.geometry.boundingBox === null && (Xt.geometry.boundingBox = new Mn), Xt.geometry.boundingSphere === null && (Xt.geometry.boundingSphere = new an);
        for (let c = 0; c < o; c++) {
            if (!i[c] || !r[c]) continue;
            const u = s[c];
            Xt.geometry.setDrawRange(u.start, u.count), this.getMatrixAt(c, Xt.matrixWorld).premultiply(a), this.getBoundingBoxAt(c, Xt.geometry.boundingBox), this.getBoundingSphereAt(c, Xt.geometry.boundingSphere), Xt.raycast(e, pa);
            for (let h = 0, f = pa.length; h < f; h++) {
                const d = pa[h];
                d.object = this, d.batchId = c, t.push(d)
            }
            pa.length = 0
        }
        Xt.material = null, Xt.geometry.index = null, Xt.geometry.attributes = {}, Xt.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map(t => ({
            ...t
        })), this._reservedRanges = e._reservedRanges.map(t => ({
            ...t
        })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map(t => ({
            boxInitialized: t.boxInitialized,
            box: t.box.clone(),
            sphereInitialized: t.sphereInitialized,
            sphere: t.sphere.clone()
        })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this
    }
    dispose() {
        return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this
    }
    onBeforeRender(e, t, i, r, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
        const o = r.getIndex(),
            a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
            l = this._visibility,
            c = this._multiDrawStarts,
            u = this._multiDrawCounts,
            h = this._drawRanges,
            f = this.perObjectFrustumCulled;
        f && (vp.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), Lc.setFromProjectionMatrix(vp, e.isWebGPURenderer ? mo : Yn));
        let d = 0;
        if (this.sortObjects) {
            _p.copy(this.matrixWorld).invert(), zs.setFromMatrixPosition(i.matrixWorld).applyMatrix4(_p);
            for (let g = 0, m = l.length; g < m; g++)
                if (l[g]) {
                    this.getMatrixAt(g, Ti), this.getBoundingSphereAt(g, ji).applyMatrix4(Ti);
                    let y = !1;
                    if (f && (y = !Lc.intersectsSphere(ji)), !y) {
                        const v = zs.distanceTo(ji.center);
                        Ic.push(h[g], v)
                    }
                } const p = Ic.list,
                _ = this.customSort;
            _ === null ? p.sort(s.transparent ? GE : zE) : _.call(this, p, i);
            for (let g = 0, m = p.length; g < m; g++) {
                const y = p[g];
                c[d] = y.start * a, u[d] = y.count, d++
            }
            Ic.reset()
        } else
            for (let p = 0, _ = l.length; p < _; p++)
                if (l[p]) {
                    let g = !1;
                    if (f && (this.getMatrixAt(p, Ti), this.getBoundingSphereAt(p, ji).applyMatrix4(Ti), g = !Lc.intersectsSphere(ji)), !g) {
                        const m = h[p];
                        c[d] = m.start * a, u[d] = m.count, d++
                    }
                } this._multiDrawCount = d, this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, i, r, s, o) {
        this.onBeforeRender(e, null, r, s, o)
    }
}
class us extends Vt {
    constructor(e) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Fe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
    }
}
const yp = new L,
    xp = new L,
    Mp = new qe,
    Dc = new Eo,
    ma = new an;
class sh extends Mt {
    constructor(e = new ht, t = new us) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [0];
            for (let r = 1, s = t.count; r < s; r++) yp.fromBufferAttribute(t, r - 1), xp.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += yp.distanceTo(xp);
            e.setAttribute("lineDistance", new Ge(i, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Line.threshold,
            o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), ma.copy(i.boundingSphere), ma.applyMatrix4(r), ma.radius += s, e.ray.intersectsSphere(ma) === !1) return;
        Mp.copy(r).invert(), Dc.copy(e.ray).applyMatrix4(Mp);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new L,
            u = new L,
            h = new L,
            f = new L,
            d = this.isLineSegments ? 2 : 1,
            p = i.index,
            g = i.attributes.position;
        if (p !== null) {
            const m = Math.max(0, o.start),
                y = Math.min(p.count, o.start + o.count);
            for (let v = m, x = y - 1; v < x; v += d) {
                const C = p.getX(v),
                    S = p.getX(v + 1);
                if (c.fromBufferAttribute(g, C), u.fromBufferAttribute(g, S), Dc.distanceSqToSegment(c, u, f, h) > l) continue;
                f.applyMatrix4(this.matrixWorld);
                const F = e.ray.origin.distanceTo(f);
                F < e.near || F > e.far || t.push({
                    distance: F,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: v,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const m = Math.max(0, o.start),
                y = Math.min(g.count, o.start + o.count);
            for (let v = m, x = y - 1; v < x; v += d) {
                if (c.fromBufferAttribute(g, v), u.fromBufferAttribute(g, v + 1), Dc.distanceSqToSegment(c, u, f, h) > l) continue;
                f.applyMatrix4(this.matrixWorld);
                const S = e.ray.origin.distanceTo(f);
                S < e.near || S > e.far || t.push({
                    distance: S,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: v,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const bp = new L,
    Sp = new L;
class pu extends sh {
    constructor(e, t) {
        super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [];
            for (let r = 0, s = t.count; r < s; r += 2) bp.fromBufferAttribute(t, r), Sp.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + bp.distanceTo(Sp);
            e.setAttribute("lineDistance", new Ge(i, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class XE extends sh {
    constructor(e, t) {
        super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class ts extends Vt {
    constructor(e) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Fe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
const Tp = new qe,
    mu = new Eo,
    ga = new an,
    _a = new L;
class Ua extends Mt {
    constructor(e = new ht, t = new ts) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Points.threshold,
            o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), ga.copy(i.boundingSphere), ga.applyMatrix4(r), ga.radius += s, e.ray.intersectsSphere(ga) === !1) return;
        Tp.copy(r).invert(), mu.copy(e.ray).applyMatrix4(Tp);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = i.index,
            h = i.attributes.position;
        if (c !== null) {
            const f = Math.max(0, o.start),
                d = Math.min(c.count, o.start + o.count);
            for (let p = f, _ = d; p < _; p++) {
                const g = c.getX(p);
                _a.fromBufferAttribute(h, g), wp(_a, g, l, r, e, t, this)
            }
        } else {
            const f = Math.max(0, o.start),
                d = Math.min(h.count, o.start + o.count);
            for (let p = f, _ = d; p < _; p++) _a.fromBufferAttribute(h, p), wp(_a, p, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}

function wp(n, e, t, i, r, s, o) {
    const a = mu.distanceSqToPoint(n);
    if (a < t) {
        const l = new L;
        mu.closestPointToPoint(n, l), l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far) return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class Oc extends zt {
    constructor(e, t, i, r, s, o, a, l, c, u, h, f) {
        super(null, o, a, l, c, u, r, s, h, f), this.isCompressedTexture = !0, this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }
}
class Jg extends zt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class ei {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0),
            s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++) i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i;
        return this.cacheArcLengths = t, t
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0,
            l = s - 1,
            c;
        for (; a <= l;)
            if (r = Math.floor(a + (l - a) / 2), c = i[r] - o, c < 0) a = r + 1;
            else if (c > 0) l = r - 1;
        else {
            l = r;
            break
        }
        if (r = l, i[r] === o) return r / (s - 1);
        const u = i[r],
            f = i[r + 1] - u,
            d = (o - u) / f;
        return (r + d) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4,
            s = e + 1e-4;
        r < 0 && (r = 0), s > 1 && (s = 1);
        const o = this.getPoint(r),
            a = this.getPoint(s),
            l = t || (o.isVector2 ? new ue : new L);
        return l.copy(a).sub(o).normalize(), l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new L,
            r = [],
            s = [],
            o = [],
            a = new L,
            l = new qe;
        for (let d = 0; d <= e; d++) {
            const p = d / e;
            r[d] = this.getTangentAt(p, new L)
        }
        s[0] = new L, o[0] = new L;
        let c = Number.MAX_VALUE;
        const u = Math.abs(r[0].x),
            h = Math.abs(r[0].y),
            f = Math.abs(r[0].z);
        u <= c && (c = u, i.set(1, 0, 0)), h <= c && (c = h, i.set(0, 1, 0)), f <= c && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
        for (let d = 1; d <= e; d++) {
            if (s[d] = s[d - 1].clone(), o[d] = o[d - 1].clone(), a.crossVectors(r[d - 1], r[d]), a.length() > Number.EPSILON) {
                a.normalize();
                const p = Math.acos(Lt(r[d - 1].dot(r[d]), -1, 1));
                s[d].applyMatrix4(l.makeRotationAxis(a, p))
            }
            o[d].crossVectors(r[d], s[d])
        }
        if (t === !0) {
            let d = Math.acos(Lt(s[0].dot(s[e]), -1, 1));
            d /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (d = -d);
            for (let p = 1; p <= e; p++) s[p].applyMatrix4(l.makeRotationAxis(r[p], d * p)), o[p].crossVectors(r[p], s[p])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
}
class oh extends ei {
    constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
    }
    getPoint(e, t) {
        const i = t || new ue,
            r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0;) s += r;
        for (; s > r;) s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation),
                h = Math.sin(this.aRotation),
                f = l - this.aX,
                d = c - this.aY;
            l = f * u - d * h + this.aX, c = f * h + d * u + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
}
class qE extends oh {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function ah() {
    let n = 0,
        e = 0,
        t = 0,
        i = 0;

    function r(s, o, a, l) {
        n = s, e = a, t = -3 * s + 3 * o - 2 * a - l, i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function (s, o, a, l, c) {
            r(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function (s, o, a, l, c, u, h) {
            let f = (o - s) / c - (a - s) / (c + u) + (a - o) / u,
                d = (a - o) / u - (l - o) / (u + h) + (l - a) / h;
            f *= u, d *= u, r(o, a, f, d)
        },
        calc: function (s) {
            const o = s * s,
                a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const va = new L,
    Nc = new ah,
    Uc = new ah,
    Fc = new ah;
class YE extends ei {
    constructor(e = [], t = !1, i = "centripetal", r = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r
    }
    getPoint(e, t = new L) {
        const i = t,
            r = this.points,
            s = r.length,
            o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o),
            l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
        let c, u;
        this.closed || a > 0 ? c = r[(a - 1) % s] : (va.subVectors(r[0], r[1]).add(r[0]), c = va);
        const h = r[a % s],
            f = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? u = r[(a + 2) % s] : (va.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), u = va), this.curveType === "centripetal" || this.curveType === "chordal") {
            const d = this.curveType === "chordal" ? .5 : .25;
            let p = Math.pow(c.distanceToSquared(h), d),
                _ = Math.pow(h.distanceToSquared(f), d),
                g = Math.pow(f.distanceToSquared(u), d);
            _ < 1e-4 && (_ = 1), p < 1e-4 && (p = _), g < 1e-4 && (g = _), Nc.initNonuniformCatmullRom(c.x, h.x, f.x, u.x, p, _, g), Uc.initNonuniformCatmullRom(c.y, h.y, f.y, u.y, p, _, g), Fc.initNonuniformCatmullRom(c.z, h.z, f.z, u.z, p, _, g)
        } else this.curveType === "catmullrom" && (Nc.initCatmullRom(c.x, h.x, f.x, u.x, this.tension), Uc.initCatmullRom(c.y, h.y, f.y, u.y, this.tension), Fc.initCatmullRom(c.z, h.z, f.z, u.z, this.tension));
        return i.set(Nc.calc(l), Uc.calc(l), Fc.calc(l)), i
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new L().fromArray(r))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
}

function Ep(n, e, t, i, r) {
    const s = (i - e) * .5,
        o = (r - t) * .5,
        a = n * n,
        l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}

function KE(n, e) {
    const t = 1 - n;
    return t * t * e
}

function jE(n, e) {
    return 2 * (1 - n) * n * e
}

function JE(n, e) {
    return n * n * e
}

function to(n, e, t, i) {
    return KE(n, e) + jE(n, t) + JE(n, i)
}

function ZE(n, e) {
    const t = 1 - n;
    return t * t * t * e
}

function QE(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}

function eA(n, e) {
    return 3 * (1 - n) * n * n * e
}

function tA(n, e) {
    return n * n * n * e
}

function no(n, e, t, i, r) {
    return ZE(n, e) + QE(n, t) + eA(n, i) + tA(n, r)
}
class Zg extends ei {
    constructor(e = new ue, t = new ue, i = new ue, r = new ue) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
    }
    getPoint(e, t = new ue) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(no(e, r.x, s.x, o.x, a.x), no(e, r.y, s.y, o.y, a.y)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class nA extends ei {
    constructor(e = new L, t = new L, i = new L, r = new L) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
    }
    getPoint(e, t = new L) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(no(e, r.x, s.x, o.x, a.x), no(e, r.y, s.y, o.y, a.y), no(e, r.z, s.z, o.z, a.z)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class Qg extends ei {
    constructor(e = new ue, t = new ue) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new ue) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t = new ue) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class iA extends ei {
    constructor(e = new L, t = new L) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new L) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t = new L) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class e_ extends ei {
    constructor(e = new ue, t = new ue, i = new ue) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i
    }
    getPoint(e, t = new ue) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2;
        return i.set(to(e, r.x, s.x, o.x), to(e, r.y, s.y, o.y)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class t_ extends ei {
    constructor(e = new L, t = new L, i = new L) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i
    }
    getPoint(e, t = new L) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2;
        return i.set(to(e, r.x, s.x, o.x), to(e, r.y, s.y, o.y), to(e, r.z, s.z, o.z)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class n_ extends ei {
    constructor(e = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
    }
    getPoint(e, t = new ue) {
        const i = t,
            r = this.points,
            s = (r.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = r[o === 0 ? o : o - 1],
            c = r[o],
            u = r[o > r.length - 2 ? r.length - 1 : o + 1],
            h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(Ep(a, l.x, c.x, u.x, h.x), Ep(a, l.y, c.y, u.y, h.y)), i
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new ue().fromArray(r))
        }
        return this
    }
}
var nl = Object.freeze({
    __proto__: null,
    ArcCurve: qE,
    CatmullRomCurve3: YE,
    CubicBezierCurve: Zg,
    CubicBezierCurve3: nA,
    EllipseCurve: oh,
    LineCurve: Qg,
    LineCurve3: iA,
    QuadraticBezierCurve: e_,
    QuadraticBezierCurve3: t_,
    SplineCurve: n_
});
class rA extends ei {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new nl[i](t, e))
        }
        return this
    }
    getPoint(e, t) {
        const i = e * this.getLength(),
            r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length;) {
            if (r[s] >= i) {
                const o = r[s] - i,
                    a = this.curves[s],
                    l = a.getLength(),
                    c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++) t += this.curves[i].getLength(), e.push(t);
        return this.cacheLengths = e, e
    }
    getSpacedPoints(e = 40) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]), t
    }
    getPoints(e = 12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r],
                a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
                l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const u = l[c];
                i && i.equals(u) || (t.push(u), i = u)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
    }
    copy(e) {
        super.copy(e), this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose, this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new nl[r.type]().fromJSON(r))
        }
        return this
    }
}
class gu extends rA {
    constructor(e) {
        super(), this.type = "Path", this.currentPoint = new ue, e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this
    }
    lineTo(e, t) {
        const i = new Qg(this.currentPoint.clone(), new ue(e, t));
        return this.curves.push(i), this.currentPoint.set(e, t), this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new e_(this.currentPoint.clone(), new ue(e, t), new ue(i, r));
        return this.curves.push(s), this.currentPoint.set(i, r), this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new Zg(this.currentPoint.clone(), new ue(e, t), new ue(i, r), new ue(s, o));
        return this.curves.push(a), this.currentPoint.set(s, o), this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
            i = new n_(t);
        return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x,
            l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o), this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o), this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const c = this.currentPoint.x,
            u = this.currentPoint.y;
        return this.absellipse(e + c, t + u, i, r, s, o, a, l), this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const c = new oh(e, t, i, r, s, o, a, l);
        if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(c);
        const u = c.getPoint(1);
        return this.currentPoint.copy(u), this
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
    }
}
class Al extends ht {
    constructor(e = [new ue(0, -.5), new ue(.5, 0), new ue(0, .5)], t = 12, i = 0, r = Math.PI * 2) {
        super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        }, t = Math.floor(t), r = Lt(r, 0, Math.PI * 2);
        const s = [],
            o = [],
            a = [],
            l = [],
            c = [],
            u = 1 / t,
            h = new L,
            f = new ue,
            d = new L,
            p = new L,
            _ = new L;
        let g = 0,
            m = 0;
        for (let y = 0; y <= e.length - 1; y++) switch (y) {
        case 0:
            g = e[y + 1].x - e[y].x, m = e[y + 1].y - e[y].y, d.x = m * 1, d.y = -g, d.z = m * 0, _.copy(d), d.normalize(), l.push(d.x, d.y, d.z);
            break;
        case e.length - 1:
            l.push(_.x, _.y, _.z);
            break;
        default:
            g = e[y + 1].x - e[y].x, m = e[y + 1].y - e[y].y, d.x = m * 1, d.y = -g, d.z = m * 0, p.copy(d), d.x += _.x, d.y += _.y, d.z += _.z, d.normalize(), l.push(d.x, d.y, d.z), _.copy(p)
        }
        for (let y = 0; y <= t; y++) {
            const v = i + y * u * r,
                x = Math.sin(v),
                C = Math.cos(v);
            for (let S = 0; S <= e.length - 1; S++) {
                h.x = e[S].x * x, h.y = e[S].y, h.z = e[S].x * C, o.push(h.x, h.y, h.z), f.x = y / t, f.y = S / (e.length - 1), a.push(f.x, f.y);
                const R = l[3 * S + 0] * x,
                    F = l[3 * S + 1],
                    T = l[3 * S + 0] * C;
                c.push(R, F, T)
            }
        }
        for (let y = 0; y < t; y++)
            for (let v = 0; v < e.length - 1; v++) {
                const x = v + y * e.length,
                    C = x,
                    S = x + e.length,
                    R = x + e.length + 1,
                    F = x + 1;
                s.push(C, S, F), s.push(R, F, S)
            }
        this.setIndex(s), this.setAttribute("position", new Ge(o, 3)), this.setAttribute("uv", new Ge(a, 2)), this.setAttribute("normal", new Ge(c, 3))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Al(e.points, e.segments, e.phiStart, e.phiLength)
    }
}
class lh extends Al {
    constructor(e = 1, t = 1, i = 4, r = 8) {
        const s = new gu;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            length: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new lh(e.radius, e.length, e.capSegments, e.radialSegments)
    }
}
class Rl extends ht {
    constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
        super(), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        }, t = Math.max(3, t);
        const s = [],
            o = [],
            a = [],
            l = [],
            c = new L,
            u = new ue;
        o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5);
        for (let h = 0, f = 3; h <= t; h++, f += 3) {
            const d = i + h / t * r;
            c.x = e * Math.cos(d), c.y = e * Math.sin(d), o.push(c.x, c.y, c.z), a.push(0, 0, 1), u.x = (o[f] / e + 1) / 2, u.y = (o[f + 1] / e + 1) / 2, l.push(u.x, u.y)
        }
        for (let h = 1; h <= t; h++) s.push(h, h + 1, 0);
        this.setIndex(s), this.setAttribute("position", new Ge(o, 3)), this.setAttribute("normal", new Ge(a, 3)), this.setAttribute("uv", new Ge(l, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Rl(e.radius, e.segments, e.thetaStart, e.thetaLength)
    }
}
class Cl extends ht {
    constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        r = Math.floor(r), s = Math.floor(s);
        const u = [],
            h = [],
            f = [],
            d = [];
        let p = 0;
        const _ = [],
            g = i / 2;
        let m = 0;
        y(), o === !1 && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(u), this.setAttribute("position", new Ge(h, 3)), this.setAttribute("normal", new Ge(f, 3)), this.setAttribute("uv", new Ge(d, 2));

        function y() {
            const x = new L,
                C = new L;
            let S = 0;
            const R = (t - e) / i;
            for (let F = 0; F <= s; F++) {
                const T = [],
                    A = F / s,
                    G = A * (t - e) + e;
                for (let ee = 0; ee <= r; ee++) {
                    const he = ee / r,
                        B = he * l + a,
                        V = Math.sin(B),
                        q = Math.cos(B);
                    C.x = G * V, C.y = -A * i + g, C.z = G * q, h.push(C.x, C.y, C.z), x.set(V, R, q).normalize(), f.push(x.x, x.y, x.z), d.push(he, 1 - A), T.push(p++)
                }
                _.push(T)
            }
            for (let F = 0; F < r; F++)
                for (let T = 0; T < s; T++) {
                    const A = _[T][F],
                        G = _[T + 1][F],
                        ee = _[T + 1][F + 1],
                        he = _[T][F + 1];
                    u.push(A, G, he), u.push(G, ee, he), S += 6
                }
            c.addGroup(m, S, 0), m += S
        }

        function v(x) {
            const C = p,
                S = new ue,
                R = new L;
            let F = 0;
            const T = x === !0 ? e : t,
                A = x === !0 ? 1 : -1;
            for (let ee = 1; ee <= r; ee++) h.push(0, g * A, 0), f.push(0, A, 0), d.push(.5, .5), p++;
            const G = p;
            for (let ee = 0; ee <= r; ee++) {
                const B = ee / r * l + a,
                    V = Math.cos(B),
                    q = Math.sin(B);
                R.x = T * q, R.y = g * A, R.z = T * V, h.push(R.x, R.y, R.z), f.push(0, A, 0), S.x = V * .5 + .5, S.y = q * .5 * A + .5, d.push(S.x, S.y), p++
            }
            for (let ee = 0; ee < r; ee++) {
                const he = C + ee,
                    B = G + ee;
                x === !0 ? u.push(B, B + 1, he) : u.push(B + 1, B, he), F += 3
            }
            c.addGroup(m, F, x === !0 ? 1 : 2), m += F
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Cl(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class ch extends Cl {
    constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
        super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new ch(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class br extends ht {
    constructor(e = [], t = [], i = 1, r = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = [],
            o = [];
        a(r), c(i), u(), this.setAttribute("position", new Ge(s, 3)), this.setAttribute("normal", new Ge(s.slice(), 3)), this.setAttribute("uv", new Ge(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();

        function a(y) {
            const v = new L,
                x = new L,
                C = new L;
            for (let S = 0; S < t.length; S += 3) d(t[S + 0], v), d(t[S + 1], x), d(t[S + 2], C), l(v, x, C, y)
        }

        function l(y, v, x, C) {
            const S = C + 1,
                R = [];
            for (let F = 0; F <= S; F++) {
                R[F] = [];
                const T = y.clone().lerp(x, F / S),
                    A = v.clone().lerp(x, F / S),
                    G = S - F;
                for (let ee = 0; ee <= G; ee++) ee === 0 && F === S ? R[F][ee] = T : R[F][ee] = T.clone().lerp(A, ee / G)
            }
            for (let F = 0; F < S; F++)
                for (let T = 0; T < 2 * (S - F) - 1; T++) {
                    const A = Math.floor(T / 2);
                    T % 2 === 0 ? (f(R[F][A + 1]), f(R[F + 1][A]), f(R[F][A])) : (f(R[F][A + 1]), f(R[F + 1][A + 1]), f(R[F + 1][A]))
                }
        }

        function c(y) {
            const v = new L;
            for (let x = 0; x < s.length; x += 3) v.x = s[x + 0], v.y = s[x + 1], v.z = s[x + 2], v.normalize().multiplyScalar(y), s[x + 0] = v.x, s[x + 1] = v.y, s[x + 2] = v.z
        }

        function u() {
            const y = new L;
            for (let v = 0; v < s.length; v += 3) {
                y.x = s[v + 0], y.y = s[v + 1], y.z = s[v + 2];
                const x = g(y) / 2 / Math.PI + .5,
                    C = m(y) / Math.PI + .5;
                o.push(x, 1 - C)
            }
            p(), h()
        }

        function h() {
            for (let y = 0; y < o.length; y += 6) {
                const v = o[y + 0],
                    x = o[y + 2],
                    C = o[y + 4],
                    S = Math.max(v, x, C),
                    R = Math.min(v, x, C);
                S > .9 && R < .1 && (v < .2 && (o[y + 0] += 1), x < .2 && (o[y + 2] += 1), C < .2 && (o[y + 4] += 1))
            }
        }

        function f(y) {
            s.push(y.x, y.y, y.z)
        }

        function d(y, v) {
            const x = y * 3;
            v.x = e[x + 0], v.y = e[x + 1], v.z = e[x + 2]
        }

        function p() {
            const y = new L,
                v = new L,
                x = new L,
                C = new L,
                S = new ue,
                R = new ue,
                F = new ue;
            for (let T = 0, A = 0; T < s.length; T += 9, A += 6) {
                y.set(s[T + 0], s[T + 1], s[T + 2]), v.set(s[T + 3], s[T + 4], s[T + 5]), x.set(s[T + 6], s[T + 7], s[T + 8]), S.set(o[A + 0], o[A + 1]), R.set(o[A + 2], o[A + 3]), F.set(o[A + 4], o[A + 5]), C.copy(y).add(v).add(x).divideScalar(3);
                const G = g(C);
                _(S, A + 0, y, G), _(R, A + 2, v, G), _(F, A + 4, x, G)
            }
        }

        function _(y, v, x, C) {
            C < 0 && y.x === 1 && (o[v] = y.x - 1), x.x === 0 && x.z === 0 && (o[v] = C / 2 / Math.PI + .5)
        }

        function g(y) {
            return Math.atan2(y.z, -y.x)
        }

        function m(y) {
            return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new br(e.vertices, e.indices, e.radius, e.details)
    }
}
class uh extends br {
    constructor(e = 1, t = 0) {
        const i = (1 + Math.sqrt(5)) / 2,
            r = 1 / i,
            s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new uh(e.radius, e.detail)
    }
}
const ya = new L,
    xa = new L,
    Bc = new L,
    Ma = new gn;
class sA extends ht {
    constructor(e = null, t = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
                geometry: e,
                thresholdAngle: t
            }, e !== null) {
            const r = Math.pow(10, 4),
                s = Math.cos(ls * t),
                o = e.getIndex(),
                a = e.getAttribute("position"),
                l = o ? o.count : a.count,
                c = [0, 0, 0],
                u = ["a", "b", "c"],
                h = new Array(3),
                f = {},
                d = [];
            for (let p = 0; p < l; p += 3) {
                o ? (c[0] = o.getX(p), c[1] = o.getX(p + 1), c[2] = o.getX(p + 2)) : (c[0] = p, c[1] = p + 1, c[2] = p + 2);
                const {
                    a: _,
                    b: g,
                    c: m
                } = Ma;
                if (_.fromBufferAttribute(a, c[0]), g.fromBufferAttribute(a, c[1]), m.fromBufferAttribute(a, c[2]), Ma.getNormal(Bc), h[0] = `${Math.round(_.x*r)},${Math.round(_.y*r)},${Math.round(_.z*r)}`, h[1] = `${Math.round(g.x*r)},${Math.round(g.y*r)},${Math.round(g.z*r)}`, h[2] = `${Math.round(m.x*r)},${Math.round(m.y*r)},${Math.round(m.z*r)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let y = 0; y < 3; y++) {
                        const v = (y + 1) % 3,
                            x = h[y],
                            C = h[v],
                            S = Ma[u[y]],
                            R = Ma[u[v]],
                            F = `${x}_${C}`,
                            T = `${C}_${x}`;
                        T in f && f[T] ? (Bc.dot(f[T].normal) <= s && (d.push(S.x, S.y, S.z), d.push(R.x, R.y, R.z)), f[T] = null) : F in f || (f[F] = {
                            index0: c[y],
                            index1: c[v],
                            normal: Bc.clone()
                        })
                    }
            }
            for (const p in f)
                if (f[p]) {
                    const {
                        index0: _,
                        index1: g
                    } = f[p];
                    ya.fromBufferAttribute(a, _), xa.fromBufferAttribute(a, g), d.push(ya.x, ya.y, ya.z), d.push(xa.x, xa.y, xa.z)
                } this.setAttribute("position", new Ge(d, 3))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
}
class hh extends gu {
    constructor(e) {
        super(e), this.uuid = Rn(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e), this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new gu().fromJSON(r))
        }
        return this
    }
}
const oA = {
    triangulate: function (n, e, t = 2) {
        const i = e && e.length,
            r = i ? e[0] * t : n.length;
        let s = i_(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, c, u, h, f, d;
        if (i && (s = hA(n, e, s, t)), n.length > 80 * t) {
            a = c = n[0], l = u = n[1];
            for (let p = t; p < r; p += t) h = n[p], f = n[p + 1], h < a && (a = h), f < l && (l = f), h > c && (c = h), f > u && (u = f);
            d = Math.max(c - a, u - l), d = d !== 0 ? 32767 / d : 0
        }
        return vo(s, o, t, a, l, d, 0), o
    }
};

function i_(n, e, t, i, r) {
    let s, o;
    if (r === bA(n, e, t, i) > 0)
        for (s = e; s < t; s += i) o = Ap(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i) o = Ap(s, n[s], n[s + 1], o);
    return o && Pl(o, o.next) && (xo(o), o = o.next), o
}

function mr(n, e) {
    if (!n) return n;
    e || (e = n);
    let t = n,
        i;
    do
        if (i = !1, !t.steiner && (Pl(t, t.next) || Tt(t.prev, t, t.next) === 0)) {
            if (xo(t), t = e = t.prev, t === t.next) break;
            i = !0
        } else t = t.next; while (i || t !== e);
    return e
}

function vo(n, e, t, i, r, s, o) {
    if (!n) return;
    !o && s && gA(n, i, r, s);
    let a = n,
        l, c;
    for (; n.prev !== n.next;) {
        if (l = n.prev, c = n.next, s ? lA(n, i, r, s) : aA(n)) {
            e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(c.i / t | 0), xo(n), n = c.next, a = c.next;
            continue
        }
        if (n = c, n === a) {
            o ? o === 1 ? (n = cA(mr(n), e, t), vo(n, e, t, i, r, s, 2)) : o === 2 && uA(n, e, t, i, r, s) : vo(mr(n), e, t, i, r, s, 1);
            break
        }
    }
}

function aA(n) {
    const e = n.prev,
        t = n,
        i = n.next;
    if (Tt(e, t, i) >= 0) return !1;
    const r = e.x,
        s = t.x,
        o = i.x,
        a = e.y,
        l = t.y,
        c = i.y,
        u = r < s ? r < o ? r : o : s < o ? s : o,
        h = a < l ? a < c ? a : c : l < c ? l : c,
        f = r > s ? r > o ? r : o : s > o ? s : o,
        d = a > l ? a > c ? a : c : l > c ? l : c;
    let p = i.next;
    for (; p !== e;) {
        if (p.x >= u && p.x <= f && p.y >= h && p.y <= d && ns(r, a, s, l, o, c, p.x, p.y) && Tt(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function lA(n, e, t, i) {
    const r = n.prev,
        s = n,
        o = n.next;
    if (Tt(r, s, o) >= 0) return !1;
    const a = r.x,
        l = s.x,
        c = o.x,
        u = r.y,
        h = s.y,
        f = o.y,
        d = a < l ? a < c ? a : c : l < c ? l : c,
        p = u < h ? u < f ? u : f : h < f ? h : f,
        _ = a > l ? a > c ? a : c : l > c ? l : c,
        g = u > h ? u > f ? u : f : h > f ? h : f,
        m = _u(d, p, e, t, i),
        y = _u(_, g, e, t, i);
    let v = n.prevZ,
        x = n.nextZ;
    for (; v && v.z >= m && x && x.z <= y;) {
        if (v.x >= d && v.x <= _ && v.y >= p && v.y <= g && v !== r && v !== o && ns(a, u, l, h, c, f, v.x, v.y) && Tt(v.prev, v, v.next) >= 0 || (v = v.prevZ, x.x >= d && x.x <= _ && x.y >= p && x.y <= g && x !== r && x !== o && ns(a, u, l, h, c, f, x.x, x.y) && Tt(x.prev, x, x.next) >= 0)) return !1;
        x = x.nextZ
    }
    for (; v && v.z >= m;) {
        if (v.x >= d && v.x <= _ && v.y >= p && v.y <= g && v !== r && v !== o && ns(a, u, l, h, c, f, v.x, v.y) && Tt(v.prev, v, v.next) >= 0) return !1;
        v = v.prevZ
    }
    for (; x && x.z <= y;) {
        if (x.x >= d && x.x <= _ && x.y >= p && x.y <= g && x !== r && x !== o && ns(a, u, l, h, c, f, x.x, x.y) && Tt(x.prev, x, x.next) >= 0) return !1;
        x = x.nextZ
    }
    return !0
}

function cA(n, e, t) {
    let i = n;
    do {
        const r = i.prev,
            s = i.next.next;
        !Pl(r, s) && r_(r, i, i.next, s) && yo(r, s) && yo(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), xo(i), xo(i.next), i = n = s), i = i.next
    } while (i !== n);
    return mr(i)
}

function uA(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && yA(o, a)) {
                let l = s_(o, a);
                o = mr(o, o.next), l = mr(l, l.next), vo(o, e, t, i, r, s, 0), vo(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}

function hA(n, e, t, i) {
    const r = [];
    let s, o, a, l, c;
    for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : n.length, c = i_(n, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(vA(c));
    for (r.sort(fA), s = 0; s < r.length; s++) t = dA(r[s], t);
    return t
}

function fA(n, e) {
    return n.x - e.x
}

function dA(n, e) {
    const t = pA(n, e);
    if (!t) return e;
    const i = s_(t, n);
    return mr(i, i.next), mr(t, t.next)
}

function pA(n, e) {
    let t = e,
        i = -1 / 0,
        r;
    const s = n.x,
        o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const f = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (f <= s && f > i && (i = f, r = t.x < t.next.x ? t : t.next, f === s)) return r
        }
        t = t.next
    } while (t !== e);
    if (!r) return null;
    const a = r,
        l = r.x,
        c = r.y;
    let u = 1 / 0,
        h;
    t = r;
    do s >= t.x && t.x >= l && s !== t.x && ns(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), yo(t, n) && (h < u || h === u && (t.x > r.x || t.x === r.x && mA(r, t))) && (r = t, u = h)), t = t.next; while (t !== a);
    return r
}

function mA(n, e) {
    return Tt(n.prev, n, e.prev) < 0 && Tt(e.next, n, n.next) < 0
}

function gA(n, e, t, i) {
    let r = n;
    do r.z === 0 && (r.z = _u(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== n);
    r.prevZ.nextZ = null, r.prevZ = null, _A(r)
}

function _A(n) {
    let e, t, i, r, s, o, a, l, c = 1;
    do {
        for (t = n, n = null, s = null, o = 0; t;) {
            for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++);
            for (l = c; a > 0 || l > 0 && i;) a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
            t = i
        }
        s.nextZ = null, c *= 2
    } while (o > 1);
    return n
}

function _u(n, e, t, i, r) {
    return n = (n - t) * r | 0, e = (e - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1
}

function vA(n) {
    let e = n,
        t = n;
    do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n);
    return t
}

function ns(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}

function yA(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !xA(n, e) && (yo(n, e) && yo(e, n) && MA(n, e) && (Tt(n.prev, n, e.prev) || Tt(n, e.prev, e)) || Pl(n, e) && Tt(n.prev, n, n.next) > 0 && Tt(e.prev, e, e.next) > 0)
}

function Tt(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}

function Pl(n, e) {
    return n.x === e.x && n.y === e.y
}

function r_(n, e, t, i) {
    const r = Sa(Tt(n, e, t)),
        s = Sa(Tt(n, e, i)),
        o = Sa(Tt(t, i, n)),
        a = Sa(Tt(t, i, e));
    return !!(r !== s && o !== a || r === 0 && ba(n, t, e) || s === 0 && ba(n, i, e) || o === 0 && ba(t, n, i) || a === 0 && ba(t, e, i))
}

function ba(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}

function Sa(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}

function xA(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && r_(t, t.next, n, e)) return !0;
        t = t.next
    } while (t !== n);
    return !1
}

function yo(n, e) {
    return Tt(n.prev, n, n.next) < 0 ? Tt(n, e, n.next) >= 0 && Tt(n, n.prev, e) >= 0 : Tt(n, e, n.prev) < 0 || Tt(n, n.next, e) < 0
}

function MA(n, e) {
    let t = n,
        i = !1;
    const r = (n.x + e.x) / 2,
        s = (n.y + e.y) / 2;
    do t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next; while (t !== n);
    return i
}

function s_(n, e) {
    const t = new vu(n.i, n.x, n.y),
        i = new vu(e.i, e.x, e.y),
        r = n.next,
        s = e.prev;
    return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i
}

function Ap(n, e, t, i) {
    const r = new vu(n, e, t);
    return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
}

function xo(n) {
    n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
}

function vu(n, e, t) {
    this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function bA(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i) r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s;
    return r
}
class Fi {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return Fi.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = [],
            r = [],
            s = [];
        Rp(e), Cp(i, e);
        let o = e.length;
        t.forEach(Rp);
        for (let l = 0; l < t.length; l++) r.push(o), o += t[l].length, Cp(i, t[l]);
        const a = oA.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
        return s
    }
}

function Rp(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}

function Cp(n, e) {
    for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y)
}
class fh extends ht {
    constructor(e = new hh([new ue(.5, .5), new ue(-.5, .5), new ue(-.5, -.5), new ue(.5, -.5)]), t = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        const i = this,
            r = [],
            s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new Ge(r, 3)), this.setAttribute("uv", new Ge(s, 2)), this.computeVertexNormals();

        function o(a) {
            const l = [],
                c = t.curveSegments !== void 0 ? t.curveSegments : 12,
                u = t.steps !== void 0 ? t.steps : 1,
                h = t.depth !== void 0 ? t.depth : 1;
            let f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                d = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
                p = t.bevelSize !== void 0 ? t.bevelSize : d - .1,
                _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const m = t.extrudePath,
                y = t.UVGenerator !== void 0 ? t.UVGenerator : SA;
            let v, x = !1,
                C, S, R, F;
            m && (v = m.getSpacedPoints(u), x = !0, f = !1, C = m.computeFrenetFrames(u, !1), S = new L, R = new L, F = new L), f || (g = 0, d = 0, p = 0, _ = 0);
            const T = a.extractPoints(c);
            let A = T.shape;
            const G = T.holes;
            if (!Fi.isClockWise(A)) {
                A = A.reverse();
                for (let I = 0, w = G.length; I < w; I++) {
                    const E = G[I];
                    Fi.isClockWise(E) && (G[I] = E.reverse())
                }
            }
            const he = Fi.triangulateShape(A, G),
                B = A;
            for (let I = 0, w = G.length; I < w; I++) {
                const E = G[I];
                A = A.concat(E)
            }

            function V(I, w, E) {
                return w || console.error("THREE.ExtrudeGeometry: vec does not exist"), I.clone().addScaledVector(w, E)
            }
            const q = A.length,
                j = he.length;

            function J(I, w, E) {
                let N, U, W;
                const Y = I.x - w.x,
                    b = I.y - w.y,
                    M = E.x - I.x,
                    D = E.y - I.y,
                    z = Y * Y + b * b,
                    $ = Y * D - b * M;
                if (Math.abs($) > Number.EPSILON) {
                    const K = Math.sqrt(z),
                        fe = Math.sqrt(M * M + D * D),
                        se = w.x - b / K,
                        ge = w.y + Y / K,
                        Ee = E.x - D / fe,
                        De = E.y + M / fe,
                        oe = ((Ee - se) * D - (De - ge) * M) / (Y * D - b * M);
                    N = se + Y * oe - I.x, U = ge + b * oe - I.y;
                    const Be = N * N + U * U;
                    if (Be <= 2) return new ue(N, U);
                    W = Math.sqrt(Be / 2)
                } else {
                    let K = !1;
                    Y > Number.EPSILON ? M > Number.EPSILON && (K = !0) : Y < -Number.EPSILON ? M < -Number.EPSILON && (K = !0) : Math.sign(b) === Math.sign(D) && (K = !0), K ? (N = -b, U = Y, W = Math.sqrt(z)) : (N = Y, U = b, W = Math.sqrt(z / 2))
                }
                return new ue(N / W, U / W)
            }
            const ie = [];
            for (let I = 0, w = B.length, E = w - 1, N = I + 1; I < w; I++, E++, N++) E === w && (E = 0), N === w && (N = 0), ie[I] = J(B[I], B[E], B[N]);
            const pe = [];
            let de, xe = ie.concat();
            for (let I = 0, w = G.length; I < w; I++) {
                const E = G[I];
                de = [];
                for (let N = 0, U = E.length, W = U - 1, Y = N + 1; N < U; N++, W++, Y++) W === U && (W = 0), Y === U && (Y = 0), de[N] = J(E[N], E[W], E[Y]);
                pe.push(de), xe = xe.concat(de)
            }
            for (let I = 0; I < g; I++) {
                const w = I / g,
                    E = d * Math.cos(w * Math.PI / 2),
                    N = p * Math.sin(w * Math.PI / 2) + _;
                for (let U = 0, W = B.length; U < W; U++) {
                    const Y = V(B[U], ie[U], N);
                    H(Y.x, Y.y, -E)
                }
                for (let U = 0, W = G.length; U < W; U++) {
                    const Y = G[U];
                    de = pe[U];
                    for (let b = 0, M = Y.length; b < M; b++) {
                        const D = V(Y[b], de[b], N);
                        H(D.x, D.y, -E)
                    }
                }
            }
            const te = p + _;
            for (let I = 0; I < q; I++) {
                const w = f ? V(A[I], xe[I], te) : A[I];
                x ? (R.copy(C.normals[0]).multiplyScalar(w.x), S.copy(C.binormals[0]).multiplyScalar(w.y), F.copy(v[0]).add(R).add(S), H(F.x, F.y, F.z)) : H(w.x, w.y, 0)
            }
            for (let I = 1; I <= u; I++)
                for (let w = 0; w < q; w++) {
                    const E = f ? V(A[w], xe[w], te) : A[w];
                    x ? (R.copy(C.normals[I]).multiplyScalar(E.x), S.copy(C.binormals[I]).multiplyScalar(E.y), F.copy(v[I]).add(R).add(S), H(F.x, F.y, F.z)) : H(E.x, E.y, h / u * I)
                }
            for (let I = g - 1; I >= 0; I--) {
                const w = I / g,
                    E = d * Math.cos(w * Math.PI / 2),
                    N = p * Math.sin(w * Math.PI / 2) + _;
                for (let U = 0, W = B.length; U < W; U++) {
                    const Y = V(B[U], ie[U], N);
                    H(Y.x, Y.y, h + E)
                }
                for (let U = 0, W = G.length; U < W; U++) {
                    const Y = G[U];
                    de = pe[U];
                    for (let b = 0, M = Y.length; b < M; b++) {
                        const D = V(Y[b], de[b], N);
                        x ? H(D.x, D.y + v[u - 1].y, v[u - 1].x + E) : H(D.x, D.y, h + E)
                    }
                }
            }
            me(), Re();

            function me() {
                const I = r.length / 3;
                if (f) {
                    let w = 0,
                        E = q * w;
                    for (let N = 0; N < j; N++) {
                        const U = he[N];
                        ce(U[2] + E, U[1] + E, U[0] + E)
                    }
                    w = u + g * 2, E = q * w;
                    for (let N = 0; N < j; N++) {
                        const U = he[N];
                        ce(U[0] + E, U[1] + E, U[2] + E)
                    }
                } else {
                    for (let w = 0; w < j; w++) {
                        const E = he[w];
                        ce(E[2], E[1], E[0])
                    }
                    for (let w = 0; w < j; w++) {
                        const E = he[w];
                        ce(E[0] + q * u, E[1] + q * u, E[2] + q * u)
                    }
                }
                i.addGroup(I, r.length / 3 - I, 0)
            }

            function Re() {
                const I = r.length / 3;
                let w = 0;
                Pe(B, w), w += B.length;
                for (let E = 0, N = G.length; E < N; E++) {
                    const U = G[E];
                    Pe(U, w), w += U.length
                }
                i.addGroup(I, r.length / 3 - I, 1)
            }

            function Pe(I, w) {
                let E = I.length;
                for (; --E >= 0;) {
                    const N = E;
                    let U = E - 1;
                    U < 0 && (U = I.length - 1);
                    for (let W = 0, Y = u + g * 2; W < Y; W++) {
                        const b = q * W,
                            M = q * (W + 1),
                            D = w + N + b,
                            z = w + U + b,
                            $ = w + U + M,
                            K = w + N + M;
                        ae(D, z, $, K)
                    }
                }
            }

            function H(I, w, E) {
                l.push(I), l.push(w), l.push(E)
            }

            function ce(I, w, E) {
                le(I), le(w), le(E);
                const N = r.length / 3,
                    U = y.generateTopUV(i, r, N - 3, N - 2, N - 1);
                Ce(U[0]), Ce(U[1]), Ce(U[2])
            }

            function ae(I, w, E, N) {
                le(I), le(w), le(N), le(w), le(E), le(N);
                const U = r.length / 3,
                    W = y.generateSideWallUV(i, r, U - 6, U - 3, U - 2, U - 1);
                Ce(W[0]), Ce(W[1]), Ce(W[3]), Ce(W[1]), Ce(W[2]), Ce(W[3])
            }

            function le(I) {
                r.push(l[I * 3 + 0]), r.push(l[I * 3 + 1]), r.push(l[I * 3 + 2])
            }

            function Ce(I) {
                s.push(I.x), s.push(I.y)
            }
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes,
            i = this.parameters.options;
        return TA(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new nl[r.type]().fromJSON(r)), new fh(i, e.options)
    }
}
const SA = {
    generateTopUV: function (n, e, t, i, r) {
        const s = e[t * 3],
            o = e[t * 3 + 1],
            a = e[i * 3],
            l = e[i * 3 + 1],
            c = e[r * 3],
            u = e[r * 3 + 1];
        return [new ue(s, o), new ue(a, l), new ue(c, u)]
    },
    generateSideWallUV: function (n, e, t, i, r, s) {
        const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[i * 3],
            u = e[i * 3 + 1],
            h = e[i * 3 + 2],
            f = e[r * 3],
            d = e[r * 3 + 1],
            p = e[r * 3 + 2],
            _ = e[s * 3],
            g = e[s * 3 + 1],
            m = e[s * 3 + 2];
        return Math.abs(a - u) < Math.abs(o - c) ? [new ue(o, 1 - l), new ue(c, 1 - h), new ue(f, 1 - p), new ue(_, 1 - m)] : [new ue(a, 1 - l), new ue(u, 1 - h), new ue(d, 1 - p), new ue(g, 1 - m)]
    }
};

function TA(n, e, t) {
    if (t.shapes = [], Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        } else t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t
}
class dh extends br {
    constructor(e = 1, t = 0) {
        const i = (1 + Math.sqrt(5)) / 2,
            r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
            s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new dh(e.radius, e.detail)
    }
}
class ph extends br {
    constructor(e = 1, t = 0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new ph(e.radius, e.detail)
    }
}
class mh extends ht {
    constructor(e = .5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
        super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        }, i = Math.max(3, i), r = Math.max(1, r);
        const a = [],
            l = [],
            c = [],
            u = [];
        let h = e;
        const f = (t - e) / r,
            d = new L,
            p = new ue;
        for (let _ = 0; _ <= r; _++) {
            for (let g = 0; g <= i; g++) {
                const m = s + g / i * o;
                d.x = h * Math.cos(m), d.y = h * Math.sin(m), l.push(d.x, d.y, d.z), c.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, u.push(p.x, p.y)
            }
            h += f
        }
        for (let _ = 0; _ < r; _++) {
            const g = _ * (i + 1);
            for (let m = 0; m < i; m++) {
                const y = m + g,
                    v = y,
                    x = y + i + 1,
                    C = y + i + 2,
                    S = y + 1;
                a.push(v, x, S), a.push(x, C, S)
            }
        }
        this.setIndex(a), this.setAttribute("position", new Ge(l, 3)), this.setAttribute("normal", new Ge(c, 3)), this.setAttribute("uv", new Ge(u, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new mh(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
    }
}
class gh extends ht {
    constructor(e = new hh([new ue(0, .5), new ue(-.5, -.5), new ue(.5, -.5)]), t = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = [],
            r = [],
            s = [],
            o = [];
        let a = 0,
            l = 0;
        if (Array.isArray(e) === !1) c(e);
        else
            for (let u = 0; u < e.length; u++) c(e[u]), this.addGroup(a, l, u), a += l, l = 0;
        this.setIndex(i), this.setAttribute("position", new Ge(r, 3)), this.setAttribute("normal", new Ge(s, 3)), this.setAttribute("uv", new Ge(o, 2));

        function c(u) {
            const h = r.length / 3,
                f = u.extractPoints(t);
            let d = f.shape;
            const p = f.holes;
            Fi.isClockWise(d) === !1 && (d = d.reverse());
            for (let g = 0, m = p.length; g < m; g++) {
                const y = p[g];
                Fi.isClockWise(y) === !0 && (p[g] = y.reverse())
            }
            const _ = Fi.triangulateShape(d, p);
            for (let g = 0, m = p.length; g < m; g++) {
                const y = p[g];
                d = d.concat(y)
            }
            for (let g = 0, m = d.length; g < m; g++) {
                const y = d[g];
                r.push(y.x, y.y, 0), s.push(0, 0, 1), o.push(y.x, y.y)
            }
            for (let g = 0, m = _.length; g < m; g++) {
                const y = _[g],
                    v = y[0] + h,
                    x = y[1] + h,
                    C = y[2] + h;
                i.push(v, x, C), l += 3
            }
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes;
        return wA(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new gh(i, e.curveSegments)
    }
}

function wA(n, e) {
    if (e.shapes = [], Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        } else e.shapes.push(n.uuid);
    return e
}
class _h extends ht {
    constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const u = [],
            h = new L,
            f = new L,
            d = [],
            p = [],
            _ = [],
            g = [];
        for (let m = 0; m <= i; m++) {
            const y = [],
                v = m / i;
            let x = 0;
            m === 0 && o === 0 ? x = .5 / t : m === i && l === Math.PI && (x = -.5 / t);
            for (let C = 0; C <= t; C++) {
                const S = C / t;
                h.x = -e * Math.cos(r + S * s) * Math.sin(o + v * a), h.y = e * Math.cos(o + v * a), h.z = e * Math.sin(r + S * s) * Math.sin(o + v * a), p.push(h.x, h.y, h.z), f.copy(h).normalize(), _.push(f.x, f.y, f.z), g.push(S + x, 1 - v), y.push(c++)
            }
            u.push(y)
        }
        for (let m = 0; m < i; m++)
            for (let y = 0; y < t; y++) {
                const v = u[m][y + 1],
                    x = u[m][y],
                    C = u[m + 1][y],
                    S = u[m + 1][y + 1];
                (m !== 0 || o > 0) && d.push(v, x, S), (m !== i - 1 || l < Math.PI) && d.push(x, C, S)
            }
        this.setIndex(d), this.setAttribute("position", new Ge(p, 3)), this.setAttribute("normal", new Ge(_, 3)), this.setAttribute("uv", new Ge(g, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new _h(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
    }
}
class vh extends br {
    constructor(e = 1, t = 0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new vh(e.radius, e.detail)
    }
}
class yh extends ht {
    constructor(e = 1, t = .4, i = 12, r = 48, s = Math.PI * 2) {
        super(), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        }, i = Math.floor(i), r = Math.floor(r);
        const o = [],
            a = [],
            l = [],
            c = [],
            u = new L,
            h = new L,
            f = new L;
        for (let d = 0; d <= i; d++)
            for (let p = 0; p <= r; p++) {
                const _ = p / r * s,
                    g = d / i * Math.PI * 2;
                h.x = (e + t * Math.cos(g)) * Math.cos(_), h.y = (e + t * Math.cos(g)) * Math.sin(_), h.z = t * Math.sin(g), a.push(h.x, h.y, h.z), u.x = e * Math.cos(_), u.y = e * Math.sin(_), f.subVectors(h, u).normalize(), l.push(f.x, f.y, f.z), c.push(p / r), c.push(d / i)
            }
        for (let d = 1; d <= i; d++)
            for (let p = 1; p <= r; p++) {
                const _ = (r + 1) * d + p - 1,
                    g = (r + 1) * (d - 1) + p - 1,
                    m = (r + 1) * (d - 1) + p,
                    y = (r + 1) * d + p;
                o.push(_, g, y), o.push(g, m, y)
            }
        this.setIndex(o), this.setAttribute("position", new Ge(a, 3)), this.setAttribute("normal", new Ge(l, 3)), this.setAttribute("uv", new Ge(c, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new yh(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
    }
}
class xh extends ht {
    constructor(e = 1, t = .4, i = 64, r = 8, s = 2, o = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        }, i = Math.floor(i), r = Math.floor(r);
        const a = [],
            l = [],
            c = [],
            u = [],
            h = new L,
            f = new L,
            d = new L,
            p = new L,
            _ = new L,
            g = new L,
            m = new L;
        for (let v = 0; v <= i; ++v) {
            const x = v / i * s * Math.PI * 2;
            y(x, s, o, e, d), y(x + .01, s, o, e, p), g.subVectors(p, d), m.addVectors(p, d), _.crossVectors(g, m), m.crossVectors(_, g), _.normalize(), m.normalize();
            for (let C = 0; C <= r; ++C) {
                const S = C / r * Math.PI * 2,
                    R = -t * Math.cos(S),
                    F = t * Math.sin(S);
                h.x = d.x + (R * m.x + F * _.x), h.y = d.y + (R * m.y + F * _.y), h.z = d.z + (R * m.z + F * _.z), l.push(h.x, h.y, h.z), f.subVectors(h, d).normalize(), c.push(f.x, f.y, f.z), u.push(v / i), u.push(C / r)
            }
        }
        for (let v = 1; v <= i; v++)
            for (let x = 1; x <= r; x++) {
                const C = (r + 1) * (v - 1) + (x - 1),
                    S = (r + 1) * v + (x - 1),
                    R = (r + 1) * v + x,
                    F = (r + 1) * (v - 1) + x;
                a.push(C, S, F), a.push(S, R, F)
            }
        this.setIndex(a), this.setAttribute("position", new Ge(l, 3)), this.setAttribute("normal", new Ge(c, 3)), this.setAttribute("uv", new Ge(u, 2));

        function y(v, x, C, S, R) {
            const F = Math.cos(v),
                T = Math.sin(v),
                A = C / x * v,
                G = Math.cos(A);
            R.x = S * (2 + G) * .5 * F, R.y = S * (2 + G) * T * .5, R.z = S * Math.sin(A) * .5
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new xh(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
    }
}
class Mh extends ht {
    constructor(e = new t_(new L(-1, -1, 0), new L(-1, 1, 0), new L(1, 1, 0)), t = 64, i = 1, r = 8, s = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        const a = new L,
            l = new L,
            c = new ue;
        let u = new L;
        const h = [],
            f = [],
            d = [],
            p = [];
        _(), this.setIndex(p), this.setAttribute("position", new Ge(h, 3)), this.setAttribute("normal", new Ge(f, 3)), this.setAttribute("uv", new Ge(d, 2));

        function _() {
            for (let v = 0; v < t; v++) g(v);
            g(s === !1 ? t : 0), y(), m()
        }

        function g(v) {
            u = e.getPointAt(v / t, u);
            const x = o.normals[v],
                C = o.binormals[v];
            for (let S = 0; S <= r; S++) {
                const R = S / r * Math.PI * 2,
                    F = Math.sin(R),
                    T = -Math.cos(R);
                l.x = T * x.x + F * C.x, l.y = T * x.y + F * C.y, l.z = T * x.z + F * C.z, l.normalize(), f.push(l.x, l.y, l.z), a.x = u.x + i * l.x, a.y = u.y + i * l.y, a.z = u.z + i * l.z, h.push(a.x, a.y, a.z)
            }
        }

        function m() {
            for (let v = 1; v <= t; v++)
                for (let x = 1; x <= r; x++) {
                    const C = (r + 1) * (v - 1) + (x - 1),
                        S = (r + 1) * v + (x - 1),
                        R = (r + 1) * v + x,
                        F = (r + 1) * (v - 1) + x;
                    p.push(C, S, F), p.push(S, R, F)
                }
        }

        function y() {
            for (let v = 0; v <= t; v++)
                for (let x = 0; x <= r; x++) c.x = v / t, c.y = x / r, d.push(c.x, c.y)
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(), e
    }
    static fromJSON(e) {
        return new Mh(new nl[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
    }
}
class EA extends ht {
    constructor(e = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: e
            }, e !== null) {
            const t = [],
                i = new Set,
                r = new L,
                s = new L;
            if (e.index !== null) {
                const o = e.attributes.position,
                    a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let c = 0, u = l.length; c < u; ++c) {
                    const h = l[c],
                        f = h.start,
                        d = h.count;
                    for (let p = f, _ = f + d; p < _; p += 3)
                        for (let g = 0; g < 3; g++) {
                            const m = a.getX(p + g),
                                y = a.getX(p + (g + 1) % 3);
                            r.fromBufferAttribute(o, m), s.fromBufferAttribute(o, y), Pp(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let c = 0; c < 3; c++) {
                        const u = 3 * a + c,
                            h = 3 * a + (c + 1) % 3;
                        r.fromBufferAttribute(o, u), s.fromBufferAttribute(o, h), Pp(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new Ge(t, 3))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
}

function Pp(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
        r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0)
}
var Lp = Object.freeze({
    __proto__: null,
    BoxGeometry: Ms,
    CapsuleGeometry: lh,
    CircleGeometry: Rl,
    ConeGeometry: ch,
    CylinderGeometry: Cl,
    DodecahedronGeometry: uh,
    EdgesGeometry: sA,
    ExtrudeGeometry: fh,
    IcosahedronGeometry: dh,
    LatheGeometry: Al,
    OctahedronGeometry: ph,
    PlaneGeometry: Ao,
    PolyhedronGeometry: br,
    RingGeometry: mh,
    ShapeGeometry: gh,
    SphereGeometry: _h,
    TetrahedronGeometry: vh,
    TorusGeometry: yh,
    TorusKnotGeometry: xh,
    TubeGeometry: Mh,
    WireframeGeometry: EA
});
class o_ extends Vt {
    constructor(e) {
        super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Fe(0), this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
    }
}
class AA extends Qn {
    constructor(e) {
        super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
    }
}
class bh extends Vt {
    constructor(e) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Fe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xr, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class yu extends bh {
    constructor(e) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ue(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function () {
                return Lt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function (t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Fe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Fe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Fe(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
    }
}
class a_ extends Vt {
    constructor(e) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Fe(16777215), this.specular = new Fe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xr, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bl, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class RA extends Vt {
    constructor(e) {
        super(), this.isMeshToonMaterial = !0, this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Fe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xr, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
class CA extends Vt {
    constructor(e) {
        super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xr, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
    }
}
class l_ extends Vt {
    constructor(e) {
        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Fe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xr, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bl, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class PA extends Vt {
    constructor(e) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Fe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xr, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class LA extends us {
    constructor(e) {
        super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    }
}

function Ta(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}

function IA(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}

function DA(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length,
        i = new Array(t);
    for (let r = 0; r !== t; ++r) i[r] = r;
    return i.sort(e), i
}

function Ip(n, e, t) {
    const i = n.length,
        r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l) r[o++] = n[a + l]
    }
    return r
}

function c_(n, e, t, i) {
    let r = 1,
        s = n[0];
    for (; s !== void 0 && s[i] === void 0;) s = n[r++];
    if (s === void 0) return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++]; while (s !== void 0);
        else if (o.toArray !== void 0)
        do o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++]; while (s !== void 0);
    else
        do o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++]; while (s !== void 0)
}
class Ll {
    constructor(e, t, i, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex,
            r = t[i],
            s = t[i - 1];
        n: {
            e: {
                let o;t: {
                    i: if (!(e < r)) {
                        for (let a = i + 2;;) {
                            if (r === void 0) {
                                if (e < s) break i;
                                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                            }
                            if (i === a) break;
                            if (s = r, r = t[++i], e < r) break e
                        }
                        o = t.length;
                        break t
                    }if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2, s = a);
                        for (let l = i - 2;;) {
                            if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (i === l) break;
                            if (r = s, s = t[--i - 1], e >= s) break e
                        }
                        o = i, i = 0;
                        break t
                    }
                    break n
                }
                for (; i < o;) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0,
                this.copySampleValue_(0);
                if (r === void 0) return i = t.length,
                this._cachedIndex = i,
                this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r;
        for (let o = 0; o !== r; ++o) t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class OA extends Ll {
    constructor(e, t, i, r) {
        super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: gd,
            endingEnd: gd
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2,
            o = e + 1,
            a = r[s],
            l = r[o];
        if (a === void 0) switch (this.getSettings_().endingStart) {
        case _d:
            s = e, a = 2 * t - i;
            break;
        case vd:
            s = r.length - 2, a = t + r[s] - r[s + 1];
            break;
        default:
            s = e, a = i
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
        case _d:
            o = e, l = 2 * i - t;
            break;
        case vd:
            o = 1, l = i + r[1] - r[0];
            break;
        default:
            o = e - 1, l = t
        }
        const c = (i - t) * .5,
            u = this.valueSize;
        this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = s * u, this._offsetNext = o * u
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = this._offsetPrev,
            h = this._offsetNext,
            f = this._weightPrev,
            d = this._weightNext,
            p = (i - t) / (r - t),
            _ = p * p,
            g = _ * p,
            m = -f * g + 2 * f * _ - f * p,
            y = (1 + f) * g + (-1.5 - 2 * f) * _ + (-.5 + f) * p + 1,
            v = (-1 - d) * g + (1.5 + d) * _ + .5 * p,
            x = d * g - d * _;
        for (let C = 0; C !== a; ++C) s[C] = m * o[u + C] + y * o[c + C] + v * o[l + C] + x * o[h + C];
        return s
    }
}
class NA extends Ll {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = (i - t) / (r - t),
            h = 1 - u;
        for (let f = 0; f !== a; ++f) s[f] = o[c + f] * h + o[l + f] * u;
        return s
    }
}
class UA extends Ll {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class ti {
    constructor(e, t, i, r) {
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Ta(t, this.TimeBufferType), this.values = Ta(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: Ta(e.times, Array),
                values: Ta(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName, i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new UA(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new NA(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new OA(this.times, this.values, this.getValueSize(), e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case fo:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case po:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case rc:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this
        }
        return this.createInterpolant = t, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return fo;
        case this.InterpolantFactoryMethodLinear:
            return po;
        case this.InterpolantFactoryMethodSmooth:
            return rc
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times,
            r = i.length;
        let s = 0,
            o = r - 1;
        for (; s !== r && i[s] < e;) ++s;
        for (; o !== -1 && i[o] > t;) --o;
        if (++o, s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            const a = this.getValueSize();
            this.times = i.slice(s, o), this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        const i = this.times,
            r = this.values,
            s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
                break
            }
            o = l
        }
        if (r !== void 0 && IA(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
                const c = r[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice(),
            t = this.values.slice(),
            i = this.getValueSize(),
            r = this.getInterpolation() === rc,
            s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a],
                u = e[a + 1];
            if (c !== u && (a !== 1 || c !== e[0]))
                if (r) l = !0;
                else {
                    const h = a * i,
                        f = h - i,
                        d = h + i;
                    for (let p = 0; p !== i; ++p) {
                        const _ = t[h + p];
                        if (_ !== t[f + p] || _ !== t[d + p]) {
                            l = !0;
                            break
                        }
                    }
                } if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i,
                        f = o * i;
                    for (let d = 0; d !== i; ++d) t[f + d] = t[h + d]
                }++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * i)) : (this.times = e, this.values = t), this
    }
    clone() {
        const e = this.times.slice(),
            t = this.values.slice(),
            i = this.constructor,
            r = new i(this.name, e, t);
        return r.createInterpolant = this.createInterpolant, r
    }
}
ti.prototype.TimeBufferType = Float32Array;
ti.prototype.ValueBufferType = Float32Array;
ti.prototype.DefaultInterpolation = po;
class Ss extends ti {}
Ss.prototype.ValueTypeName = "bool";
Ss.prototype.ValueBufferType = Array;
Ss.prototype.DefaultInterpolation = fo;
Ss.prototype.InterpolantFactoryMethodLinear = void 0;
Ss.prototype.InterpolantFactoryMethodSmooth = void 0;
class u_ extends ti {}
u_.prototype.ValueTypeName = "color";
class il extends ti {}
il.prototype.ValueTypeName = "number";
class FA extends Ll {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (i - t) / (r - t);
        let c = e * a;
        for (let u = c + a; c !== u; c += 4) Zn.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class Ro extends ti {
    InterpolantFactoryMethodLinear(e) {
        return new FA(this.times, this.values, this.getValueSize(), e)
    }
}
Ro.prototype.ValueTypeName = "quaternion";
Ro.prototype.DefaultInterpolation = po;
Ro.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ts extends ti {}
Ts.prototype.ValueTypeName = "string";
Ts.prototype.ValueBufferType = Array;
Ts.prototype.DefaultInterpolation = fo;
Ts.prototype.InterpolantFactoryMethodLinear = void 0;
Ts.prototype.InterpolantFactoryMethodSmooth = void 0;
class rl extends ti {}
rl.prototype.ValueTypeName = "vector";
class BA {
    constructor(e, t = -1, i, r = iM) {
        this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Rn(), this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = [],
            i = e.tracks,
            r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o) t.push(zA(i[o]).scale(r));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return s.uuid = e.uuid, s
    }
    static toJSON(e) {
        const t = [],
            i = e.tracks,
            r = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
        for (let s = 0, o = i.length; s !== o; ++s) t.push(ti.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let l = [],
                c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            const u = DA(l);
            l = Ip(l, 1, u), c = Ip(c, 1, u), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new il(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / i))
        }
        return new this(e, -1, o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t) return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                u = c.name.match(s);
            if (u && u.length > 1) {
                const h = u[1];
                let f = r[h];
                f || (r[h] = f = []), f.push(c)
            }
        }
        const o = [];
        for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function (h, f, d, p, _) {
                if (d.length !== 0) {
                    const g = [],
                        m = [];
                    c_(d, g, m, p), g.length !== 0 && _.push(new h(f, g, m))
                }
            },
            r = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let h = 0; h < c.length; h++) {
            const f = c[h].keys;
            if (!(!f || f.length === 0))
                if (f[0].morphTargets) {
                    const d = {};
                    let p;
                    for (p = 0; p < f.length; p++)
                        if (f[p].morphTargets)
                            for (let _ = 0; _ < f[p].morphTargets.length; _++) d[f[p].morphTargets[_]] = -1;
                    for (const _ in d) {
                        const g = [],
                            m = [];
                        for (let y = 0; y !== f[p].morphTargets.length; ++y) {
                            const v = f[p];
                            g.push(v.time), m.push(v.morphTarget === _ ? 1 : 0)
                        }
                        r.push(new il(".morphTargetInfluence[" + _ + "]", g, m))
                    }
                    l = d.length * o
                } else {
                    const d = ".bones[" + t[h].name + "]";
                    i(rl, d + ".position", f, "pos", r), i(Ro, d + ".quaternion", f, "rot", r), i(rl, d + ".scale", f, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s, l, r, a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t, this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function kA(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return il;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return rl;
    case "color":
        return u_;
    case "quaternion":
        return Ro;
    case "bool":
    case "boolean":
        return Ss;
    case "string":
        return Ts
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}

function zA(n) {
    if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = kA(n.type);
    if (n.times === void 0) {
        const t = [],
            i = [];
        c_(n.keys, t, i, "value"), n.times = t, n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation)
}
const sl = {
    enabled: !1,
    files: {},
    add: function (n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function (n) {
        if (this.enabled !== !1) return this.files[n]
    },
    remove: function (n) {
        delete this.files[n]
    },
    clear: function () {
        this.files = {}
    }
};
class h_ {
    constructor(e, t, i) {
        const r = this;
        let s = !1,
            o = 0,
            a = 0,
            l;
        const c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (u) {
            a++, s === !1 && r.onStart !== void 0 && r.onStart(u, o, a), s = !0
        }, this.itemEnd = function (u) {
            o++, r.onProgress !== void 0 && r.onProgress(u, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad())
        }, this.itemError = function (u) {
            r.onError !== void 0 && r.onError(u)
        }, this.resolveURL = function (u) {
            return l ? l(u) : u
        }, this.setURLModifier = function (u) {
            return l = u, this
        }, this.addHandler = function (u, h) {
            return c.push(u, h), this
        }, this.removeHandler = function (u) {
            const h = c.indexOf(u);
            return h !== -1 && c.splice(h, 2), this
        }, this.getHandler = function (u) {
            for (let h = 0, f = c.length; h < f; h += 2) {
                const d = c[h],
                    p = c[h + 1];
                if (d.global && (d.lastIndex = 0), d.test(u)) return p
            }
            return null
        }
    }
}
const GA = new h_;
class Gi {
    constructor(e) {
        this.manager = e !== void 0 ? e : GA, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function (r, s) {
            i.load(e, r, t, s)
        })
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e, this
    }
    setWithCredentials(e) {
        return this.withCredentials = e, this
    }
    setPath(e) {
        return this.path = e, this
    }
    setResourcePath(e) {
        return this.resourcePath = e, this
    }
    setRequestHeader(e) {
        return this.requestHeader = e, this
    }
}
Gi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ui = {};
class VA extends Error {
    constructor(e, t) {
        super(e), this.response = t
    }
}
class Mo extends Gi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = sl.get(e);
        if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            t && t(s), this.manager.itemEnd(e)
        }, 0), s;
        if (ui[e] !== void 0) {
            ui[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        ui[e] = [], ui[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            a = this.mimeType,
            l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                const u = ui[e],
                    h = c.body.getReader(),
                    f = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
                    d = f ? parseInt(f) : 0,
                    p = d !== 0;
                let _ = 0;
                const g = new ReadableStream({
                    start(m) {
                        y();

                        function y() {
                            h.read().then(({
                                done: v,
                                value: x
                            }) => {
                                if (v) m.close();
                                else {
                                    _ += x.byteLength;
                                    const C = new ProgressEvent("progress", {
                                        lengthComputable: p,
                                        loaded: _,
                                        total: d
                                    });
                                    for (let S = 0, R = u.length; S < R; S++) {
                                        const F = u[S];
                                        F.onProgress && F.onProgress(C)
                                    }
                                    m.enqueue(x), y()
                                }
                            })
                        }
                    }
                });
                return new Response(g)
            } else throw new VA(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
        }).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(u => new DOMParser().parseFromString(u, a));
            case "json":
                return c.json();
            default:
                if (a === void 0) return c.text(); {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a),
                        f = h && h[1] ? h[1].toLowerCase() : void 0,
                        d = new TextDecoder(f);
                    return c.arrayBuffer().then(p => d.decode(p))
                }
            }
        }).then(c => {
            sl.add(e, c);
            const u = ui[e];
            delete ui[e];
            for (let h = 0, f = u.length; h < f; h++) {
                const d = u[h];
                d.onLoad && d.onLoad(c)
            }
        }).catch(c => {
            const u = ui[e];
            if (u === void 0) throw this.manager.itemError(e), c;
            delete ui[e];
            for (let h = 0, f = u.length; h < f; h++) {
                const d = u[h];
                d.onError && d.onError(c)
            }
            this.manager.itemError(e)
        }).finally(() => {
            this.manager.itemEnd(e)
        }), this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e, this
    }
    setMimeType(e) {
        return this.mimeType = e, this
    }
}
class xu extends Gi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = sl.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () {
            t && t(o), s.manager.itemEnd(e)
        }, 0), o;
        const a = go("img");

        function l() {
            u(), sl.add(e, this), t && t(this), s.manager.itemEnd(e)
        }

        function c(h) {
            u(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e)
        }

        function u() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
    }
}
class HA extends Gi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new zt,
            o = new xu(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) {
            s.image = a, s.needsUpdate = !0, t !== void 0 && t(s)
        }, i, r), s
    }
}
class Sr extends Mt {
    constructor(e, t = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new Fe(e), this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
    }
}
class WA extends Sr {
    constructor(e, t, i) {
        super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Mt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Fe(t)
    }
    copy(e, t) {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this
    }
}
const kc = new qe,
    Dp = new L,
    Op = new L;
class Sh {
    constructor(e) {
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ue(512, 512), this.map = null, this.mapPass = null, this.matrix = new qe, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new wl, this._frameExtents = new ue(1, 1), this._viewportCount = 1, this._viewports = [new pt(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera,
            i = this.matrix;
        Dp.setFromMatrixPosition(e.matrixWorld), t.position.copy(Dp), Op.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Op), t.updateMatrixWorld(), kc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(kc), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(kc)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
    }
}
class $A extends Sh {
    constructor() {
        super(new qt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera,
            i = gs * 2 * e.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e), this.focus = e.focus, this
    }
}
class XA extends Sr {
    constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
        super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Mt.DEFAULT_UP), this.updateMatrix(), this.target = new Mt, this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new $A
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
const Np = new qe,
    Gs = new L,
    zc = new L;
class qA extends Sh {
    constructor() {
        super(new qt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ue(4, 2), this._viewportCount = 6, this._viewports = [new pt(2, 1, 1, 1), new pt(0, 1, 1, 1), new pt(3, 1, 1, 1), new pt(1, 1, 1, 1), new pt(3, 0, 1, 1), new pt(1, 0, 1, 1)], this._cubeDirections = [new L(1, 0, 0), new L(-1, 0, 0), new L(0, 0, 1), new L(0, 0, -1), new L(0, 1, 0), new L(0, -1, 0)], this._cubeUps = [new L(0, 1, 0), new L(0, 1, 0), new L(0, 1, 0), new L(0, 1, 0), new L(0, 0, 1), new L(0, 0, -1)]
    }
    updateMatrices(e, t = 0) {
        const i = this.camera,
            r = this.matrix,
            s = e.distance || i.far;
        s !== i.far && (i.far = s, i.updateProjectionMatrix()), Gs.setFromMatrixPosition(e.matrixWorld), i.position.copy(Gs), zc.copy(i.position), zc.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(zc), i.updateMatrixWorld(), r.makeTranslation(-Gs.x, -Gs.y, -Gs.z), Np.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Np)
    }
}
class YA extends Sr {
    constructor(e, t, i = 0, r = 2) {
        super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new qA
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
    }
}
class KA extends Sh {
    constructor() {
        super(new Qu(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class f_ extends Sr {
    constructor(e, t) {
        super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Mt.DEFAULT_UP), this.updateMatrix(), this.target = new Mt, this.shadow = new KA
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
class d_ extends Sr {
    constructor(e, t) {
        super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}
class jA extends Sr {
    constructor(e, t, i = 10, r = 10) {
        super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e), this.width = e.width, this.height = e.height, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width, t.object.height = this.height, t
    }
}
class JA {
    constructor() {
        this.isSphericalHarmonics3 = !0, this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new L)
    }
    set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], .546274 * (i * i - r * r)), t
    }
    getIrradianceAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * r), t.addScaledVector(o[2], 2 * .511664 * s), t.addScaledVector(o[3], 2 * .511664 * i), t.addScaledVector(o[4], 2 * .429043 * i * r), t.addScaledVector(o[5], 2 * .429043 * r * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 2 * .429043 * i * s), t.addScaledVector(o[8], .429043 * (i * i - r * r)), t
    }
    add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t = 0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z;
        t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * s, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = .546274 * (i * i - r * r)
    }
}
class ZA extends Sr {
    constructor(e = new JA, t = 1) {
        super(void 0, t), this.isLightProbe = !0, this.sh = e
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this
    }
    fromJSON(e) {
        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(), t
    }
}
class Th extends Gi {
    constructor(e) {
        super(e), this.textures = {}
    }
    load(e, t, i, r) {
        const s = this,
            o = new Mo(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;

        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s]
        }
        const r = Th.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Fe().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {}, o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Fe().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new ue().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new L().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new pt().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new Qe().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new qe().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
            for (const s in e.extensions) r.extensions[s] = e.extensions[s];
        if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new ue().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new ue().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r
    }
    setTextures(e) {
        return this.textures = e, this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: o_,
            SpriteMaterial: Yg,
            RawShaderMaterial: AA,
            ShaderMaterial: Qn,
            PointsMaterial: ts,
            MeshPhysicalMaterial: yu,
            MeshStandardMaterial: bh,
            MeshPhongMaterial: a_,
            MeshToonMaterial: RA,
            MeshNormalMaterial: CA,
            MeshLambertMaterial: l_,
            MeshDepthMaterial: $g,
            MeshDistanceMaterial: Xg,
            MeshBasicMaterial: Ju,
            MeshMatcapMaterial: PA,
            LineDashedMaterial: LA,
            LineBasicMaterial: us,
            Material: Vt
        };
        return new t[e]
    }
}
class Up {
    static decodeText(e) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class QA extends ht {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e), this.instanceCount = e.instanceCount, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
    }
}
class e1 extends Gi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = new Mo(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {},
            i = {};

        function r(d, p) {
            if (t[p] !== void 0) return t[p];
            const g = d.interleavedBuffers[p],
                m = s(d, g.buffer),
                y = Jr(g.type, m),
                v = new qg(y, g.stride);
            return v.uuid = g.uuid, t[p] = v, v
        }

        function s(d, p) {
            if (i[p] !== void 0) return i[p];
            const g = d.arrayBuffers[p],
                m = new Uint32Array(g).buffer;
            return i[p] = m, m
        }
        const o = e.isInstancedBufferGeometry ? new QA : new ht,
            a = e.data.index;
        if (a !== void 0) {
            const d = Jr(a.type, a.array);
            o.setIndex(new ut(d, 1))
        }
        const l = e.data.attributes;
        for (const d in l) {
            const p = l[d];
            let _;
            if (p.isInterleavedBufferAttribute) {
                const g = r(e.data, p.data);
                _ = new ys(g, p.itemSize, p.offset, p.normalized)
            } else {
                const g = Jr(p.type, p.array),
                    m = p.isInstancedBufferAttribute ? _o : ut;
                _ = new m(g, p.itemSize, p.normalized)
            }
            p.name !== void 0 && (_.name = p.name), p.usage !== void 0 && _.setUsage(p.usage), o.setAttribute(d, _)
        }
        const c = e.data.morphAttributes;
        if (c)
            for (const d in c) {
                const p = c[d],
                    _ = [];
                for (let g = 0, m = p.length; g < m; g++) {
                    const y = p[g];
                    let v;
                    if (y.isInterleavedBufferAttribute) {
                        const x = r(e.data, y.data);
                        v = new ys(x, y.itemSize, y.offset, y.normalized)
                    } else {
                        const x = Jr(y.type, y.array);
                        v = new ut(x, y.itemSize, y.normalized)
                    }
                    y.name !== void 0 && (v.name = y.name), _.push(v)
                }
                o.morphAttributes[d] = _
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let d = 0, p = h.length; d !== p; ++d) {
                const _ = h[d];
                o.addGroup(_.start, _.count, _.materialIndex)
            }
        const f = e.data.boundingSphere;
        if (f !== void 0) {
            const d = new L;
            f.center !== void 0 && d.fromArray(f.center), o.boundingSphere = new an(d, f.radius)
        }
        return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    }
}
class t1 extends Gi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = this.path === "" ? Up.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Mo(this.manager);
        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (h) {
                r !== void 0 && r(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const u = c.metadata;
            if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(c, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this,
            r = this.path === "" ? Up.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new Mo(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t),
            a = JSON.parse(o),
            l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, r),
            o = this.parseImages(e.images, function () {
                t !== void 0 && t(c)
            }),
            a = this.parseTextures(e.textures, o),
            l = this.parseMaterials(e.materials, a),
            c = this.parseObject(e.object, s, l, a, i),
            u = this.parseSkeletons(e.skeletons, c);
        if (this.bindSkeletons(c, u), t !== void 0) {
            let h = !1;
            for (const f in o)
                if (o[f].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                } h === !1 && t(c)
        }
        return c
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            r = this.parseGeometries(e.geometries, i),
            s = await this.parseImagesAsync(e.images),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            l = this.parseObject(e.object, r, a, o, t),
            c = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, c), l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new hh().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {},
            r = {};
        if (t.traverse(function (s) {
                s.isBone && (r[s.uuid] = s)
            }), e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new rh().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new e1;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = r.parse(l);
                    break;
                default:
                    l.type in Lp ? a = Lp[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {},
            r = {};
        if (e !== void 0) {
            const s = new Th;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)), r[l.uuid] = i[l.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i],
                    s = BA.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this,
            r = {};
        let s;

        function o(l) {
            return i.manager.itemStart(l), s.load(l, function () {
                i.manager.itemEnd(l)
            }, void 0, function () {
                i.manager.itemError(l), i.manager.itemEnd(l)
            })
        }

        function a(l) {
            if (typeof l == "string") {
                const c = l,
                    u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
                return o(u)
            } else return l.data ? {
                data: Jr(l.type, l.data),
                width: l.width,
                height: l.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new h_(t);
            s = new xu(l), s.setCrossOrigin(this.crossOrigin);
            for (let c = 0, u = e.length; c < u; c++) {
                const h = e[c],
                    f = h.url;
                if (Array.isArray(f)) {
                    const d = [];
                    for (let p = 0, _ = f.length; p < _; p++) {
                        const g = f[p],
                            m = a(g);
                        m !== null && (m instanceof HTMLImageElement ? d.push(m) : d.push(new eo(m.data, m.width, m.height)))
                    }
                    r[h.uuid] = new ir(d)
                } else {
                    const d = a(h.url);
                    r[h.uuid] = new ir(d)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this,
            i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o,
                    l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(l)
            } else return o.data ? {
                data: Jr(o.type, o.data),
                width: o.width,
                height: o.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new xu(this.manager), r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o],
                    c = l.url;
                if (Array.isArray(c)) {
                    const u = [];
                    for (let h = 0, f = c.length; h < f; h++) {
                        const d = c[h],
                            p = await s(d);
                        p !== null && (p instanceof HTMLImageElement ? u.push(p) : u.push(new eo(p.data, p.width, p.height)))
                    }
                    i[l.uuid] = new ir(u)
                } else {
                    const u = await s(l.url);
                    i[l.uuid] = new ir(u)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image],
                    c = l.data;
                let u;
                Array.isArray(c) ? (u = new Zu, c.length === 6 && (u.needsUpdate = !0)) : (c && c.data ? u = new eo : u = new zt, c && (u.needsUpdate = !0)), u.source = l, u.uuid = a.uuid, a.name !== void 0 && (u.name = a.name), a.mapping !== void 0 && (u.mapping = i(a.mapping, n1)), a.channel !== void 0 && (u.channel = a.channel), a.offset !== void 0 && u.offset.fromArray(a.offset), a.repeat !== void 0 && u.repeat.fromArray(a.repeat), a.center !== void 0 && u.center.fromArray(a.center), a.rotation !== void 0 && (u.rotation = a.rotation), a.wrap !== void 0 && (u.wrapS = i(a.wrap[0], Fp), u.wrapT = i(a.wrap[1], Fp)), a.format !== void 0 && (u.format = a.format), a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat), a.type !== void 0 && (u.type = a.type), a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace), a.encoding !== void 0 && (u.encoding = a.encoding), a.minFilter !== void 0 && (u.minFilter = i(a.minFilter, Bp)), a.magFilter !== void 0 && (u.magFilter = i(a.magFilter, Bp)), a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy), a.flipY !== void 0 && (u.flipY = a.flipY), a.generateMipmaps !== void 0 && (u.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (u.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (u.compareFunction = a.compareFunction), a.userData !== void 0 && (u.userData = a.userData), r[a.uuid] = u
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;

        function a(f) {
            return t[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", f), t[f]
        }

        function l(f) {
            if (f !== void 0) {
                if (Array.isArray(f)) {
                    const d = [];
                    for (let p = 0, _ = f.length; p < _; p++) {
                        const g = f[p];
                        i[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), d.push(i[g])
                    }
                    return d
                }
                return i[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", f), i[f]
            }
        }

        function c(f) {
            return r[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", f), r[f]
        }
        let u, h;
        switch (e.type) {
        case "Scene":
            o = new vs, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Fe(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new ih(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new nh(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
            break;
        case "PerspectiveCamera":
            o = new qt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new Qu(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new d_(e.color, e.intensity);
            break;
        case "DirectionalLight":
            o = new f_(e.color, e.intensity);
            break;
        case "PointLight":
            o = new YA(e.color, e.intensity, e.distance, e.decay);
            break;
        case "RectAreaLight":
            o = new jA(e.color, e.intensity, e.width, e.height);
            break;
        case "SpotLight":
            o = new XA(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
            break;
        case "HemisphereLight":
            o = new WA(e.color, e.groundColor, e.intensity);
            break;
        case "LightProbe":
            o = new ZA().fromJSON(e);
            break;
        case "SkinnedMesh":
            u = a(e.geometry), h = l(e.material), o = new UE(u, h), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            u = a(e.geometry), h = l(e.material), o = new xt(u, h);
            break;
        case "InstancedMesh":
            u = a(e.geometry), h = l(e.material);
            const f = e.count,
                d = e.instanceMatrix,
                p = e.instanceColor;
            o = new kE(u, h, f), o.instanceMatrix = new _o(new Float32Array(d.array), 16), p !== void 0 && (o.instanceColor = new _o(new Float32Array(p.array), p.itemSize));
            break;
        case "BatchedMesh":
            u = a(e.geometry), h = l(e.material), o = new $E(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, h), o.geometry = u, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map(_ => {
                const g = new Mn;
                g.min.fromArray(_.boxMin), g.max.fromArray(_.boxMax);
                const m = new an;
                return m.radius = _.sphereRadius, m.center.fromArray(_.sphereCenter), {
                    boxInitialized: _.boxInitialized,
                    box: g,
                    sphereInitialized: _.sphereInitialized,
                    sphere: m
                }
            }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = c(e.matricesTexture.uuid);
            break;
        case "LOD":
            o = new OE;
            break;
        case "Line":
            o = new sh(a(e.geometry), l(e.material));
            break;
        case "LineLoop":
            o = new XE(a(e.geometry), l(e.material));
            break;
        case "LineSegments":
            o = new pu(a(e.geometry), l(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new Ua(a(e.geometry), l(e.material));
            break;
        case "Sprite":
            o = new DE(l(e.material));
            break;
        case "Group":
            o = new es;
            break;
        case "Bone":
            o = new jg;
            break;
        default:
            o = new Mt
        }
        if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
            const f = e.children;
            for (let d = 0; d < f.length; d++) o.add(this.parseObject(f[d], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const f = e.animations;
            for (let d = 0; d < f.length; d++) {
                const p = f[d];
                o.animations.push(s[p])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const f = e.levels;
            for (let d = 0; d < f.length; d++) {
                const p = f[d],
                    _ = o.getObjectByProperty("uuid", p.object);
                _ !== void 0 && o.addLevel(_, p.distance, p.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function (i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
}
const n1 = {
        UVMapping: Xu,
        CubeReflectionMapping: hr,
        CubeRefractionMapping: fr,
        EquirectangularReflectionMapping: Ya,
        EquirectangularRefractionMapping: Ka,
        CubeUVReflectionMapping: wo
    },
    Fp = {
        RepeatWrapping: co,
        ClampToEdgeWrapping: _n,
        MirroredRepeatWrapping: uo
    },
    Bp = {
        NearestFilter: It,
        NearestMipmapNearestFilter: ja,
        NearestMipmapLinearFilter: Js,
        LinearFilter: cn,
        LinearMipmapNearestFilter: qu,
        LinearMipmapLinearFilter: dr
    },
    wh = "\\[\\]\\.:\\/",
    i1 = new RegExp("[" + wh + "]", "g"),
    Eh = "[^" + wh + "]",
    r1 = "[^" + wh.replace("\\.", "") + "]",
    s1 = /((?:WC+[\/:])*)/.source.replace("WC", Eh),
    o1 = /(WCOD+)?/.source.replace("WCOD", r1),
    a1 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Eh),
    l1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Eh),
    c1 = new RegExp("^" + s1 + o1 + a1 + l1 + "$"),
    u1 = ["material", "materials", "bones", "map"];
class h1 {
    constructor(e, t, i) {
        const r = i || ot.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
            r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
    }
}
class ot {
    constructor(e, t, i) {
        this.path = t, this.parsedPath = i || ot.parseTrackName(t), this.node = ot.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new ot.Composite(e, t, i) : new ot(e, t, i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(i1, "")
    }
    static parseTrackName(e) {
        const t = c1.exec(e);
        if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            },
            r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            u1.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i
        }
        if (e.children) {
            const i = function (s) {
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (a.name === t || a.uuid === t) return a;
                        const l = i(a.children);
                        if (l) return l
                    }
                    return null
                },
                r = i(e.children);
            if (r) return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath,
            i = t.objectName,
            r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = ot.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let u = 0; u < e.length; u++)
                    if (e[u].name === c) {
                        c = u;
                        break
                    } break;
            case "map":
                if ("map" in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
ot.Composite = h1;
ot.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
ot.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
ot.prototype.GetterByBindingType = [ot.prototype._getValue_direct, ot.prototype._getValue_array, ot.prototype._getValue_arrayElement, ot.prototype._getValue_toArray];
ot.prototype.SetterByBindingTypeAndVersioning = [
    [ot.prototype._setValue_direct, ot.prototype._setValue_direct_setNeedsUpdate, ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [ot.prototype._setValue_array, ot.prototype._setValue_array_setNeedsUpdate, ot.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [ot.prototype._setValue_arrayElement, ot.prototype._setValue_arrayElement_setNeedsUpdate, ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [ot.prototype._setValue_fromArray, ot.prototype._setValue_fromArray_setNeedsUpdate, ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class Ah {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new Ah(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
class kp {
    constructor(e = 1, t = 0, i = 0) {
        return this.radius = e, this.phi = t, this.theta = i, this
    }
    set(e, t, i) {
        return this.radius = e, this.phi = t, this.theta = i, this
    }
    copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Lt(t / this.radius, -1, 1))), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: $u
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = $u);
const zp = {
        type: "change"
    },
    Gc = {
        type: "start"
    },
    Gp = {
        type: "end"
    },
    wa = new Eo,
    Vp = new Ci,
    f1 = Math.cos(70 * tl.DEG2RAD);
class d1 extends Mr {
    constructor(e, t) {
        super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new L, this.cursor = new L, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }, this.mouseButtons = {
            LEFT: wr.ROTATE,
            MIDDLE: wr.DOLLY,
            RIGHT: wr.PAN
        }, this.touches = {
            ONE: Er.ROTATE,
            TWO: Er.DOLLY_PAN
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
            return a.phi
        }, this.getAzimuthalAngle = function () {
            return a.theta
        }, this.getDistance = function () {
            return this.object.position.distanceTo(this.target)
        }, this.listenToKeyEvents = function (O) {
            O.addEventListener("keydown", K), this._domElementKeyEvents = O
        }, this.stopListenToKeyEvents = function () {
            this._domElementKeyEvents.removeEventListener("keydown", K), this._domElementKeyEvents = null
        }, this.saveState = function () {
            i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom
        }, this.reset = function () {
            i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(zp), i.update(), s = r.NONE
        }, this.update = function () {
            const O = new L,
                _e = new Zn().setFromUnitVectors(e.up, new L(0, 1, 0)),
                Me = _e.clone().invert(),
                ye = new L,
                Le = new Zn,
                ze = new L,
                et = 2 * Math.PI;
            return function (we = null) {
                const k = i.object.position;
                O.copy(k).sub(i.target), O.applyQuaternion(_e), a.setFromVector3(O), i.autoRotate && s === r.NONE && G(T(we)), i.enableDamping ? (a.theta += l.theta * i.dampingFactor, a.phi += l.phi * i.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
                let Se = i.minAzimuthAngle,
                    Te = i.maxAzimuthAngle;
                isFinite(Se) && isFinite(Te) && (Se < -Math.PI ? Se += et : Se > Math.PI && (Se -= et), Te < -Math.PI ? Te += et : Te > Math.PI && (Te -= et), Se <= Te ? a.theta = Math.max(Se, Math.min(Te, a.theta)) : a.theta = a.theta > (Se + Te) / 2 ? Math.max(Se, a.theta) : Math.min(Te, a.theta)), a.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, a.phi)), a.makeSafe(), i.enableDamping === !0 ? i.target.addScaledVector(u, i.dampingFactor) : i.target.add(u), i.target.sub(i.cursor), i.target.clampLength(i.minTargetRadius, i.maxTargetRadius), i.target.add(i.cursor), i.zoomToCursor && S || i.object.isOrthographicCamera ? a.radius = ie(a.radius) : a.radius = ie(a.radius * c), O.setFromSpherical(a), O.applyQuaternion(Me), k.copy(i.target).add(O), i.object.lookAt(i.target), i.enableDamping === !0 ? (l.theta *= 1 - i.dampingFactor, l.phi *= 1 - i.dampingFactor, u.multiplyScalar(1 - i.dampingFactor)) : (l.set(0, 0, 0), u.set(0, 0, 0));
                let ke = !1;
                if (i.zoomToCursor && S) {
                    let Ne = null;
                    if (i.object.isPerspectiveCamera) {
                        const st = O.length();
                        Ne = ie(st * c);
                        const at = st - Ne;
                        i.object.position.addScaledVector(x, at), i.object.updateMatrixWorld()
                    } else if (i.object.isOrthographicCamera) {
                        const st = new L(C.x, C.y, 0);
                        st.unproject(i.object), i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), i.object.updateProjectionMatrix(), ke = !0;
                        const at = new L(C.x, C.y, 0);
                        at.unproject(i.object), i.object.position.sub(at).add(st), i.object.updateMatrixWorld(), Ne = O.length()
                    } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), i.zoomToCursor = !1;
                    Ne !== null && (this.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(Ne).add(i.object.position) : (wa.origin.copy(i.object.position), wa.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(wa.direction)) < f1 ? e.lookAt(i.target) : (Vp.setFromNormalAndCoplanarPoint(i.object.up, i.target), wa.intersectPlane(Vp, i.target))))
                } else i.object.isOrthographicCamera && (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), i.object.updateProjectionMatrix(), ke = !0);
                return c = 1, S = !1, ke || ye.distanceToSquared(i.object.position) > o || 8 * (1 - Le.dot(i.object.quaternion)) > o || ze.distanceToSquared(i.target) > 0 ? (i.dispatchEvent(zp), ye.copy(i.object.position), Le.copy(i.object.quaternion), ze.copy(i.target), !0) : !1
            }
        }(), this.dispose = function () {
            i.domElement.removeEventListener("contextmenu", ge), i.domElement.removeEventListener("pointerdown", Y), i.domElement.removeEventListener("pointercancel", M), i.domElement.removeEventListener("wheel", $), i.domElement.removeEventListener("pointermove", b), i.domElement.removeEventListener("pointerup", M), i._domElementKeyEvents !== null && (i._domElementKeyEvents.removeEventListener("keydown", K), i._domElementKeyEvents = null)
        };
        const i = this,
            r = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
        let s = r.NONE;
        const o = 1e-6,
            a = new kp,
            l = new kp;
        let c = 1;
        const u = new L,
            h = new ue,
            f = new ue,
            d = new ue,
            p = new ue,
            _ = new ue,
            g = new ue,
            m = new ue,
            y = new ue,
            v = new ue,
            x = new L,
            C = new ue;
        let S = !1;
        const R = [],
            F = {};

        function T(O) {
            return O !== null ? 2 * Math.PI / 60 * i.autoRotateSpeed * O : 2 * Math.PI / 60 / 60 * i.autoRotateSpeed
        }

        function A(O) {
            const _e = Math.abs(O) / (100 * (window.devicePixelRatio | 0));
            return Math.pow(.95, i.zoomSpeed * _e)
        }

        function G(O) {
            l.theta -= O
        }

        function ee(O) {
            l.phi -= O
        }
        const he = function () {
                const O = new L;
                return function (Me, ye) {
                    O.setFromMatrixColumn(ye, 0), O.multiplyScalar(-Me), u.add(O)
                }
            }(),
            B = function () {
                const O = new L;
                return function (Me, ye) {
                    i.screenSpacePanning === !0 ? O.setFromMatrixColumn(ye, 1) : (O.setFromMatrixColumn(ye, 0), O.crossVectors(i.object.up, O)), O.multiplyScalar(Me), u.add(O)
                }
            }(),
            V = function () {
                const O = new L;
                return function (Me, ye) {
                    const Le = i.domElement;
                    if (i.object.isPerspectiveCamera) {
                        const ze = i.object.position;
                        O.copy(ze).sub(i.target);
                        let et = O.length();
                        et *= Math.tan(i.object.fov / 2 * Math.PI / 180), he(2 * Me * et / Le.clientHeight, i.object.matrix), B(2 * ye * et / Le.clientHeight, i.object.matrix)
                    } else i.object.isOrthographicCamera ? (he(Me * (i.object.right - i.object.left) / i.object.zoom / Le.clientWidth, i.object.matrix), B(ye * (i.object.top - i.object.bottom) / i.object.zoom / Le.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1)
                }
            }();

        function q(O) {
            i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? c /= O : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
        }

        function j(O) {
            i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? c *= O : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
        }

        function J(O, _e) {
            if (!i.zoomToCursor) return;
            S = !0;
            const Me = i.domElement.getBoundingClientRect(),
                ye = O - Me.left,
                Le = _e - Me.top,
                ze = Me.width,
                et = Me.height;
            C.x = ye / ze * 2 - 1, C.y = -(Le / et) * 2 + 1, x.set(C.x, C.y, 1).unproject(i.object).sub(i.object.position).normalize()
        }

        function ie(O) {
            return Math.max(i.minDistance, Math.min(i.maxDistance, O))
        }

        function pe(O) {
            h.set(O.clientX, O.clientY)
        }

        function de(O) {
            J(O.clientX, O.clientX), m.set(O.clientX, O.clientY)
        }

        function xe(O) {
            p.set(O.clientX, O.clientY)
        }

        function te(O) {
            f.set(O.clientX, O.clientY), d.subVectors(f, h).multiplyScalar(i.rotateSpeed);
            const _e = i.domElement;
            G(2 * Math.PI * d.x / _e.clientHeight), ee(2 * Math.PI * d.y / _e.clientHeight), h.copy(f), i.update()
        }

        function me(O) {
            y.set(O.clientX, O.clientY), v.subVectors(y, m), v.y > 0 ? q(A(v.y)) : v.y < 0 && j(A(v.y)), m.copy(y), i.update()
        }

        function Re(O) {
            _.set(O.clientX, O.clientY), g.subVectors(_, p).multiplyScalar(i.panSpeed), V(g.x, g.y), p.copy(_), i.update()
        }

        function Pe(O) {
            J(O.clientX, O.clientY), O.deltaY < 0 ? j(A(O.deltaY)) : O.deltaY > 0 && q(A(O.deltaY)), i.update()
        }

        function H(O) {
            let _e = !1;
            switch (O.code) {
            case i.keys.UP:
                O.ctrlKey || O.metaKey || O.shiftKey ? ee(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : V(0, i.keyPanSpeed), _e = !0;
                break;
            case i.keys.BOTTOM:
                O.ctrlKey || O.metaKey || O.shiftKey ? ee(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : V(0, -i.keyPanSpeed), _e = !0;
                break;
            case i.keys.LEFT:
                O.ctrlKey || O.metaKey || O.shiftKey ? G(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : V(i.keyPanSpeed, 0), _e = !0;
                break;
            case i.keys.RIGHT:
                O.ctrlKey || O.metaKey || O.shiftKey ? G(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : V(-i.keyPanSpeed, 0), _e = !0;
                break
            }
            _e && (O.preventDefault(), i.update())
        }

        function ce(O) {
            if (R.length === 1) h.set(O.pageX, O.pageY);
            else {
                const _e = Be(O),
                    Me = .5 * (O.pageX + _e.x),
                    ye = .5 * (O.pageY + _e.y);
                h.set(Me, ye)
            }
        }

        function ae(O) {
            if (R.length === 1) p.set(O.pageX, O.pageY);
            else {
                const _e = Be(O),
                    Me = .5 * (O.pageX + _e.x),
                    ye = .5 * (O.pageY + _e.y);
                p.set(Me, ye)
            }
        }

        function le(O) {
            const _e = Be(O),
                Me = O.pageX - _e.x,
                ye = O.pageY - _e.y,
                Le = Math.sqrt(Me * Me + ye * ye);
            m.set(0, Le)
        }

        function Ce(O) {
            i.enableZoom && le(O), i.enablePan && ae(O)
        }

        function I(O) {
            i.enableZoom && le(O), i.enableRotate && ce(O)
        }

        function w(O) {
            if (R.length == 1) f.set(O.pageX, O.pageY);
            else {
                const Me = Be(O),
                    ye = .5 * (O.pageX + Me.x),
                    Le = .5 * (O.pageY + Me.y);
                f.set(ye, Le)
            }
            d.subVectors(f, h).multiplyScalar(i.rotateSpeed);
            const _e = i.domElement;
            G(2 * Math.PI * d.x / _e.clientHeight), ee(2 * Math.PI * d.y / _e.clientHeight), h.copy(f)
        }

        function E(O) {
            if (R.length === 1) _.set(O.pageX, O.pageY);
            else {
                const _e = Be(O),
                    Me = .5 * (O.pageX + _e.x),
                    ye = .5 * (O.pageY + _e.y);
                _.set(Me, ye)
            }
            g.subVectors(_, p).multiplyScalar(i.panSpeed), V(g.x, g.y), p.copy(_)
        }

        function N(O) {
            const _e = Be(O),
                Me = O.pageX - _e.x,
                ye = O.pageY - _e.y,
                Le = Math.sqrt(Me * Me + ye * ye);
            y.set(0, Le), v.set(0, Math.pow(y.y / m.y, i.zoomSpeed)), q(v.y), m.copy(y);
            const ze = (O.pageX + _e.x) * .5,
                et = (O.pageY + _e.y) * .5;
            J(ze, et)
        }

        function U(O) {
            i.enableZoom && N(O), i.enablePan && E(O)
        }

        function W(O) {
            i.enableZoom && N(O), i.enableRotate && w(O)
        }

        function Y(O) {
            i.enabled !== !1 && (R.length === 0 && (i.domElement.setPointerCapture(O.pointerId), i.domElement.addEventListener("pointermove", b), i.domElement.addEventListener("pointerup", M)), Ee(O), O.pointerType === "touch" ? fe(O) : D(O))
        }

        function b(O) {
            i.enabled !== !1 && (O.pointerType === "touch" ? se(O) : z(O))
        }

        function M(O) {
            De(O), R.length === 0 && (i.domElement.releasePointerCapture(O.pointerId), i.domElement.removeEventListener("pointermove", b), i.domElement.removeEventListener("pointerup", M)), i.dispatchEvent(Gp), s = r.NONE
        }

        function D(O) {
            let _e;
            switch (O.button) {
            case 0:
                _e = i.mouseButtons.LEFT;
                break;
            case 1:
                _e = i.mouseButtons.MIDDLE;
                break;
            case 2:
                _e = i.mouseButtons.RIGHT;
                break;
            default:
                _e = -1
            }
            switch (_e) {
            case wr.DOLLY:
                if (i.enableZoom === !1) return;
                de(O), s = r.DOLLY;
                break;
            case wr.ROTATE:
                if (O.ctrlKey || O.metaKey || O.shiftKey) {
                    if (i.enablePan === !1) return;
                    xe(O), s = r.PAN
                } else {
                    if (i.enableRotate === !1) return;
                    pe(O), s = r.ROTATE
                }
                break;
            case wr.PAN:
                if (O.ctrlKey || O.metaKey || O.shiftKey) {
                    if (i.enableRotate === !1) return;
                    pe(O), s = r.ROTATE
                } else {
                    if (i.enablePan === !1) return;
                    xe(O), s = r.PAN
                }
                break;
            default:
                s = r.NONE
            }
            s !== r.NONE && i.dispatchEvent(Gc)
        }

        function z(O) {
            switch (s) {
            case r.ROTATE:
                if (i.enableRotate === !1) return;
                te(O);
                break;
            case r.DOLLY:
                if (i.enableZoom === !1) return;
                me(O);
                break;
            case r.PAN:
                if (i.enablePan === !1) return;
                Re(O);
                break
            }
        }

        function $(O) {
            i.enabled === !1 || i.enableZoom === !1 || s !== r.NONE || (O.preventDefault(), i.dispatchEvent(Gc), Pe(O), i.dispatchEvent(Gp))
        }

        function K(O) {
            i.enabled === !1 || i.enablePan === !1 || H(O)
        }

        function fe(O) {
            switch (oe(O), R.length) {
            case 1:
                switch (i.touches.ONE) {
                case Er.ROTATE:
                    if (i.enableRotate === !1) return;
                    ce(O), s = r.TOUCH_ROTATE;
                    break;
                case Er.PAN:
                    if (i.enablePan === !1) return;
                    ae(O), s = r.TOUCH_PAN;
                    break;
                default:
                    s = r.NONE
                }
                break;
            case 2:
                switch (i.touches.TWO) {
                case Er.DOLLY_PAN:
                    if (i.enableZoom === !1 && i.enablePan === !1) return;
                    Ce(O), s = r.TOUCH_DOLLY_PAN;
                    break;
                case Er.DOLLY_ROTATE:
                    if (i.enableZoom === !1 && i.enableRotate === !1) return;
                    I(O), s = r.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    s = r.NONE
                }
                break;
            default:
                s = r.NONE
            }
            s !== r.NONE && i.dispatchEvent(Gc)
        }

        function se(O) {
            switch (oe(O), s) {
            case r.TOUCH_ROTATE:
                if (i.enableRotate === !1) return;
                w(O), i.update();
                break;
            case r.TOUCH_PAN:
                if (i.enablePan === !1) return;
                E(O), i.update();
                break;
            case r.TOUCH_DOLLY_PAN:
                if (i.enableZoom === !1 && i.enablePan === !1) return;
                U(O), i.update();
                break;
            case r.TOUCH_DOLLY_ROTATE:
                if (i.enableZoom === !1 && i.enableRotate === !1) return;
                W(O), i.update();
                break;
            default:
                s = r.NONE
            }
        }

        function ge(O) {
            i.enabled !== !1 && O.preventDefault()
        }

        function Ee(O) {
            R.push(O.pointerId)
        }

        function De(O) {
            delete F[O.pointerId];
            for (let _e = 0; _e < R.length; _e++)
                if (R[_e] == O.pointerId) {
                    R.splice(_e, 1);
                    return
                }
        }

        function oe(O) {
            let _e = F[O.pointerId];
            _e === void 0 && (_e = new ue, F[O.pointerId] = _e), _e.set(O.pageX, O.pageY)
        }

        function Be(O) {
            const _e = O.pointerId === R[0] ? R[1] : R[0];
            return F[_e]
        }
        i.domElement.addEventListener("contextmenu", ge), i.domElement.addEventListener("pointerdown", Y), i.domElement.addEventListener("pointercancel", M), i.domElement.addEventListener("wheel", $, {
            passive: !1
        }), this.update()
    }
}
class In {}
_t(In, "CAMERA_SENSITIVITY", .3), _t(In, "MIN_BRANCH_RADIUS", .05), _t(In, "X_AXIS", new L(1, 0, 0)), _t(In, "Y_AXIS", new L(0, 1, 0)), _t(In, "Z_AXIS", new L(0, 0, 1)), _t(In, "UP", new L(0, 1, 0)), _t(In, "SIDE", new L(1, 0, 0)), _t(In, "DOWN", new L(0, -1, 0)), _t(In, "EMPTY_QUATERNION", new Zn), _t(In, "WHITE_LIGHT_COLOR", 16777215);
const io = class io {
    static init(e, t, i) {
        this.initPerspectiveCamera(e, t, i)
    }
    static initPerspectiveCamera(e, t, i) {
        this.perspectiveCamera = new qt(75, e / t, .1, 5e3), this.perspectiveCamera.position.z = 210, this.perspectiveCamera.position.y = 100, this.orbitControls = new d1(io.perspectiveCamera, i.domElement), this.orbitControls.rotateSpeed = In.CAMERA_SENSITIVITY, this.orbitControls.minDistance = 1, this.orbitControls.maxDistance = 1e3, this.orbitControls.target.set(0, 20, 0), this.orbitControls.enabled = !0, this.orbitControls.maxPolarAngle = Math.PI / 1.5, this.orbitControls.enableDamping = !0, this.orbitControls.dampingFactor = .05, this.orbitControls.update()
    }
    static updateCamerasForNewRendererSize(e, t) {
        const i = e / t;
        this.perspectiveCamera.aspect = i, this.perspectiveCamera.updateProjectionMatrix()
    }
};
_t(io, "orbitControls"), _t(io, "perspectiveCamera");
let tr = io;
class p1 {
    constructor(e) {
        this.geometry = new Rl(e, 50), this.material = new o_, this.material.opacity = .2, this.mesh = new xt(this.geometry, this.material), this.mesh.rotation.x = -1.5708, this.mesh.name = "Terrain", this.mesh.receiveShadow = !0
    }
}
class Fa {
    static init() {
        this.initMainScene()
    }
    static initMainScene() {
        this.MainScene = new vs, this.MainScene.background = new Fe(6908265);
        const e = new d_(16777215, .1);
        this.MainScene.add(e);
        const t = new f_(16777215, 2);
        t.position.set(200, 250, 0), t.target.position.set(-75, 0, 0), this.MainScene.add(t);
        const i = 200;
        t.castShadow = !0, t.shadow.bias = -.01, t.shadow.mapSize.width = 4096, t.shadow.mapSize.height = 4096, t.shadow.camera.top = i, t.shadow.camera.bottom = -i, t.shadow.camera.left = i, t.shadow.camera.right = -i, t.shadow.radius = 5;
        const r = new p1(150);
        this.MainScene.add(r.mesh)
    }
}
_t(Fa, "MainScene");
const On = class On {
    static get(e) {
        if (!e) return null;
        if (this.loaded.has(e)) return this.loaded.get(e);
        const t = this.LOADER.load(e);
        return t.name = e, t && this.loaded.set(e, t), t
    }
    static async getAsync(e) {
        if (!e) return null;
        if (this.loaded.has(e)) return this.loaded.get(e);
        const t = await this.LOADER.loadAsync(e);
        return t.name = e, t && this.loaded.set(e, t), t
    }
    static findPreviewSrc(e) {
        for (const [t, i] of Object.entries(this.banks))
            for (let r = 0; r < this.banks[t].length; r++) {
                const s = this.banks[t][r];
                if (s.map == e) return s.preview
            }
    }
    static async packToAtlas(e, t) {
        const i = [t.mesh ? await this.getAsync(e.barkDiffuse) : null, t.foliageMesh ? await this.getAsync(e.foliageDiffuse) : null, t.fruitMesh ? await this.getAsync(e.fruitDiffuse) : null],
            r = [t.mesh ? await this.getAsync(e.barkOpacity) : null, t.foliageMesh ? await this.getAsync(e.foliageOpacity) : null, t.fruitMesh ? await this.getAsync(e.fruitOpacity) : null],
            s = [t.mesh ? await this.getAsync(e.barkNormal) : null, t.foliageMesh ? await this.getAsync(e.foliageNormal) : null, t.fruitMesh ? await this.getAsync(e.fruitNormal) : null],
            o = [t.mesh ? await this.getAsync(e.barkRoughness) : null, t.foliageMesh ? await this.getAsync(e.foliageRoughness) : null, t.fruitMesh ? await this.getAsync(e.fruitRoughness) : null];

        function a(p) {
            let _ = null;
            if (p == "bark") {
                if (i[0]) return [i[0].source.data.width, i[0].source.data.height];
                if (r[0]) return [r[0].source.data.width, r[0].source.data.height];
                if (s[0]) return [s[0].source.data.width, s[0].source.data.height];
                if (o[0]) return [o[0].source.data.width, o[0].source.data.height]
            } else if (p == "foliage") {
                if (i[1]) return [i[1].source.data.width, i[1].source.data.height];
                if (r[1]) return [r[1].source.data.width, r[1].source.data.height];
                if (s[1]) return [s[1].source.data.width, s[1].source.data.height];
                if (o[1]) return [o[1].source.data.width, o[1].source.data.height]
            } else if (p == "fruit") {
                if (i[2]) return [i[2].source.data.width, i[2].source.data.height];
                if (r[2]) return [r[2].source.data.width, r[2].source.data.height];
                if (s[2]) return [s[2].source.data.width, s[2].source.data.height];
                if (o[2]) return [o[2].source.data.width, o[2].source.data.height]
            }
            return _
        }
        const l = [a("bark"), a("foliage"), a("fruit")],
            c = 1024,
            u = await On.createAtlas(i, c, "#000000", l),
            h = await On.createAtlas(r, c, "#ffffff", l),
            f = await On.createAtlas(s, c, "#7f7fff", l),
            d = await On.createAtlas(o, c, "#b9b9b9", l);
        return {
            diffuse: u,
            opacity: h,
            normal: f,
            roughness: d
        }
    }
    static async createAtlas(e, t, i, r, s = 5) {
        function o(f, d, p) {
            const _ = f.getImageData(d, p, 1, 1).data;
            return "rgb(" + _[0] + "," + _[1] + "," + _[2] + ")"
        }
        let a = 0;
        r.forEach(f => {
            f && (a += f[0] / f[1] * t + s * 2)
        });
        const l = document.createElement("canvas");
        l.width = a, l.height = t;
        const c = l.getContext("2d");
        c.fillStyle = i, c.fillRect(0, 0, l.width, l.height);
        let u = 0;
        const h = [];
        for (let f = 0; f < e.length; f++) {
            u += s;
            const d = r[f],
                p = {};
            if (e[f] !== null) {
                const _ = e[f].source.data,
                    g = d[0] / d[1] * t;
                p.start = u / a, c.drawImage(_, 0, 0, _.width, _.height, u, 0, g, t);
                const m = o(c, u + 1, l.height / 2);
                c.fillStyle = m, c.fillRect(u - s, 0, s, l.height), c.fillRect(u + g, 0, s, l.height)
            }
            d !== null && (u += d[0] / d[1] * t + s), p.end = (u - s) / a, h.push(p)
        }
        return {
            texture: new Jg(l),
            offsets: h
        }
    }
};
_t(On, "LOADER", new HA), _t(On, "loaded", new Map), _t(On, "banks", {
    bark: [{
        map: "/textures/bark/bark_color1.png",
        preview: "/textures/bark/bark_color1_preview.png"
    }, {
        map: "/textures/bark/bark_color2.jpg",
        preview: "/textures/bark/bark_color2_preview.jpg"
    }, {
        map: "/textures/bark/bark_color3.png",
        preview: "/textures/bark/bark_color3_preview.png"
    }, {
        map: "/textures/bark/bark_normal3.png",
        preview: "/textures/bark/bark_normal3_preview.png"
    }],
    foliage: [{
        map: "/textures/foliage/peachleaf_foliage_color.png",
        preview: "/textures/foliage/peachleaf_foliage_color_preview.png"
    }, {
        map: "/textures/foliage/peachleaf_foliage_opacity.png",
        preview: "/textures/foliage/peachleaf_foliage_opacity_preview.png"
    }, {
        map: "/textures/foliage/elm_branch_color.png",
        preview: "/textures/foliage/elm_branch_color_preview.png"
    }, {
        map: "/textures/foliage/elm_branch_opacity.png",
        preview: "/textures/foliage/elm_branch_opacity_preview.png"
    }, {
        map: "/textures/foliage/oak_foliage_color.png",
        preview: "/textures/foliage/oak_foliage_color_preview.png"
    }, {
        map: "/textures/foliage/oak_foliage_opacity.png",
        preview: "/textures/foliage/oak_foliage_opacity_preview.png"
    }],
    fruit: [{
        map: "/textures/fruit/mango.png",
        preview: "/textures/fruit/mango_preview.png"
    }, {
        map: "/textures/fruit/lemon.png",
        preview: "/textures/fruit/lemon_preview.png"
    }, {
        map: "/textures/fruit/apple.png",
        preview: "/textures/fruit/apple_preview.png"
    }]
}), _t(On, "UNTEXTURED", On.LOADER.load("/textures/untextured.png"));
let Rt = On;
class Li {}
_t(Li, "ATLASED_TREE", new yu({
    side: En,
    alphaTest: .1,
    format: on
})), _t(Li, "FOLIAGE", new yu({
    map: Rt.get("/textures/foliage/elmFoliageColor.png"),
    transparent: !0,
    side: En,
    alphaToCoverage: !0,
    alphaTest: .1,
    transmission: .1
})), _t(Li, "BARK", new l_({
    map: Rt.get("/textures/bark/maple_color.png")
})), _t(Li, "FRUIT", new bh({
    map: Rt.get("/textures/fruit/mango.png")
}));

function m1(n, e = !1) {
    const t = n[0].index !== null,
        i = new Set(Object.keys(n[0].attributes)),
        r = new Set(Object.keys(n[0].morphAttributes)),
        s = {},
        o = {},
        a = n[0].morphTargetsRelative,
        l = new ht;
    let c = 0;
    for (let u = 0; u < n.length; ++u) {
        const h = n[u];
        let f = 0;
        if (t !== (h.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
        for (const d in h.attributes) {
            if (!i.has(d)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + '. All geometries must have compatible attributes; make sure "' + d + '" attribute exists among all geometries, or in none of them.'), null;
            s[d] === void 0 && (s[d] = []), s[d].push(h.attributes[d]), f++
        }
        if (f !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". Make sure all geometries have the same number of attributes."), null;
        if (a !== h.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
        for (const d in h.morphAttributes) {
            if (!r.has(d)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ".  .morphAttributes must be consistent throughout all geometries."), null;
            o[d] === void 0 && (o[d] = []), o[d].push(h.morphAttributes[d])
        }
        if (e) {
            let d;
            if (t) d = h.index.count;
            else if (h.attributes.position !== void 0) d = h.attributes.position.count;
            else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". The geometry must have either an index or a position attribute"), null;
            l.addGroup(c, d, u), c += d
        }
    }
    if (t) {
        let u = 0;
        const h = [];
        for (let f = 0; f < n.length; ++f) {
            const d = n[f].index;
            for (let p = 0; p < d.count; ++p) h.push(d.getX(p) + u);
            u += n[f].attributes.position.count
        }
        l.setIndex(h)
    }
    for (const u in s) {
        const h = Hp(s[u]);
        if (!h) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + u + " attribute."), null;
        l.setAttribute(u, h)
    }
    for (const u in o) {
        const h = o[u][0].length;
        if (h === 0) break;
        l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[u] = [];
        for (let f = 0; f < h; ++f) {
            const d = [];
            for (let _ = 0; _ < o[u].length; ++_) d.push(o[u][_][f]);
            const p = Hp(d);
            if (!p) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + u + " morphAttribute."), null;
            l.morphAttributes[u].push(p)
        }
    }
    return l
}

function Hp(n) {
    let e, t, i, r = -1,
        s = 0;
    for (let c = 0; c < n.length; ++c) {
        const u = n[c];
        if (u.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."), null;
        if (e === void 0 && (e = u.array.constructor), e !== u.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
        if (t === void 0 && (t = u.itemSize), t !== u.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
        if (i === void 0 && (i = u.normalized), i !== u.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
        if (r === -1 && (r = u.gpuType), r !== u.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
        s += u.array.length
    }
    const o = new e(s);
    let a = 0;
    for (let c = 0; c < n.length; ++c) o.set(n[c].array, a), a += n[c].array.length;
    const l = new ut(o, t, i);
    return r !== void 0 && (l.gpuType = r), l
}

function g1(n, e = 1e-4) {
    e = Math.max(e, Number.EPSILON);
    const t = {},
        i = n.getIndex(),
        r = n.getAttribute("position"),
        s = i ? i.count : r.count;
    let o = 0;
    const a = Object.keys(n.attributes),
        l = {},
        c = {},
        u = [],
        h = ["getX", "getY", "getZ", "getW"],
        f = ["setX", "setY", "setZ", "setW"];
    for (let y = 0, v = a.length; y < v; y++) {
        const x = a[y],
            C = n.attributes[x];
        l[x] = new ut(new C.array.constructor(C.count * C.itemSize), C.itemSize, C.normalized);
        const S = n.morphAttributes[x];
        S && (c[x] = new ut(new S.array.constructor(S.count * S.itemSize), S.itemSize, S.normalized))
    }
    const d = e * .5,
        p = Math.log10(1 / e),
        _ = Math.pow(10, p),
        g = d * _;
    for (let y = 0; y < s; y++) {
        const v = i ? i.getX(y) : y;
        let x = "";
        for (let C = 0, S = a.length; C < S; C++) {
            const R = a[C],
                F = n.getAttribute(R),
                T = F.itemSize;
            for (let A = 0; A < T; A++) x += `${~~(F[h[A]](v)*_+g)},`
        }
        if (x in t) u.push(t[x]);
        else {
            for (let C = 0, S = a.length; C < S; C++) {
                const R = a[C],
                    F = n.getAttribute(R),
                    T = n.morphAttributes[R],
                    A = F.itemSize,
                    G = l[R],
                    ee = c[R];
                for (let he = 0; he < A; he++) {
                    const B = h[he],
                        V = f[he];
                    if (G[V](o, F[B](v)), T)
                        for (let q = 0, j = T.length; q < j; q++) ee[q][V](o, T[q][B](v))
                }
            }
            t[x] = o, u.push(o), o++
        }
    }
    const m = n.clone();
    for (const y in n.attributes) {
        const v = l[y];
        if (m.setAttribute(y, new ut(v.array.slice(0, o * v.itemSize), v.itemSize, v.normalized)), y in c)
            for (let x = 0; x < c[y].length; x++) {
                const C = c[y][x];
                m.morphAttributes[y][x] = new ut(C.array.slice(0, o * C.itemSize), C.itemSize, C.normalized)
            }
    }
    return m.setIndex(u), m
}
class yn {
    static vertexArrToBuffer(e) {
        let t = [];
        for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y), t.push(e[i].z);
        return t
    }
    static computeNodeData(e, t, i) {
        if (e.length == 0) return;
        const r = new L(0, 0, 0);
        let s = 0;
        for (let o = 0; o < e.length; o++)
            if (t.distanceTo(e[o].position) < i) {
                const a = new L().subVectors(e[o].position, t).normalize();
                r.add(a), s++
            } return i > 0 && r.divideScalar(s).normalize(), r.negate(), r
    }
    static MAP(e, t, i, r, s) {
        return (e - t) * (s - r) / (i - t) + r
    }
    static MS_TO_READABLE_TIME(e) {
        let t = (e / 1e3).toFixed(1),
            i = (e / (1e3 * 60)).toFixed(1),
            r = (e / (1e3 * 60 * 60)).toFixed(1),
            s = (e / (1e3 * 60 * 60 * 24)).toFixed(1);
        return t < 60 ? t + " Sec" : i < 60 ? i + " Min" : r < 24 ? r + " Hrs" : s + " Days"
    }
    static v3ToString(e) {
        return `${parseFloat(e.x.toFixed(4))},${parseFloat(e.y.toFixed(4))},${parseFloat(e.z.toFixed(4))}`
    }
    static v2ToString(e) {
        return `${parseFloat(e.x.toFixed(4))},${parseFloat(e.y.toFixed(4))}`
    }
    static offsetUVs(e, t, i, r, s) {
        if (!e.geometry.attributes.uv) return;
        const o = e.geometry.attributes.uv;
        for (let a = 0; a < o.count; a++) {
            const l = o.getX(a),
                c = o.getY(a),
                u = yn.MAP(l, 0, 1, t, i),
                h = yn.MAP(c, 0, 1, r, s);
            o.setXY(a, u, h)
        }
        o.needsUpdate = !0
    }
    static mergeTreeToSingleMesh(e) {
        const t = [];
        return e.mesh && t.push(e.mesh.geometry), e.foliageMesh && t.push(e.foliageMesh.geometry), e.fruitMesh && t.push(e.fruitMesh.geometry), new xt(m1(t))
    }
}
const mt = (n, e) => {
        const t = n.__vccOpts || n;
        for (const [i, r] of e) t[i] = r;
        return t
    },
    _1 = {
        data() {
            return {
                progress: 100,
                message: ""
            }
        },
        emits: ["cancel"],
        methods: {
            setPercentLoaded(n, e) {
                this.message = e || "", this.progress = Math.round(n);
                const t = this.$refs.bar,
                    i = this.$refs.progress,
                    r = t.offsetWidth,
                    s = yn.MAP(n, 0, 100, 0, r);
                i.style.width = s + "px"
            }
        }
    },
    v1 = {
        class: "loading_bar_container"
    },
    y1 = {
        style: {
            display: "flex"
        }
    },
    x1 = {
        ref: "bar",
        class: "loading_bar"
    },
    M1 = {
        ref: "progress"
    };

function b1(n, e, t, i, r, s) {
    return V0((be(), Ie("div", v1, [re("p", null, jt(r.message), 1), re("div", y1, [re("div", x1, [re("div", M1, null, 512)], 512), re("button", {
        onClick: e[0] || (e[0] = o => n.$emit("cancel"))
    }, "Cancel")])], 512)), [
        [kv, r.progress != 100]
    ])
}
const S1 = mt(_1, [
        ["render", b1],
        ["__scopeId", "data-v-575444a0"]
    ]),
    T1 = {},
    Il = n => (Zt("data-v-aa81c0c2"), n = n(), Qt(), n),
    w1 = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "burger_icon",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "#ffffff",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    E1 = Il(() => re("path", {
        stroke: "none",
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1)),
    A1 = Il(() => re("path", {
        d: "M4 6l16 0"
    }, null, -1)),
    R1 = Il(() => re("path", {
        d: "M4 12l16 0"
    }, null, -1)),
    C1 = Il(() => re("path", {
        d: "M4 18l16 0"
    }, null, -1)),
    P1 = [E1, A1, R1, C1];

function L1(n, e) {
    return be(), Ie("svg", w1, P1)
}
const p_ = mt(T1, [
        ["render", L1],
        ["__scopeId", "data-v-aa81c0c2"]
    ]),
    I1 = {},
    Rh = n => (Zt("data-v-f154626c"), n = n(), Qt(), n),
    D1 = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "close_icon",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "#2c3e50",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    O1 = Rh(() => re("path", {
        stroke: "none",
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1)),
    N1 = Rh(() => re("path", {
        d: "M18 6l-12 12"
    }, null, -1)),
    U1 = Rh(() => re("path", {
        d: "M6 6l12 12"
    }, null, -1)),
    F1 = [O1, N1, U1];

function B1(n, e) {
    return be(), Ie("svg", D1, F1)
}
const ws = mt(I1, [
        ["render", B1],
        ["__scopeId", "data-v-f154626c"]
    ]),
    Ch = {
        data() {
            return {
                mouseDown: !1
            }
        },
        emits: ["StrictClick"],
        methods: {
            handleMouseDown(n) {
                n.stopPropagation(), this.mouseDown = !0
            },
            handleMouseUp() {
                this.mouseDown && (this.$emit("StrictClick"), this.mouseDown = !1)
            },
            handleMouseLeave() {
                this.mouseDown = !1
            }
        },
        mounted() {
            const n = this.$refs.root;
            n.addEventListener("mousedown", this.handleMouseDown), n.addEventListener("mouseup", this.handleMouseUp), n.addEventListener("mouseleave", this.handleMouseLeave)
        },
        beforeUnmount() {
            const n = this.$refs.root;
            n.removeEventListener("click", this.handleMouseDown), n.removeEventListener("mouseup", this.handleMouseUp), n.removeEventListener("mouseleave", this.handleMouseLeave)
        }
    },
    k1 = {
        mixins: [Ch]
    },
    z1 = {
        ref: "root"
    };

function G1(n, e, t, i, r, s) {
    return be(), Ie("button", z1, [Bu(n.$slots, "default")], 512)
}
const m_ = mt(k1, [
        ["render", G1]
    ]),
    V1 = {
        props: {
            label: String,
            value: Boolean
        },
        emits: ["changed"]
    },
    H1 = {
        style: {
            display: "flex"
        }
    },
    W1 = ["checked"],
    $1 = {
        class: "vertical_flex_center"
    };

function X1(n, e, t, i, r, s) {
    return be(), Ie("div", H1, [re("input", {
        checked: t.value,
        onChange: e[0] || (e[0] = o => n.$emit("changed", n.$refs.checkbox.checked)),
        ref: "checkbox",
        type: "checkbox",
        id: "checkbox",
        name: "checkbox",
        class: "custom-checkbox"
    }, null, 40, W1), re("label", $1, jt(t.label), 1)])
}
const q1 = mt(V1, [
    ["render", X1],
    ["__scopeId", "data-v-818dcaf6"]
]);
class Vn {
    static downloadFile(e, t) {
        const i = new Blob([e], {
                type: "text/plain"
            }),
            r = URL.createObjectURL(i),
            s = document.createElement("a");
        s.href = r, s.download = t, s.click(), URL.revokeObjectURL(r)
    }
    static downloadTexture(e, t) {
        var i = document.createElement("canvas");
        i.width = e.image.width, i.height = e.image.height;
        var r = i.getContext("2d");
        r.drawImage(e.image, 0, 0);
        var s = i.toDataURL("image/png"),
            o = document.createElement("a");
        o.download = t, o.href = s, o.click(), o.remove(), i.remove()
    }
}
class bo {
    static EXPORT(e, t) {
        let i = [];
        if (e.mesh && i.push({
                groupname: "structure",
                mesh: e.mesh
            }), e.foliageMesh && i.push({
                groupname: "foliage",
                mesh: e.foliageMesh
            }), e.fruitMesh && i.push({
                groupname: "fruit",
                mesh: e.fruitMesh
            }), i.length == 0) return;
        const r = {
            vertices: 0,
            uvs: 0
        };
        let s = "";
        for (let o = 0; o < i.length; o++) {
            const a = {
                    vertices: r.vertices,
                    uvs: r.uvs
                },
                l = i[o].mesh,
                c = i[o].groupname;
            s += "o " + c + `
g ` + c + `_g
`;
            const u = l.geometry.getAttribute("position"),
                h = l.geometry.getAttribute("uv"),
                f = l.geometry.getIndex();
            let d;
            const p = bo.mergeDuplicateVertices(u);
            for (d = 0; d < p.array.length; d++) s += "v " + p.array[d].x + " " + p.array[d].y + " " + p.array[d].z + `
`;
            const _ = bo.mergeDuplicateUVs(h);
            for (d = 0; d < _.array.length; d++) s += "vt " + _.array[d].x + " " + _.array[d].y + `
`;
            for (d = 0; d < f.count; d += 3) {
                s += "f ";
                for (let g = 0; g < 3; g++) {
                    const m = f.array[d + g],
                        y = yn.v3ToString(new L(u.array[m * 3], u.array[m * 3 + 1], u.array[m * 3 + 2])),
                        v = yn.v2ToString(new ue(h.array[m * 2], h.array[m * 2 + 1])),
                        x = p.map.get(y),
                        C = _.map.get(v);
                    s += x + a.vertices + "/" + (C + a.uvs) + " ", x + a.vertices > r.vertices && (r.vertices = x + a.vertices), C + a.uvs > r.uvs && (r.uvs = C + a.uvs)
                }
                s += `
`
            }
        }
        Vn.downloadFile(s, t + ".obj")
    }
    static mergeDuplicateVertices(e) {
        let t = [],
            i = new Map,
            r = new Set;
        for (let s = 0; s < e.count; s++) {
            const o = new L().fromBufferAttribute(e, s),
                a = yn.v3ToString(o);
            r.has(a) === !1 && (t.push(o), i.set(a, t.length), r.add(a))
        }
        return {
            array: t,
            map: i
        }
    }
    static mergeDuplicateUVs(e) {
        let t = [],
            i = new Map,
            r = new Set;
        for (let s = 0; s < e.count; s++) {
            const o = new ue().fromBufferAttribute(e, s),
                a = yn.v2ToString(o);
            r.has(a) === !1 && (t.push(o), i.set(a, t.length), r.add(a))
        }
        return {
            array: t,
            map: i
        }
    }
}
class Ea {
    static GET_RANDOM_FLOAT(e, t) {
        return e === 0 && t === 0 ? 0 : Math.random() * (t - e) + e
    }
    static GET_RANDOM_INT(e, t) {
        return e == 0 && t == 0 ? 0 : Math.floor(Math.random() * (t - e + 1)) + e
    }
    static RAND_EVENT(e) {
        return e <= 0 ? !1 : this.GET_RANDOM_INT(1, 100) <= e
    }
    static RAND_UNITVEC() {
        return new L(this.GET_RANDOM_FLOAT(-1, 1), this.GET_RANDOM_FLOAT(-1, 1), this.GET_RANDOM_FLOAT(-1, 1)).normalize()
    }
}
let Vs, Vc, Kr, Aa;

function Hc(n, e = 1 / 0, t = null) {
    Vc || (Vc = new Ao(2, 2, 1, 1)), Kr || (Kr = new Qn({
        uniforms: {
            blitTexture: new Ah(n)
        },
        vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
        fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
    })), Kr.uniforms.blitTexture.value = n, Kr.defines.IS_SRGB = n.colorSpace == Pt, Kr.needsUpdate = !0, Aa || (Aa = new xt(Vc, Kr), Aa.frustrumCulled = !1);
    const i = new qt,
        r = new vs;
    r.add(Aa), t === null && (t = Vs = new th({
        antialias: !1
    }));
    const s = Math.min(n.image.width, e),
        o = Math.min(n.image.height, e);
    t.setSize(s, o), t.clear(), t.render(r, i);
    const a = document.createElement("canvas"),
        l = a.getContext("2d");
    a.width = s, a.height = o, l.drawImage(t.domElement, 0, 0, s, o);
    const c = new Jg(a);
    return c.minFilter = n.minFilter, c.magFilter = n.magFilter, c.wrapS = n.wrapS, c.wrapT = n.wrapT, c.name = n.name, Vs && (Vs.forceContextLoss(), Vs.dispose(), Vs = null), c
}
const Wp = {
    POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"],
    NORMAL: ["byte normalized", "short normalized"],
    TANGENT: ["byte normalized", "short normalized"],
    TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class Ph {
    constructor() {
        this.pluginCallbacks = [], this.register(function (e) {
            return new iR(e)
        }), this.register(function (e) {
            return new rR(e)
        }), this.register(function (e) {
            return new aR(e)
        }), this.register(function (e) {
            return new lR(e)
        }), this.register(function (e) {
            return new cR(e)
        }), this.register(function (e) {
            return new uR(e)
        }), this.register(function (e) {
            return new sR(e)
        }), this.register(function (e) {
            return new oR(e)
        }), this.register(function (e) {
            return new hR(e)
        }), this.register(function (e) {
            return new fR(e)
        }), this.register(function (e) {
            return new dR(e)
        }), this.register(function (e) {
            return new pR(e)
        }), this.register(function (e) {
            return new mR(e)
        })
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    parse(e, t, i, r) {
        const s = new nR,
            o = [];
        for (let a = 0, l = this.pluginCallbacks.length; a < l; a++) o.push(this.pluginCallbacks[a](s));
        s.setPlugins(o), s.write(e, t, r).catch(i)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function (r, s) {
            i.parse(e, r, s, t)
        })
    }
}
const nt = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        BYTE: 5120,
        UNSIGNED_BYTE: 5121,
        SHORT: 5122,
        UNSIGNED_SHORT: 5123,
        INT: 5124,
        UNSIGNED_INT: 5125,
        FLOAT: 5126,
        ARRAY_BUFFER: 34962,
        ELEMENT_ARRAY_BUFFER: 34963,
        NEAREST: 9728,
        LINEAR: 9729,
        NEAREST_MIPMAP_NEAREST: 9984,
        LINEAR_MIPMAP_NEAREST: 9985,
        NEAREST_MIPMAP_LINEAR: 9986,
        LINEAR_MIPMAP_LINEAR: 9987,
        CLAMP_TO_EDGE: 33071,
        MIRRORED_REPEAT: 33648,
        REPEAT: 10497
    },
    Wc = "KHR_mesh_quantization",
    xn = {};
xn[It] = nt.NEAREST;
xn[ja] = nt.NEAREST_MIPMAP_NEAREST;
xn[Js] = nt.NEAREST_MIPMAP_LINEAR;
xn[cn] = nt.LINEAR;
xn[qu] = nt.LINEAR_MIPMAP_NEAREST;
xn[dr] = nt.LINEAR_MIPMAP_LINEAR;
xn[_n] = nt.CLAMP_TO_EDGE;
xn[co] = nt.REPEAT;
xn[uo] = nt.MIRRORED_REPEAT;
const $p = {
        scale: "scale",
        position: "translation",
        quaternion: "rotation",
        morphTargetInfluences: "weights"
    },
    Y1 = new Fe,
    Xp = 12,
    K1 = 1179937895,
    j1 = 2,
    qp = 8,
    J1 = 1313821514,
    Z1 = 5130562;

function Ws(n, e) {
    return n.length === e.length && n.every(function (t, i) {
        return t === e[i]
    })
}

function Q1(n) {
    return new TextEncoder().encode(n).buffer
}

function eR(n) {
    return Ws(n.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
}

function tR(n, e, t) {
    const i = {
        min: new Array(n.itemSize).fill(Number.POSITIVE_INFINITY),
        max: new Array(n.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for (let r = e; r < e + t; r++)
        for (let s = 0; s < n.itemSize; s++) {
            let o;
            n.itemSize > 4 ? o = n.array[r * n.itemSize + s] : (s === 0 ? o = n.getX(r) : s === 1 ? o = n.getY(r) : s === 2 ? o = n.getZ(r) : s === 3 && (o = n.getW(r)), n.normalized === !0 && (o = tl.normalize(o, n.array))), i.min[s] = Math.min(i.min[s], o), i.max[s] = Math.max(i.max[s], o)
        }
    return i
}

function g_(n) {
    return Math.ceil(n / 4) * 4
}

function $c(n, e = 0) {
    const t = g_(n.byteLength);
    if (t !== n.byteLength) {
        const i = new Uint8Array(t);
        if (i.set(new Uint8Array(n)), e !== 0)
            for (let r = n.byteLength; r < t; r++) i[r] = e;
        return i.buffer
    }
    return n
}

function Yp() {
    return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas")
}

function Kp(n, e) {
    if (n.toBlob !== void 0) return new Promise(i => n.toBlob(i, e));
    let t;
    return e === "image/jpeg" ? t = .92 : e === "image/webp" && (t = .8), n.convertToBlob({
        type: e,
        quality: t
    })
}
class nR {
    constructor() {
        this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = new Map, this.uid = 0, this.json = {
            asset: {
                version: "2.0",
                generator: "THREE.GLTFExporter"
            }
        }, this.cache = {
            meshes: new Map,
            attributes: new Map,
            attributesNormalized: new Map,
            materials: new Map,
            textures: new Map,
            images: new Map
        }
    }
    setPlugins(e) {
        this.plugins = e
    }
    async write(e, t, i = {}) {
        this.options = Object.assign({
            binary: !1,
            trs: !1,
            onlyVisible: !0,
            maxTextureSize: 1 / 0,
            animations: [],
            includeCustomExtensions: !1
        }, i), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
        const r = this,
            s = r.buffers,
            o = r.json;
        i = r.options;
        const a = r.extensionsUsed,
            l = r.extensionsRequired,
            c = new Blob(s, {
                type: "application/octet-stream"
            }),
            u = Object.keys(a),
            h = Object.keys(l);
        if (u.length > 0 && (o.extensionsUsed = u), h.length > 0 && (o.extensionsRequired = h), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size), i.binary === !0) {
            const f = new FileReader;
            f.readAsArrayBuffer(c), f.onloadend = function () {
                const d = $c(f.result),
                    p = new DataView(new ArrayBuffer(qp));
                p.setUint32(0, d.byteLength, !0), p.setUint32(4, Z1, !0);
                const _ = $c(Q1(JSON.stringify(o)), 32),
                    g = new DataView(new ArrayBuffer(qp));
                g.setUint32(0, _.byteLength, !0), g.setUint32(4, J1, !0);
                const m = new ArrayBuffer(Xp),
                    y = new DataView(m);
                y.setUint32(0, K1, !0), y.setUint32(4, j1, !0);
                const v = Xp + g.byteLength + _.byteLength + p.byteLength + d.byteLength;
                y.setUint32(8, v, !0);
                const x = new Blob([m, g, _, p, d], {
                        type: "application/octet-stream"
                    }),
                    C = new FileReader;
                C.readAsArrayBuffer(x), C.onloadend = function () {
                    t(C.result)
                }
            }
        } else if (o.buffers && o.buffers.length > 0) {
            const f = new FileReader;
            f.readAsDataURL(c), f.onloadend = function () {
                const d = f.result;
                o.buffers[0].uri = d, t(o)
            }
        } else t(o)
    }
    serializeUserData(e, t) {
        if (Object.keys(e.userData).length === 0) return;
        const i = this.options,
            r = this.extensionsUsed;
        try {
            const s = JSON.parse(JSON.stringify(e.userData));
            if (i.includeCustomExtensions && s.gltfExtensions) {
                t.extensions === void 0 && (t.extensions = {});
                for (const o in s.gltfExtensions) t.extensions[o] = s.gltfExtensions[o], r[o] = !0;
                delete s.gltfExtensions
            }
            Object.keys(s).length > 0 && (t.extras = s)
        } catch (s) {
            console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + s.message)
        }
    }
    getUID(e, t = !1) {
        if (this.uids.has(e) === !1) {
            const r = new Map;
            r.set(!0, this.uid++), r.set(!1, this.uid++), this.uids.set(e, r)
        }
        return this.uids.get(e).get(t)
    }
    isNormalizedNormalAttribute(e) {
        if (this.cache.attributesNormalized.has(e)) return !1;
        const i = new L;
        for (let r = 0, s = e.count; r < s; r++)
            if (Math.abs(i.fromBufferAttribute(e, r).length() - 1) > 5e-4) return !1;
        return !0
    }
    createNormalizedNormalAttribute(e) {
        const t = this.cache;
        if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
        const i = e.clone(),
            r = new L;
        for (let s = 0, o = i.count; s < o; s++) r.fromBufferAttribute(i, s), r.x === 0 && r.y === 0 && r.z === 0 ? r.setX(1) : r.normalize(), i.setXYZ(s, r.x, r.y, r.z);
        return t.attributesNormalized.set(e, i), i
    }
    applyTextureTransform(e, t) {
        let i = !1;
        const r = {};
        (t.offset.x !== 0 || t.offset.y !== 0) && (r.offset = t.offset.toArray(), i = !0), t.rotation !== 0 && (r.rotation = t.rotation, i = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (r.scale = t.repeat.toArray(), i = !0), i && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0)
    }
    buildMetalRoughTexture(e, t) {
        if (e === t) return e;

        function i(d) {
            return d.colorSpace === Pt ? function (_) {
                return _ < .04045 ? _ * .0773993808 : Math.pow(_ * .9478672986 + .0521327014, 2.4)
            } : function (_) {
                return _
            }
        }
        console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof Oc && (e = Hc(e)), t instanceof Oc && (t = Hc(t));
        const r = e ? e.image : null,
            s = t ? t.image : null,
            o = Math.max(r ? r.width : 0, s ? s.width : 0),
            a = Math.max(r ? r.height : 0, s ? s.height : 0),
            l = Yp();
        l.width = o, l.height = a;
        const c = l.getContext("2d");
        c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a);
        const u = c.getImageData(0, 0, o, a);
        if (r) {
            c.drawImage(r, 0, 0, o, a);
            const d = i(e),
                p = c.getImageData(0, 0, o, a).data;
            for (let _ = 2; _ < p.length; _ += 4) u.data[_] = d(p[_] / 256) * 256
        }
        if (s) {
            c.drawImage(s, 0, 0, o, a);
            const d = i(t),
                p = c.getImageData(0, 0, o, a).data;
            for (let _ = 1; _ < p.length; _ += 4) u.data[_] = d(p[_] / 256) * 256
        }
        c.putImageData(u, 0, 0);
        const f = (e || t).clone();
        return f.source = new ir(l), f.colorSpace = vn, f.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), f
    }
    processBuffer(e) {
        const t = this.json,
            i = this.buffers;
        return t.buffers || (t.buffers = [{
            byteLength: 0
        }]), i.push(e), 0
    }
    processBufferView(e, t, i, r, s) {
        const o = this.json;
        o.bufferViews || (o.bufferViews = []);
        let a;
        switch (t) {
        case nt.BYTE:
        case nt.UNSIGNED_BYTE:
            a = 1;
            break;
        case nt.SHORT:
        case nt.UNSIGNED_SHORT:
            a = 2;
            break;
        default:
            a = 4
        }
        const l = g_(r * e.itemSize * a),
            c = new DataView(new ArrayBuffer(l));
        let u = 0;
        for (let d = i; d < i + r; d++)
            for (let p = 0; p < e.itemSize; p++) {
                let _;
                e.itemSize > 4 ? _ = e.array[d * e.itemSize + p] : (p === 0 ? _ = e.getX(d) : p === 1 ? _ = e.getY(d) : p === 2 ? _ = e.getZ(d) : p === 3 && (_ = e.getW(d)), e.normalized === !0 && (_ = tl.normalize(_, e.array))), t === nt.FLOAT ? c.setFloat32(u, _, !0) : t === nt.INT ? c.setInt32(u, _, !0) : t === nt.UNSIGNED_INT ? c.setUint32(u, _, !0) : t === nt.SHORT ? c.setInt16(u, _, !0) : t === nt.UNSIGNED_SHORT ? c.setUint16(u, _, !0) : t === nt.BYTE ? c.setInt8(u, _) : t === nt.UNSIGNED_BYTE && c.setUint8(u, _), u += a
            }
        const h = {
            buffer: this.processBuffer(c.buffer),
            byteOffset: this.byteOffset,
            byteLength: l
        };
        return s !== void 0 && (h.target = s), s === nt.ARRAY_BUFFER && (h.byteStride = e.itemSize * a), this.byteOffset += l, o.bufferViews.push(h), {
            id: o.bufferViews.length - 1,
            byteLength: 0
        }
    }
    processBufferViewImage(e) {
        const t = this,
            i = t.json;
        return i.bufferViews || (i.bufferViews = []), new Promise(function (r) {
            const s = new FileReader;
            s.readAsArrayBuffer(e), s.onloadend = function () {
                const o = $c(s.result),
                    a = {
                        buffer: t.processBuffer(o),
                        byteOffset: t.byteOffset,
                        byteLength: o.byteLength
                    };
                t.byteOffset += o.byteLength, r(i.bufferViews.push(a) - 1)
            }
        })
    }
    processAccessor(e, t, i, r) {
        const s = this.json,
            o = {
                1: "SCALAR",
                2: "VEC2",
                3: "VEC3",
                4: "VEC4",
                9: "MAT3",
                16: "MAT4"
            };
        let a;
        if (e.array.constructor === Float32Array) a = nt.FLOAT;
        else if (e.array.constructor === Int32Array) a = nt.INT;
        else if (e.array.constructor === Uint32Array) a = nt.UNSIGNED_INT;
        else if (e.array.constructor === Int16Array) a = nt.SHORT;
        else if (e.array.constructor === Uint16Array) a = nt.UNSIGNED_SHORT;
        else if (e.array.constructor === Int8Array) a = nt.BYTE;
        else if (e.array.constructor === Uint8Array) a = nt.UNSIGNED_BYTE;
        else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
        if (i === void 0 && (i = 0), (r === void 0 || r === 1 / 0) && (r = e.count), r === 0) return null;
        const l = tR(e, i, r);
        let c;
        t !== void 0 && (c = e === t.index ? nt.ELEMENT_ARRAY_BUFFER : nt.ARRAY_BUFFER);
        const u = this.processBufferView(e, a, i, r, c),
            h = {
                bufferView: u.id,
                byteOffset: u.byteOffset,
                componentType: a,
                count: r,
                max: l.max,
                min: l.min,
                type: o[e.itemSize]
            };
        return e.normalized === !0 && (h.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(h) - 1
    }
    processImage(e, t, i, r = "image/png") {
        if (e !== null) {
            const s = this,
                o = s.cache,
                a = s.json,
                l = s.options,
                c = s.pending;
            o.images.has(e) || o.images.set(e, {});
            const u = o.images.get(e),
                h = r + ":flipY/" + i.toString();
            if (u[h] !== void 0) return u[h];
            a.images || (a.images = []);
            const f = {
                    mimeType: r
                },
                d = Yp();
            d.width = Math.min(e.width, l.maxTextureSize), d.height = Math.min(e.height, l.maxTextureSize);
            const p = d.getContext("2d");
            if (i === !0 && (p.translate(0, d.height), p.scale(1, -1)), e.data !== void 0) {
                t !== on && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                const g = new Uint8ClampedArray(e.height * e.width * 4);
                for (let m = 0; m < g.length; m += 4) g[m + 0] = e.data[m + 0], g[m + 1] = e.data[m + 1], g[m + 2] = e.data[m + 2], g[m + 3] = e.data[m + 3];
                p.putImageData(new ImageData(g, e.width, e.height), 0, 0)
            } else p.drawImage(e, 0, 0, d.width, d.height);
            l.binary === !0 ? c.push(Kp(d, r).then(g => s.processBufferViewImage(g)).then(g => {
                f.bufferView = g
            })) : d.toDataURL !== void 0 ? f.uri = d.toDataURL(r) : c.push(Kp(d, r).then(g => new FileReader().readAsDataURL(g)).then(g => {
                f.uri = g
            }));
            const _ = a.images.push(f) - 1;
            return u[h] = _, _
        } else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")
    }
    processSampler(e) {
        const t = this.json;
        t.samplers || (t.samplers = []);
        const i = {
            magFilter: xn[e.magFilter],
            minFilter: xn[e.minFilter],
            wrapS: xn[e.wrapS],
            wrapT: xn[e.wrapT]
        };
        return t.samplers.push(i) - 1
    }
    processTexture(e) {
        const i = this.options,
            r = this.cache,
            s = this.json;
        if (r.textures.has(e)) return r.textures.get(e);
        s.textures || (s.textures = []), e instanceof Oc && (e = Hc(e, i.maxTextureSize));
        let o = e.userData.mimeType;
        o === "image/webp" && (o = "image/png");
        const a = {
            sampler: this.processSampler(e),
            source: this.processImage(e.image, e.format, e.flipY, o)
        };
        e.name && (a.name = e.name), this._invokeAll(function (c) {
            c.writeTexture && c.writeTexture(e, a)
        });
        const l = s.textures.push(a) - 1;
        return r.textures.set(e, l), l
    }
    processMaterial(e) {
        const t = this.cache,
            i = this.json;
        if (t.materials.has(e)) return t.materials.get(e);
        if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
        i.materials || (i.materials = []);
        const r = {
            pbrMetallicRoughness: {}
        };
        e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
        const s = e.color.toArray().concat([e.opacity]);
        if (Ws(s, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = s), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) {
            const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap),
                l = {
                    index: this.processTexture(a),
                    channel: a.channel
                };
            this.applyTextureTransform(l, a), r.pbrMetallicRoughness.metallicRoughnessTexture = l
        }
        if (e.map) {
            const a = {
                index: this.processTexture(e.map),
                texCoord: e.map.channel
            };
            this.applyTextureTransform(a, e.map), r.pbrMetallicRoughness.baseColorTexture = a
        }
        if (e.emissive) {
            const a = e.emissive;
            if (Math.max(a.r, a.g, a.b) > 0 && (r.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
                const c = {
                    index: this.processTexture(e.emissiveMap),
                    texCoord: e.emissiveMap.channel
                };
                this.applyTextureTransform(c, e.emissiveMap), r.emissiveTexture = c
            }
        }
        if (e.normalMap) {
            const a = {
                index: this.processTexture(e.normalMap),
                texCoord: e.normalMap.channel
            };
            e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x), this.applyTextureTransform(a, e.normalMap), r.normalTexture = a
        }
        if (e.aoMap) {
            const a = {
                index: this.processTexture(e.aoMap),
                texCoord: e.aoMap.channel
            };
            e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), r.occlusionTexture = a
        }
        e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), e.side === En && (r.doubleSided = !0), e.name !== "" && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll(function (a) {
            a.writeMaterial && a.writeMaterial(e, r)
        });
        const o = i.materials.push(r) - 1;
        return t.materials.set(e, o), o
    }
    processMesh(e) {
        const t = this.cache,
            i = this.json,
            r = [e.geometry.uuid];
        if (Array.isArray(e.material))
            for (let x = 0, C = e.material.length; x < C; x++) r.push(e.material[x].uuid);
        else r.push(e.material.uuid);
        const s = r.join(":");
        if (t.meshes.has(s)) return t.meshes.get(s);
        const o = e.geometry;
        let a;
        e.isLineSegments ? a = nt.LINES : e.isLineLoop ? a = nt.LINE_LOOP : e.isLine ? a = nt.LINE_STRIP : e.isPoints ? a = nt.POINTS : a = e.material.wireframe ? nt.LINES : nt.TRIANGLES;
        const l = {},
            c = {},
            u = [],
            h = [],
            f = {
                uv: "TEXCOORD_0",
                uv1: "TEXCOORD_1",
                uv2: "TEXCOORD_2",
                uv3: "TEXCOORD_3",
                color: "COLOR_0",
                skinWeight: "WEIGHTS_0",
                skinIndex: "JOINTS_0"
            },
            d = o.getAttribute("normal");
        d !== void 0 && !this.isNormalizedNormalAttribute(d) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
        let p = null;
        for (let x in o.attributes) {
            if (x.slice(0, 5) === "morph") continue;
            const C = o.attributes[x];
            if (x = f[x] || x.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(x) || (x = "_" + x), t.attributes.has(this.getUID(C))) {
                c[x] = t.attributes.get(this.getUID(C));
                continue
            }
            p = null;
            const R = C.array;
            x === "JOINTS_0" && !(R instanceof Uint16Array) && !(R instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p = new ut(new Uint16Array(R), C.itemSize, C.normalized));
            const F = this.processAccessor(p || C, o);
            F !== null && (x.startsWith("_") || this.detectMeshQuantization(x, C), c[x] = F, t.attributes.set(this.getUID(C), F))
        }
        if (d !== void 0 && o.setAttribute("normal", d), Object.keys(c).length === 0) return null;
        if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
            const x = [],
                C = [],
                S = {};
            if (e.morphTargetDictionary !== void 0)
                for (const R in e.morphTargetDictionary) S[e.morphTargetDictionary[R]] = R;
            for (let R = 0; R < e.morphTargetInfluences.length; ++R) {
                const F = {};
                let T = !1;
                for (const A in o.morphAttributes) {
                    if (A !== "position" && A !== "normal") {
                        T || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), T = !0);
                        continue
                    }
                    const G = o.morphAttributes[A][R],
                        ee = A.toUpperCase(),
                        he = o.attributes[A];
                    if (t.attributes.has(this.getUID(G, !0))) {
                        F[ee] = t.attributes.get(this.getUID(G, !0));
                        continue
                    }
                    const B = G.clone();
                    if (!o.morphTargetsRelative)
                        for (let V = 0, q = G.count; V < q; V++)
                            for (let j = 0; j < G.itemSize; j++) j === 0 && B.setX(V, G.getX(V) - he.getX(V)), j === 1 && B.setY(V, G.getY(V) - he.getY(V)), j === 2 && B.setZ(V, G.getZ(V) - he.getZ(V)), j === 3 && B.setW(V, G.getW(V) - he.getW(V));
                    F[ee] = this.processAccessor(B, o), t.attributes.set(this.getUID(he, !0), F[ee])
                }
                h.push(F), x.push(e.morphTargetInfluences[R]), e.morphTargetDictionary !== void 0 && C.push(S[R])
            }
            l.weights = x, C.length > 0 && (l.extras = {}, l.extras.targetNames = C)
        }
        const _ = Array.isArray(e.material);
        if (_ && o.groups.length === 0) return null;
        let g = !1;
        if (_ && o.index === null) {
            const x = [];
            for (let C = 0, S = o.attributes.position.count; C < S; C++) x[C] = C;
            o.setIndex(x), g = !0
        }
        const m = _ ? e.material : [e.material],
            y = _ ? o.groups : [{
                materialIndex: 0,
                start: void 0,
                count: void 0
            }];
        for (let x = 0, C = y.length; x < C; x++) {
            const S = {
                mode: a,
                attributes: c
            };
            if (this.serializeUserData(o, S), h.length > 0 && (S.targets = h), o.index !== null) {
                let F = this.getUID(o.index);
                (y[x].start !== void 0 || y[x].count !== void 0) && (F += ":" + y[x].start + ":" + y[x].count), t.attributes.has(F) ? S.indices = t.attributes.get(F) : (S.indices = this.processAccessor(o.index, o, y[x].start, y[x].count), t.attributes.set(F, S.indices)), S.indices === null && delete S.indices
            }
            const R = this.processMaterial(m[y[x].materialIndex]);
            R !== null && (S.material = R), u.push(S)
        }
        g === !0 && o.setIndex(null), l.primitives = u, i.meshes || (i.meshes = []), this._invokeAll(function (x) {
            x.writeMesh && x.writeMesh(e, l)
        });
        const v = i.meshes.push(l) - 1;
        return t.meshes.set(s, v), v
    }
    detectMeshQuantization(e, t) {
        if (this.extensionsUsed[Wc]) return;
        let i;
        switch (t.array.constructor) {
        case Int8Array:
            i = "byte";
            break;
        case Uint8Array:
            i = "unsigned byte";
            break;
        case Int16Array:
            i = "short";
            break;
        case Uint16Array:
            i = "unsigned short";
            break;
        default:
            return
        }
        t.normalized && (i += " normalized");
        const r = e.split("_", 1)[0];
        Wp[r] && Wp[r].includes(i) && (this.extensionsUsed[Wc] = !0, this.extensionsRequired[Wc] = !0)
    }
    processCamera(e) {
        const t = this.json;
        t.cameras || (t.cameras = []);
        const i = e.isOrthographicCamera,
            r = {
                type: i ? "orthographic" : "perspective"
            };
        return i ? r.orthographic = {
            xmag: e.right * 2,
            ymag: e.top * 2,
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near
        } : r.perspective = {
            aspectRatio: e.aspect,
            yfov: tl.degToRad(e.fov),
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near
        }, e.name !== "" && (r.name = e.type), t.cameras.push(r) - 1
    }
    processAnimation(e, t) {
        const i = this.json,
            r = this.nodeMap;
        i.animations || (i.animations = []), e = Ph.Utils.mergeMorphTargetTracks(e.clone(), t);
        const s = e.tracks,
            o = [],
            a = [];
        for (let l = 0; l < s.length; ++l) {
            const c = s[l],
                u = ot.parseTrackName(c.name);
            let h = ot.findNode(t, u.nodeName);
            const f = $p[u.propertyName];
            if (u.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(u.objectIndex) : h = void 0), !h || !f) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
            const d = 1;
            let p = c.values.length / c.times.length;
            f === $p.morphTargetInfluences && (p /= h.morphTargetInfluences.length);
            let _;
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (_ = "CUBICSPLINE", p /= 3) : c.getInterpolation() === fo ? _ = "STEP" : _ = "LINEAR", a.push({
                input: this.processAccessor(new ut(c.times, d)),
                output: this.processAccessor(new ut(c.values, p)),
                interpolation: _
            }), o.push({
                sampler: a.length - 1,
                target: {
                    node: r.get(h),
                    path: f
                }
            })
        }
        return i.animations.push({
            name: e.name || "clip_" + i.animations.length,
            samplers: a,
            channels: o
        }), i.animations.length - 1
    }
    processSkin(e) {
        const t = this.json,
            i = this.nodeMap,
            r = t.nodes[i.get(e)],
            s = e.skeleton;
        if (s === void 0) return null;
        const o = e.skeleton.bones[0];
        if (o === void 0) return null;
        const a = [],
            l = new Float32Array(s.bones.length * 16),
            c = new qe;
        for (let h = 0; h < s.bones.length; ++h) a.push(i.get(s.bones[h])), c.copy(s.boneInverses[h]), c.multiply(e.bindMatrix).toArray(l, h * 16);
        return t.skins === void 0 && (t.skins = []), t.skins.push({
            inverseBindMatrices: this.processAccessor(new ut(l, 16)),
            joints: a,
            skeleton: i.get(o)
        }), r.skin = t.skins.length - 1
    }
    processNode(e) {
        const t = this.json,
            i = this.options,
            r = this.nodeMap;
        t.nodes || (t.nodes = []);
        const s = {};
        if (i.trs) {
            const a = e.quaternion.toArray(),
                l = e.position.toArray(),
                c = e.scale.toArray();
            Ws(a, [0, 0, 0, 1]) || (s.rotation = a), Ws(l, [0, 0, 0]) || (s.translation = l), Ws(c, [1, 1, 1]) || (s.scale = c)
        } else e.matrixAutoUpdate && e.updateMatrix(), eR(e.matrix) === !1 && (s.matrix = e.matrix.elements);
        if (e.name !== "" && (s.name = String(e.name)), this.serializeUserData(e, s), e.isMesh || e.isLine || e.isPoints) {
            const a = this.processMesh(e);
            a !== null && (s.mesh = a)
        } else e.isCamera && (s.camera = this.processCamera(e));
        if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
            const a = [];
            for (let l = 0, c = e.children.length; l < c; l++) {
                const u = e.children[l];
                if (u.visible || i.onlyVisible === !1) {
                    const h = this.processNode(u);
                    h !== null && a.push(h)
                }
            }
            a.length > 0 && (s.children = a)
        }
        this._invokeAll(function (a) {
            a.writeNode && a.writeNode(e, s)
        });
        const o = t.nodes.push(s) - 1;
        return r.set(e, o), o
    }
    processScene(e) {
        const t = this.json,
            i = this.options;
        t.scenes || (t.scenes = [], t.scene = 0);
        const r = {};
        e.name !== "" && (r.name = e.name), t.scenes.push(r);
        const s = [];
        for (let o = 0, a = e.children.length; o < a; o++) {
            const l = e.children[o];
            if (l.visible || i.onlyVisible === !1) {
                const c = this.processNode(l);
                c !== null && s.push(c)
            }
        }
        s.length > 0 && (r.nodes = s), this.serializeUserData(e, r)
    }
    processObjects(e) {
        const t = new vs;
        t.name = "AuxScene";
        for (let i = 0; i < e.length; i++) t.children.push(e[i]);
        this.processScene(t)
    }
    processInput(e) {
        const t = this.options;
        e = e instanceof Array ? e : [e], this._invokeAll(function (r) {
            r.beforeParse && r.beforeParse(e)
        });
        const i = [];
        for (let r = 0; r < e.length; r++) e[r] instanceof vs ? this.processScene(e[r]) : i.push(e[r]);
        i.length > 0 && this.processObjects(i);
        for (let r = 0; r < this.skins.length; ++r) this.processSkin(this.skins[r]);
        for (let r = 0; r < t.animations.length; ++r) this.processAnimation(t.animations[r], e[0]);
        this._invokeAll(function (r) {
            r.afterParse && r.afterParse(e)
        })
    }
    _invokeAll(e) {
        for (let t = 0, i = this.plugins.length; t < i; t++) e(this.plugins[t])
    }
}
class iR {
    constructor(e) {
        this.writer = e, this.name = "KHR_lights_punctual"
    }
    writeNode(e, t) {
        if (!e.isLight) return;
        if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
            console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
            return
        }
        const i = this.writer,
            r = i.json,
            s = i.extensionsUsed,
            o = {};
        e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (1 - e.penumbra) * e.angle, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), s[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = {
            lights: []
        }, s[this.name] = !0);
        const a = r.extensions[this.name].lights;
        a.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = {
            light: a.length - 1
        }
    }
}
class rR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_unlit"
    }
    writeMaterial(e, t) {
        if (!e.isMeshBasicMaterial) return;
        const r = this.writer.extensionsUsed;
        t.extensions = t.extensions || {}, t.extensions[this.name] = {}, r[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9
    }
}
class sR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_clearcoat"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.clearcoat === 0) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (s.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
            const o = {
                index: i.processTexture(e.clearcoatMap),
                texCoord: e.clearcoatMap.channel
            };
            i.applyTextureTransform(o, e.clearcoatMap), s.clearcoatTexture = o
        }
        if (s.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
            const o = {
                index: i.processTexture(e.clearcoatRoughnessMap),
                texCoord: e.clearcoatRoughnessMap.channel
            };
            i.applyTextureTransform(o, e.clearcoatRoughnessMap), s.clearcoatRoughnessTexture = o
        }
        if (e.clearcoatNormalMap) {
            const o = {
                index: i.processTexture(e.clearcoatNormalMap),
                texCoord: e.clearcoatNormalMap.channel
            };
            i.applyTextureTransform(o, e.clearcoatNormalMap), s.clearcoatNormalTexture = o
        }
        t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class oR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_iridescence"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.iridescence === 0) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (s.iridescenceFactor = e.iridescence, e.iridescenceMap) {
            const o = {
                index: i.processTexture(e.iridescenceMap),
                texCoord: e.iridescenceMap.channel
            };
            i.applyTextureTransform(o, e.iridescenceMap), s.iridescenceTexture = o
        }
        if (s.iridescenceIor = e.iridescenceIOR, s.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], s.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
            const o = {
                index: i.processTexture(e.iridescenceThicknessMap),
                texCoord: e.iridescenceThicknessMap.channel
            };
            i.applyTextureTransform(o, e.iridescenceThicknessMap), s.iridescenceThicknessTexture = o
        }
        t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class aR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_transmission"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (s.transmissionFactor = e.transmission, e.transmissionMap) {
            const o = {
                index: i.processTexture(e.transmissionMap),
                texCoord: e.transmissionMap.channel
            };
            i.applyTextureTransform(o, e.transmissionMap), s.transmissionTexture = o
        }
        t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class lR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_volume"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (s.thicknessFactor = e.thickness, e.thicknessMap) {
            const o = {
                index: i.processTexture(e.thicknessMap),
                texCoord: e.thicknessMap.channel
            };
            i.applyTextureTransform(o, e.thicknessMap), s.thicknessTexture = o
        }
        s.attenuationDistance = e.attenuationDistance, s.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class cR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_ior"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.ior === 1.5) return;
        const r = this.writer.extensionsUsed,
            s = {};
        s.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class uR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_specular"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(Y1) && !e.specularIntensityMap && !e.specularColorMap) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (e.specularIntensityMap) {
            const o = {
                index: i.processTexture(e.specularIntensityMap),
                texCoord: e.specularIntensityMap.channel
            };
            i.applyTextureTransform(o, e.specularIntensityMap), s.specularTexture = o
        }
        if (e.specularColorMap) {
            const o = {
                index: i.processTexture(e.specularColorMap),
                texCoord: e.specularColorMap.channel
            };
            i.applyTextureTransform(o, e.specularColorMap), s.specularColorTexture = o
        }
        s.specularFactor = e.specularIntensity, s.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class hR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_sheen"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.sheen == 0) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (e.sheenRoughnessMap) {
            const o = {
                index: i.processTexture(e.sheenRoughnessMap),
                texCoord: e.sheenRoughnessMap.channel
            };
            i.applyTextureTransform(o, e.sheenRoughnessMap), s.sheenRoughnessTexture = o
        }
        if (e.sheenColorMap) {
            const o = {
                index: i.processTexture(e.sheenColorMap),
                texCoord: e.sheenColorMap.channel
            };
            i.applyTextureTransform(o, e.sheenColorMap), s.sheenColorTexture = o
        }
        s.sheenRoughnessFactor = e.sheenRoughness, s.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class fR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_anisotropy"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.anisotropy == 0) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (e.anisotropyMap) {
            const o = {
                index: i.processTexture(e.anisotropyMap)
            };
            i.applyTextureTransform(o, e.anisotropyMap), s.anisotropyTexture = o
        }
        s.anisotropyStrength = e.anisotropy, s.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class dR {
    constructor(e) {
        this.writer = e, this.name = "KHR_materials_emissive_strength"
    }
    writeMaterial(e, t) {
        if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1) return;
        const r = this.writer.extensionsUsed,
            s = {};
        s.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class pR {
    constructor(e) {
        this.writer = e, this.name = "EXT_materials_bump"
    }
    writeMaterial(e, t) {
        if (!e.isMeshStandardMaterial || e.bumpScale === 1 && !e.bumpMap) return;
        const i = this.writer,
            r = i.extensionsUsed,
            s = {};
        if (e.bumpMap) {
            const o = {
                index: i.processTexture(e.bumpMap),
                texCoord: e.bumpMap.channel
            };
            i.applyTextureTransform(o, e.bumpMap), s.bumpTexture = o
        }
        s.bumpFactor = e.bumpScale, t.extensions = t.extensions || {}, t.extensions[this.name] = s, r[this.name] = !0
    }
}
class mR {
    constructor(e) {
        this.writer = e, this.name = "EXT_mesh_gpu_instancing"
    }
    writeNode(e, t) {
        if (!e.isInstancedMesh) return;
        const i = this.writer,
            r = e,
            s = new Float32Array(r.count * 3),
            o = new Float32Array(r.count * 4),
            a = new Float32Array(r.count * 3),
            l = new qe,
            c = new L,
            u = new Zn,
            h = new L;
        for (let d = 0; d < r.count; d++) r.getMatrixAt(d, l), l.decompose(c, u, h), c.toArray(s, d * 3), u.toArray(o, d * 4), h.toArray(a, d * 3);
        const f = {
            TRANSLATION: i.processAccessor(new ut(s, 3)),
            ROTATION: i.processAccessor(new ut(o, 4)),
            SCALE: i.processAccessor(new ut(a, 3))
        };
        r.instanceColor && (f._COLOR_0 = i.processAccessor(r.instanceColor)), t.extensions = t.extensions || {}, t.extensions[this.name] = {
            attributes: f
        }, i.extensionsUsed[this.name] = !0, i.extensionsRequired[this.name] = !0
    }
}
Ph.Utils = {
    insertKeyframe: function (n, e) {
        const i = n.getValueSize(),
            r = new n.TimeBufferType(n.times.length + 1),
            s = new n.ValueBufferType(n.values.length + i),
            o = n.createInterpolant(new n.ValueBufferType(i));
        let a;
        if (n.times.length === 0) {
            r[0] = e;
            for (let l = 0; l < i; l++) s[l] = 0;
            a = 0
        } else if (e < n.times[0]) {
            if (Math.abs(n.times[0] - e) < .001) return 0;
            r[0] = e, r.set(n.times, 1), s.set(o.evaluate(e), 0), s.set(n.values, i), a = 0
        } else if (e > n.times[n.times.length - 1]) {
            if (Math.abs(n.times[n.times.length - 1] - e) < .001) return n.times.length - 1;
            r[r.length - 1] = e, r.set(n.times, 0), s.set(n.values, 0), s.set(o.evaluate(e), n.values.length), a = r.length - 1
        } else
            for (let l = 0; l < n.times.length; l++) {
                if (Math.abs(n.times[l] - e) < .001) return l;
                if (n.times[l] < e && n.times[l + 1] > e) {
                    r.set(n.times.slice(0, l + 1), 0), r[l + 1] = e, r.set(n.times.slice(l + 1), l + 2), s.set(n.values.slice(0, (l + 1) * i), 0), s.set(o.evaluate(e), (l + 1) * i), s.set(n.values.slice((l + 1) * i), (l + 2) * i), a = l + 1;
                    break
                }
            }
        return n.times = r, n.values = s, a
    },
    mergeMorphTargetTracks: function (n, e) {
        const t = [],
            i = {},
            r = n.tracks;
        for (let s = 0; s < r.length; ++s) {
            let o = r[s];
            const a = ot.parseTrackName(o.name),
                l = ot.findNode(e, a.nodeName);
            if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
                t.push(o);
                continue
            }
            if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(po)
            }
            const c = l.morphTargetInfluences.length,
                u = l.morphTargetDictionary[a.propertyIndex];
            if (u === void 0) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
            let h;
            if (i[l.uuid] === void 0) {
                h = o.clone();
                const d = new h.ValueBufferType(c * h.times.length);
                for (let p = 0; p < h.times.length; p++) d[p * c + u] = h.values[p];
                h.name = (a.nodeName || "") + ".morphTargetInfluences", h.values = d, i[l.uuid] = h, t.push(h);
                continue
            }
            const f = o.createInterpolant(new o.ValueBufferType(1));
            h = i[l.uuid];
            for (let d = 0; d < h.times.length; d++) h.values[d * c + u] = f.evaluate(h.times[d]);
            for (let d = 0; d < o.times.length; d++) {
                const p = this.insertKeyframe(h, o.times[d]);
                h.values[p * c + u] = o.values[d]
            }
        }
        return n.tracks = t, n
    }
};
class Mu {
    static EXPORT(e, t) {
        const i = {},
            r = new vs;
        e.mesh && r.add(e.mesh), e.foliageMesh && r.add(e.foliageMesh), e.fruitMesh && r.add(e.fruitMesh), this.GLTFExporter.parse(r, function (s) {
            const o = JSON.stringify(s),
                a = new Blob([o], {
                    type: "model/gltf+json"
                });
            Vn.downloadFile(a, t + ".gltf")
        }, function (s) {
            console.log("An error happened: ", s)
        }, i)
    }
}
_t(Mu, "GLTFExporter", new Ph);
const gR = {
        data() {
            return {
                treeMesh: null,
                isOpen: !1,
                stats: {
                    vertices: 0,
                    tris: 0
                },
                downloadTextures: !0
            }
        },
        props: {
            currentTreeType: Object
        },
        components: {
            BurgerIcon: p_,
            CloseIcon: ws,
            ButtonWrapper: m_,
            CheckBox: q1
        },
        methods: {
            async packToAtlas(n) {
                const e = await Rt.packToAtlas(this.currentTreeType.resources, n),
                    t = e.diffuse.offsets;
                t[0].start != null && n.mesh != null && (yn.offsetUVs(n.mesh, t[0].start, t[0].end, 0, 1), n.mesh.material.map = e.diffuse.texture, n.mesh.material.alphaMap = e.opacity.texture, n.mesh.material.normalMap = e.normal.texture, n.mesh.material.roughnessMap = e.roughness.texture), t[1].start != null && n.foliageMesh != null && (yn.offsetUVs(n.foliageMesh, t[1].start, t[1].end, 0, 1), n.foliageMesh.material.map = e.diffuse.texture, n.foliageMesh.material.alphaMap = e.opacity.texture, n.foliageMesh.material.normalMap = e.normal.texture, n.foliageMesh.material.roughnessMap = e.roughness.texture), t[2].start != null && n.fruitMesh != null && (yn.offsetUVs(n.fruitMesh, t[2].start, t[2].end, 0, 1), n.fruitMesh.material.map = e.diffuse.texture, n.fruitMesh.material.alphaMap = e.opacity.texture, n.fruitMesh.material.normalMap = e.normal.texture, n.fruitMesh.material.roughnessMap = e.roughness.texture);
                const i = yn.mergeTreeToSingleMesh(n);
                return i.material = Li.ATLASED_TREE, i.material.map = e.diffuse.texture, i.material.alphaMap = e.opacity.texture, i.material.normalMap = e.normal.texture, i.material.roughnessMap = e.roughness.texture, {
                    mesh: i
                }
            },
            async exportOBJ() {
                const n = this.$parent.tree,
                    e = {
                        mesh: n.mesh ? new xt(n.mesh.geometry.clone(), n.mesh.material.clone()) : null,
                        foliageMesh: n.foliageMesh ? new xt(n.foliageMesh.geometry.clone(), n.foliageMesh.material.clone()) : null,
                        fruitMesh: n.fruitMesh ? new xt(n.fruitMesh.geometry.clone(), n.fruitMesh.material.clone()) : null
                    };
                if (this.currentTreeType.texturing.packToAtlas) {
                    const t = await this.packToAtlas(e);
                    bo.EXPORT({
                        mesh: t.mesh
                    }, Ea.GET_RANDOM_INT(1e4, 2e4)), this.downloadTextures && (Vn.downloadTexture(t.mesh.material.map, "diffuseMap.png"), Vn.downloadTexture(t.mesh.material.alphaMap, "alphaMap.png"), Vn.downloadTexture(t.mesh.material.normalMap, "normalMap.png"), Vn.downloadTexture(t.mesh.material.roughnessMap, "roughnessMap.png"))
                } else bo.EXPORT(e, Ea.GET_RANDOM_INT(1e4, 2e4));
                e.mesh && (e.mesh.geometry.dispose(), e.mesh.material.dispose()), e.foliageMesh && (e.foliageMesh.geometry.dispose(), e.foliageMesh.material.dispose()), e.fruitMesh && (e.fruitMesh.geometry.dispose(), e.fruitMesh.material.dispose()), this.trackExportEvent("obj_export")
            },
            async exportGLTF() {
                const n = this.$parent.tree,
                    e = {
                        mesh: n.mesh ? new xt(n.mesh.geometry.clone(), n.mesh.material.clone()) : null,
                        foliageMesh: n.foliageMesh ? new xt(n.foliageMesh.geometry.clone(), n.foliageMesh.material.clone()) : null,
                        fruitMesh: n.fruitMesh ? new xt(n.fruitMesh.geometry.clone(), n.fruitMesh.material.clone()) : null
                    };
                if (this.currentTreeType.texturing.packToAtlas) {
                    const t = await this.packToAtlas(e);
                    Mu.EXPORT({
                        mesh: t.mesh
                    }, Ea.GET_RANDOM_INT(1e4, 2e4)), this.downloadTextures && (Vn.downloadTexture(t.mesh.material.map, "diffuseMap.png"), Vn.downloadTexture(t.mesh.material.alphaMap, "alphaMap.png"), Vn.downloadTexture(t.mesh.material.normalMap, "normalMap.png"), Vn.downloadTexture(t.mesh.material.roughnessMap, "roughnessMap.png"))
                } else Mu.EXPORT(e, Ea.GET_RANDOM_INT(1e4, 2e4));
                this.trackExportEvent("gltf_export")
            },
            trackExportEvent(n) {
                this.$gtag.event(n, {
                    event_category: "exporting",
                    event_label: "export"
                })
            },
            updateStats(n) {
                this.stats.vertices = 0, this.stats.vertices += n.mesh ? n.mesh.geometry.attributes.position.count : 0, this.stats.vertices += n.foliageMesh ? n.foliageMesh.geometry.attributes.position.count : 0, this.stats.vertices += n.fruitMesh ? n.fruitMesh.geometry.attributes.position.count : 0, this.stats.tris = 0, this.stats.tris += n.mesh ? n.mesh.geometry.index.count / 3 : 0, this.stats.tris += n.foliageMesh ? n.foliageMesh.geometry.index.count / 3 : 0, this.stats.tris += n.fruitMesh ? n.fruitMesh.geometry.index.count / 3 : 0
            },
            setPackToAtlas(n) {
                this.$parent.$parent.setOption("texturing.packToAtlas", n)
            },
            setDownloadTextures(n) {
                this.downloadTextures = n
            }
        }
    },
    __ = n => (Zt("data-v-74164a17"), n = n(), Qt(), n),
    _R = {
        key: 1,
        class: "panel_container"
    },
    vR = {
        style: {
            display: "flex",
            "justify-content": "right"
        }
    },
    yR = {
        class: "info_content"
    },
    xR = __(() => re("div", {
        class: "flex_placeholder",
        style: {
            "margin-top": "20px"
        }
    }, null, -1)),
    MR = __(() => re("div", {
        style: {
            "margin-top": "20px"
        }
    }, null, -1));

function bR(n, e, t, i, r, s) {
    const o = He("BurgerIcon"),
        a = He("CloseIcon"),
        l = He("CheckBox"),
        c = He("ButtonWrapper");
    return r.isOpen ? (be(), Ie("section", _R, [re("div", vR, [ve(a, {
        onClick: e[1] || (e[1] = u => r.isOpen = !1)
    })]), re("section", yR, [re("p", null, "Vertices: " + jt(r.stats.vertices.toLocaleString()), 1), re("p", null, "Tris: " + jt(r.stats.tris.toLocaleString()), 1), xR, ve(l, {
        onChanged: s.setPackToAtlas,
        label: "Pack Textures To Atlas",
        value: t.currentTreeType.texturing.packToAtlas,
        style: {
            "margin-bottom": "10px"
        }
    }, null, 8, ["onChanged", "value"]), t.currentTreeType.texturing.packToAtlas ? (be(), Jt(l, {
        key: 0,
        onChanged: s.setDownloadTextures,
        label: "Download Textures",
        value: r.downloadTextures
    }, null, 8, ["onChanged", "value"])) : rt("", !0), MR, ve(c, {
        onStrictClick: e[2] || (e[2] = u => s.exportOBJ()),
        class: "general_btn"
    }, {
        default: Kn(() => [ar("Export As .OBJ")]),
        _: 1
    }), ve(c, {
        onStrictClick: e[3] || (e[3] = u => s.exportGLTF()),
        class: "general_btn"
    }, {
        default: Kn(() => [ar("Export As .GLTF")]),
        _: 1
    })])])) : (be(), Jt(o, {
        key: 0,
        class: "burger_icon",
        onClick: e[0] || (e[0] = u => r.isOpen = !0)
    }))
}
const SR = mt(gR, [
        ["render", bR],
        ["__scopeId", "data-v-74164a17"]
    ]),
    TR = {
        data() {
            return {
                bgGrow: new Worker(new URL("/assets/bgTreeWorker-BWS6yf2I.js",
                    import.meta.url), {
                    type: "module"
                }),
                additionalStats: {
                    generationTime: null
                }
            }
        },
        components: {
            LoadingBar: S1,
            InfoPanel: SR
        },
        created() {
            window.addEventListener("keyup", this.handleKeyUp)
        },
        beforeUnmount() {
            window.removeEventListener("keyup", this.handleKeyUp)
        },
        mounted() {
            this.init(), this.grow()
        },
        props: {
            currentTreeType: Object
        },
        methods: {
            handleKeyUp(n) {
                n.preventDefault(), n.code === "Space" && this.grow(n.code)
            },
            async receiveBgGrowMsg(n, e) {
                if (n.data.type == "complete") {
                    const t = new t1;
                    this.removeTreeFromScene(e), n.data.value.structureMesh && (this.tree.mesh = t.parse(n.data.value.structureMesh), this.tree.mesh.castShadow = !0, this.tree.mesh.receiveShadow = !0), n.data.value.foliageMesh && (this.tree.foliageMesh = t.parse(n.data.value.foliageMesh), this.tree.foliageMesh.castShadow = !0, this.tree.foliageMesh.receiveShadow = !0), n.data.value.fruitMesh && (this.tree.fruitMesh = t.parse(n.data.value.fruitMesh)), this.additionalStats.generationTime = yn.MS_TO_READABLE_TIME(n.data.value.generationTime || 0), await this.assignMaterialMaps(), this.addTreeToScene(e), this.$refs.growth_loading_bar.setPercentLoaded(100)
                } else n.data.type == "patch" && this.$refs.growth_loading_bar.setPercentLoaded(n.data.value.progress, n.data.value.message)
            },
            async grow() {
                const n = this.currentTreeType,
                    e = Fa.MainScene;
                this.$refs.growth_loading_bar.progress == 100 && this.bgGrow.postMessage({
                    properties: JSON.stringify(n)
                }), this.bgGrow.onmessage = t => {
                    this.receiveBgGrowMsg(t, e)
                }
            },
            cancelGrow() {
                this.$refs.growth_loading_bar.progress = 100, this.bgGrow.terminate(), this.bgGrow = new Worker(new URL("/assets/bgTreeWorker-BWS6yf2I.js",
                    import.meta.url), {
                    type: "module"
                }), this.bgGrow.onmessage = n => {
                    this.receiveBgGrowMsg(n)
                }
            },
            async assignMaterialMaps() {
                this.tree.mesh && (this.tree.mesh.material = Li.BARK, this.tree.mesh.material.map = Rt.get(this.currentTreeType.resources.barkDiffuse), this.tree.mesh.material.alphaMap = Rt.get(this.currentTreeType.resources.barkOpacity), this.tree.mesh.material.normalMap = Rt.get(this.currentTreeType.resources.barkNormal), this.tree.mesh.material.roughnessMap = Rt.get(this.currentTreeType.resources.barkRoughness)), this.tree.foliageMesh && (this.tree.foliageMesh.material = Li.FOLIAGE, this.tree.foliageMesh.material.map = Rt.get(this.currentTreeType.resources.foliageDiffuse), this.tree.foliageMesh.material.alphaMap = Rt.get(this.currentTreeType.resources.foliageOpacity), this.tree.foliageMesh.material.normalMap = Rt.get(this.currentTreeType.resources.foliageNormal), this.tree.foliageMesh.material.roughnessMap = Rt.get(this.currentTreeType.resources.foliageRoughness)), this.tree.fruitMesh && (this.tree.fruitMesh.material = Li.FRUIT, this.tree.fruitMesh.material.map = Rt.get(this.currentTreeType.resources.fruitDiffuse), this.tree.fruitMesh.material.alphaMap = Rt.get(this.currentTreeType.resources.fruitOpacity), this.tree.fruitMesh.material.normalMap = Rt.get(this.currentTreeType.resources.fruitNormal), this.tree.fruitMesh.material.roughnessMap = Rt.get(this.currentTreeType.resources.fruitRoughness))
            },
            addTreeToScene(n) {
                this.tree.mesh && n.add(this.tree.mesh), this.tree.foliageMesh && n.add(this.tree.foliageMesh), this.tree.fruitMesh && n.add(this.tree.fruitMesh), this.$refs.info_panel.updateStats(this.tree)
            },
            removeTreeFromScene(n) {
                this.tree.mesh && n.remove(this.tree.mesh), this.tree.foliageMesh && n.remove(this.tree.foliageMesh), this.tree.fruitMesh && n.remove(this.tree.fruitMesh), this.tree = {
                    mesh: null,
                    foliageMesh: null,
                    fruitMesh: null
                }
            },
            init() {
                this.tree = {
                    mesh: null,
                    foliageMesh: null,
                    fruitMesh: null
                }, this.renderer = new th({
                    alpha: !0,
                    antialias: !0
                }), this.renderer.setSize(this.$refs.rendering_window.offsetWidth, this.$refs.rendering_window.offsetHeight), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.renderer.antialias = !0, this.renderer.physicallyCorrectLights = !0, this.renderer.shadowMap.enabled = !0, this.renderer.toneMapping = yg, this.renderer.outputColorSpace = Pt, this.renderer.toneMappingExposure = 2, this.$refs.rendering_window.appendChild(this.renderer.domElement), tr.init(this.$refs.rendering_window.offsetWidth, this.$refs.rendering_window.offsetHeight, this.renderer), Fa.init(), this.animate()
            },
            animate() {
                this.resizeCanvasToDisplaySize(), tr.orbitControls.update(), this.renderer.render(Fa.MainScene, tr.perspectiveCamera), requestAnimationFrame(this.animate)
            },
            resizeCanvasToDisplaySize() {
                const n = this.renderer.domElement,
                    e = n.clientWidth,
                    t = n.clientHeight;
                (n.width !== e || n.height !== t) && (this.renderer.setSize(e, t, !1), tr.updateCamerasForNewRendererSize(e, t))
            }
        },
        watch: {
            currentTreeType: function () {
                tr.orbitControls.target.set(0, this.currentTreeType.meta.growthIncrements / 2, 0), this.grow()
            }
        }
    },
    wR = n => (Zt("data-v-2bc2477f"), n = n(), Qt(), n),
    ER = {
        ref: "rendering_window"
    },
    AR = {
        class: "grow_hint"
    },
    RR = wR(() => re("span", null, "Press 'space-bar' to", -1)),
    CR = {
        class: "additional_stats"
    },
    PR = {
        key: 0
    };

function LR(n, e, t, i, r, s) {
    const o = He("InfoPanel"),
        a = He("LoadingBar");
    return be(), Ie("section", ER, [ve(o, {
        currentTreeType: t.currentTreeType,
        ref: "info_panel"
    }, null, 8, ["currentTreeType"]), ve(a, {
        ref: "growth_loading_bar",
        class: "growth_loading_bar",
        onCancel: e[0] || (e[0] = l => s.cancelGrow())
    }, null, 512), re("p", AR, [RR, re("button", {
        onClick: e[1] || (e[1] = l => s.grow())
    }, "Grow")]), re("div", CR, [r.additionalStats.generationTime !== null ? (be(), Ie("p", PR, [ar("Generated in about "), re("span", null, jt(r.additionalStats.generationTime), 1)])) : rt("", !0)])], 512)
}
const IR = mt(TR, [
        ["render", LR],
        ["__scopeId", "data-v-2bc2477f"]
    ]),
    DR = {
        props: {
            name: String,
            previewSrc: String
        },
        mixins: [Ch]
    },
    OR = {
        ref: "root",
        class: "card_container"
    },
    NR = ["src", "alt"],
    UR = {
        class: "vertical_flex_center"
    };

function FR(n, e, t, i, r, s) {
    return be(), Ie("div", OR, [re("img", {
        src: t.previewSrc,
        alt: `Small preview image of an ${t.name} tree`
    }, null, 8, NR), re("p", UR, jt(t.name), 1)], 512)
}
const Lh = mt(DR, [
        ["render", FR],
        ["__scopeId", "data-v-daf9411d"]
    ]),
    BR = {
        data() {
            return {
                isOpen: !1
            }
        },
        emits: ["select"],
        props: {
            selectableItems: Array,
            currentSelected: Object
        },
        components: {
            CloseIcon: ws,
            TreeCard: Lh
        },
        methods: {
            handleSelect(n) {
                this.$emit("select", n), this.close()
            },
            open() {
                this.isOpen = !0
            },
            close() {
                this.isOpen = !1
            }
        }
    },
    v_ = n => (Zt("data-v-c7559b05"), n = n(), Qt(), n),
    kR = {
        key: 0
    },
    zR = {
        class: "popup_centered popup_medium"
    },
    GR = {
        class: "popup_header"
    },
    VR = v_(() => re("div", null, null, -1)),
    HR = v_(() => re("h2", {
        class: "vertical_flex_center"
    }, "Tree Types", -1)),
    WR = {
        class: "items_container"
    };

function $R(n, e, t, i, r, s) {
    const o = He("CloseIcon"),
        a = He("TreeCard");
    return r.isOpen ? (be(), Ie("div", kR, [re("div", {
        onClick: e[0] || (e[0] = xl(l => s.close(), ["self"])),
        class: "popup_overlay"
    }), re("div", zR, [re("div", GR, [VR, HR, re("div", null, [ve(o, {
        onClick: e[1] || (e[1] = l => s.close())
    })])]), re("div", WR, [(be(!0), Ie(Et, null, jn(t.selectableItems, l => (be(), Jt(a, {
        key: l.meta.name + ":" + l.meta.preview,
        name: l.meta.name,
        previewSrc: l.meta.preview,
        class: Un({
            active: l.meta.name == t.currentSelected.meta.name
        }),
        onClick: c => s.handleSelect(l)
    }, null, 8, ["name", "previewSrc", "class", "onClick"]))), 128))])])])) : rt("", !0)
}
const XR = mt(BR, [
        ["render", $R],
        ["__scopeId", "data-v-c7559b05"]
    ]),
    qR = {},
    Dl = n => (Zt("data-v-e0e79354"), n = n(), Qt(), n),
    YR = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "info_icon",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "#000000",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    KR = Dl(() => re("path", {
        stroke: "none",
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1)),
    jR = Dl(() => re("path", {
        d: "M12 9h.01"
    }, null, -1)),
    JR = Dl(() => re("path", {
        d: "M11 12h1v4h1"
    }, null, -1)),
    ZR = Dl(() => re("path", {
        d: "M12 3c7.2 0 9 1.8 9 9s-1.8 9 -9 9s-9 -1.8 -9 -9s1.8 -9 9 -9z"
    }, null, -1)),
    QR = [KR, jR, JR, ZR];

function eC(n, e) {
    return be(), Ie("svg", YR, QR)
}
const y_ = mt(qR, [
        ["render", eC],
        ["__scopeId", "data-v-e0e79354"]
    ]),
    tC = {},
    x_ = n => (Zt("data-v-ccc9c8ae"), n = n(), Qt(), n),
    nC = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "icon_minus",
        width: "44",
        height: "44",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "#ffffff",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    iC = x_(() => re("path", {
        stroke: "none",
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1)),
    rC = x_(() => re("path", {
        d: "M5 12l14 0"
    }, null, -1)),
    sC = [iC, rC];

function oC(n, e) {
    return be(), Ie("svg", nC, sC)
}
const aC = mt(tC, [
        ["render", oC],
        ["__scopeId", "data-v-ccc9c8ae"]
    ]),
    lC = {
        props: {
            params: Object,
            value: Number,
            removable: {
                type: Boolean,
                default: !1
            }
        },
        components: {
            MinusIcon: aC
        },
        emits: ["changed", "remove"]
    },
    cC = {
        class: "name_container"
    },
    uC = {
        class: "slider_container"
    },
    hC = ["min", "max", "step", "value"];

function fC(n, e, t, i, r, s) {
    const o = He("MinusIcon");
    return be(), Ie("div", null, [re("div", cC, [t.removable ? (be(), Jt(o, {
        key: 0,
        onClick: e[0] || (e[0] = a => n.$emit("remove"))
    })) : rt("", !0), re("p", null, jt(t.params.name), 1)]), re("div", uC, [re("input", {
        type: "range",
        min: t.params.min,
        max: t.params.max,
        step: t.params.step,
        value: t.value,
        ref: "input",
        onInput: e[1] || (e[1] = a => n.$emit("changed", parseFloat(n.$refs.input.value)))
    }, null, 40, hC), re("label", {
        class: "option_slider_label",
        ref: "label"
    }, jt(t.value), 513)])])
}
const Ol = mt(lC, [
        ["render", fC],
        ["__scopeId", "data-v-11abd91d"]
    ]),
    dC = {
        emits: ["select"],
        methods: {
            select(n) {
                this.$emit("select", n.target.value), this.clear()
            },
            set(n) {
                const e = this.$refs.dropdown.children;
                for (let t = 0; t < e.length; t++) e[t].value === n && (this.$refs.dropdown.selectedIndex = t)
            },
            clear() {
                this.$refs.dropdown.selectedIndex = 0
            }
        }
    },
    pC = n => (Zt("data-v-41bedb0b"), n = n(), Qt(), n),
    mC = pC(() => re("option", {
        disabled: "",
        selected: "",
        value: ""
    }, " -- select an option -- ", -1));

function gC(n, e, t, i, r, s) {
    return be(), Ie("select", {
        ref: "dropdown",
        class: "dropdown_class",
        onChange: e[0] || (e[0] = o => s.select(o))
    }, [mC, Bu(n.$slots, "default", {}, void 0, !0)], 544)
}
const Ih = mt(dC, [
        ["render", gC],
        ["__scopeId", "data-v-41bedb0b"]
    ]),
    _C = {
        data() {
            return {
                mouseOver: !1
            }
        },
        emits: ["remove"],
        props: {
            src: String,
            label: {
                type: String,
                default: ""
            },
            removeButton: {
                type: Boolean,
                default: !1
            }
        },
        mixins: [Ch],
        components: {
            CloseIcon: ws
        }
    },
    vC = {
        key: 0,
        style: {
            "margin-bottom": "5px"
        }
    },
    yC = ["src"];

function xC(n, e, t, i, r, s) {
    const o = He("CloseIcon");
    return be(), Ie("div", {
        style: {
            display: "flex",
            "flex-direction": "column",
            position: "relative"
        },
        onMouseover: e[1] || (e[1] = a => r.mouseOver = !0),
        onMouseleave: e[2] || (e[2] = a => r.mouseOver = !1)
    }, [t.label ? (be(), Ie("p", vC, jt(t.label), 1)) : rt("", !0), re("img", {
        ref: "root",
        class: "img_card",
        src: t.src || "/textures/previews/none.png"
    }, null, 8, yC), t.removeButton && r.mouseOver && t.src != null ? (be(), Ie("div", {
        key: 1,
        class: "remove_btn",
        onClick: e[0] || (e[0] = a => n.$emit("remove"))
    }, [ve(o)])) : rt("", !0)], 32)
}
const Nl = mt(_C, [
        ["render", xC],
        ["__scopeId", "data-v-3c4eebfc"]
    ]),
    MC = {
        data() {
            return {
                textures: null,
                isOpen: !1
            }
        },
        emits: ["select"],
        props: {
            title: String,
            bank: String
        },
        components: {
            CloseIcon: ws,
            TextureCard: Nl
        },
        mounted() {
            this.textures = Rt.banks[this.bank]
        },
        methods: {
            async handleImageUpload(n) {
                const e = n.target.files[0],
                    t = URL.createObjectURL(e);
                Rt.banks[this.bank].push({
                    preview: t,
                    map: t
                }), this.$forceUpdate()
            },
            open() {
                this.isOpen = !0
            },
            close() {
                this.isOpen = !1
            }
        }
    },
    bC = n => (Zt("data-v-cca92ee0"), n = n(), Qt(), n),
    SC = {
        key: 0
    },
    TC = {
        class: "popup_centered popup_medium"
    },
    wC = {
        class: "popup_header"
    },
    EC = bC(() => re("div", null, null, -1)),
    AC = {
        class: "vertical_flex_center"
    },
    RC = {
        style: {
            width: "100%",
            display: "flex",
            "justify-content": "center"
        }
    },
    CC = {
        key: 0,
        class: "texture_list"
    };

function PC(n, e, t, i, r, s) {
    const o = He("CloseIcon"),
        a = He("TextureCard");
    return r.isOpen ? (be(), Ie("div", SC, [re("div", {
        onClick: e[0] || (e[0] = xl(l => s.close(), ["self"])),
        class: "popup_overlay"
    }), re("div", TC, [re("div", wC, [EC, re("h2", AC, jt(t.title), 1), re("div", null, [ve(o, {
        onClick: e[1] || (e[1] = l => s.close())
    })])]), re("div", RC, [re("input", {
        type: "file",
        id: "file_upload",
        name: "file_upload",
        accept: "image/png, image/jpeg",
        onChange: e[2] || (e[2] = (...l) => s.handleImageUpload && s.handleImageUpload(...l)),
        style: {
            "margin-left": "75px"
        }
    }, null, 32)]), r.textures ? (be(), Ie("div", CC, [(be(!0), Ie(Et, null, jn(r.textures, l => (be(), Jt(a, {
        key: l.map,
        src: l.preview,
        onClick: c => n.$emit("select", l.map)
    }, null, 8, ["src", "onClick"]))), 128))])) : rt("", !0)])])) : rt("", !0)
}
const LC = mt(MC, [
        ["render", PC],
        ["__scopeId", "data-v-cca92ee0"]
    ]),
    Co = {
        growthIncrements: {
            name: "Growth Increments",
            min: 5,
            max: 200,
            step: 1
        },
        faces: {
            name: "Faces",
            min: 3,
            max: 20,
            step: 1
        },
        thicknessGrowthFactor: {
            name: "Thickness Growth Factor",
            min: .01,
            max: .15,
            step: .001
        },
        seekSun: {
            name: "Seek Sun",
            min: -.5,
            max: .5,
            step: .01
        },
        gnarl: {
            name: "Gnarl",
            min: 0,
            max: .5,
            step: .01
        },
        branchJointAngle: {
            name: "Branch Joint Angle",
            min: 0,
            max: 180,
            step: 1
        },
        branchDensity: {
            name: "Branch Density",
            min: 0,
            max: 100,
            step: 1
        },
        branchGrowthSpeedReduction: {
            name: "Branch Growth Speed Reduction",
            min: 0,
            max: .9,
            step: .01
        },
        growthEvasionRange: {
            name: "Growth Evasion Range",
            min: 0,
            max: 50,
            step: 1
        },
        growthEvasionStrength: {
            name: "Growth Evasion Strength",
            min: 0,
            max: 1,
            step: .01
        },
        minFoliageSpacing: {
            name: "Min Foliage Spacing",
            min: 0,
            max: 25,
            step: .1
        },
        foliageThreshold: {
            name: "Foliage Threshold",
            min: 0,
            max: 4,
            step: .1
        },
        foliageSize: {
            name: "Foliage Size",
            min: .1,
            max: 20,
            step: .1
        },
        foliageAngle: {
            name: "Foliage Angle",
            min: 0,
            max: 360,
            step: 1
        },
        minFruitSpacing: {
            name: "Min Fruit Spacing",
            min: 1,
            max: 50,
            step: 1
        },
        fruitThreshold: {
            name: "Fruit Threshold",
            min: 0,
            max: 4,
            step: .1
        },
        fruitModelSize: {
            name: "Fruit Model Size",
            min: .1,
            max: 20,
            step: .1
        },
        textureStretch: {
            name: "Texture Stretch",
            min: 1,
            max: 30,
            step: 1
        }
    },
    IC = {
        data() {
            return {
                sliderParams: Co,
                Textures: Rt
            }
        },
        props: {
            currentTreeType: Object
        },
        components: {
            TreeCard: Lh,
            Slider: Ol,
            Dropdown: Ih,
            TextureSelector: LC,
            TextureCard: Nl
        },
        emits: ["setOption"]
    },
    Dh = n => (Zt("data-v-b80fdbc5"), n = n(), Qt(), n),
    DC = {
        class: "texturing"
    },
    OC = Dh(() => re("h3", null, "Bark", -1)),
    NC = {
        class: "texturing_section"
    },
    UC = Dh(() => re("h3", null, "Foliage", -1)),
    FC = {
        class: "texturing_section"
    },
    BC = Dh(() => re("h3", null, "Fruit", -1)),
    kC = {
        class: "texturing_section"
    };

function zC(n, e, t, i, r, s) {
    const o = He("Slider"),
        a = He("TextureCard"),
        l = He("TextureSelector");
    return be(), Ie("section", DC, [OC, re("section", NC, [ve(o, {
        params: r.sliderParams.textureStretch,
        value: t.currentTreeType.texturing.textureStretch,
        onChanged: e[0] || (e[0] = c => n.$emit("setOption", "texturing.textureStretch", c))
    }, null, 8, ["params", "value"]), ve(a, {
        onStrictClick: e[1] || (e[1] = c => n.$refs.bark_diffuse.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.barkDiffuse) || t.currentTreeType.resources.barkDiffuse,
        label: "Diffuse",
        removeButton: !0,
        onRemove: e[2] || (e[2] = c => n.$emit("setOption", "resources.barkDiffuse", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[3] || (e[3] = c => n.$refs.bark_normal.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.barkNormal) || t.currentTreeType.resources.barkNormal,
        label: "Normal",
        removeButton: !0,
        onRemove: e[4] || (e[4] = c => n.$emit("setOption", "resources.barkNormal", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[5] || (e[5] = c => n.$refs.bark_roughness.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.barkRoughness) || t.currentTreeType.resources.barkRoughness,
        label: "Roughness",
        removeButton: !0,
        onRemove: e[6] || (e[6] = c => n.$emit("setOption", "resources.barkRoughness", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"])]), UC, re("section", FC, [ve(a, {
        onStrictClick: e[7] || (e[7] = c => n.$refs.foliage_diffuse.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.foliageDiffuse) || t.currentTreeType.resources.foliageDiffuse,
        label: "Diffuse",
        removeButton: !0,
        onRemove: e[8] || (e[8] = c => n.$emit("setOption", "resources.foliageDiffuse", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[9] || (e[9] = c => n.$refs.foliage_opacity.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.foliageOpacity) || t.currentTreeType.resources.foliageOpacity,
        label: "Opacity",
        removeButton: !0,
        onRemove: e[10] || (e[10] = c => n.$emit("setOption", "resources.foliageOpacity", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[11] || (e[11] = c => n.$refs.foliage_normal.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.foliageNormal) || t.currentTreeType.resources.foliageNormal,
        label: "Normal",
        removeButton: !0,
        onRemove: e[12] || (e[12] = c => n.$emit("setOption", "resources.foliageNormal", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[13] || (e[13] = c => n.$refs.foliage_roughness.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.foliageRoughness) || t.currentTreeType.resources.foliageRoughness,
        label: "Roughness",
        removeButton: !0,
        onRemove: e[14] || (e[14] = c => n.$emit("setOption", "resources.foliageRoughness", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"])]), BC, re("section", kC, [ve(a, {
        onStrictClick: e[15] || (e[15] = c => n.$refs.fruit_diffuse.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.fruitDiffuse) || t.currentTreeType.resources.fruitDiffuse,
        label: "Diffuse",
        removeButton: !0,
        onRemove: e[16] || (e[16] = c => n.$emit("setOption", "resources.fruitDiffuse", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[17] || (e[17] = c => n.$refs.fruit_normal.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.fruitNormal) || t.currentTreeType.resources.fruitNormal,
        label: "Normal",
        removeButton: !0,
        onRemove: e[18] || (e[18] = c => n.$emit("setOption", "resources.fruitNormal", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"]), ve(a, {
        onStrictClick: e[19] || (e[19] = c => n.$refs.fruit_roughness.open()),
        src: r.Textures.findPreviewSrc(t.currentTreeType.resources.fruitRoughness) || t.currentTreeType.resources.fruitRoughness,
        label: "Roughness",
        removeButton: !0,
        onRemove: e[20] || (e[20] = c => n.$emit("setOption", "resources.fruitRoughness", null)),
        style: {
            margin: "10px"
        }
    }, null, 8, ["src"])]), ve(l, {
        onSelect: e[21] || (e[21] = c => n.$emit("setOption", "resources.barkDiffuse", c)),
        title: "Bark Diffuse",
        bank: "bark",
        ref: "bark_diffuse"
    }, null, 512), ve(l, {
        onSelect: e[22] || (e[22] = c => n.$emit("setOption", "resources.barkNormal", c)),
        title: "Bark Normal",
        bank: "bark",
        ref: "bark_normal"
    }, null, 512), ve(l, {
        onSelect: e[23] || (e[23] = c => n.$emit("setOption", "resources.barkRoughness", c)),
        title: "Bark Roughness",
        bank: "bark",
        ref: "bark_roughness"
    }, null, 512), ve(l, {
        onSelect: e[24] || (e[24] = c => n.$emit("setOption", "resources.foliageDiffuse", c)),
        title: "Foliage Diffuse",
        bank: "foliage",
        ref: "foliage_diffuse"
    }, null, 512), ve(l, {
        onSelect: e[25] || (e[25] = c => n.$emit("setOption", "resources.foliageOpacity", c)),
        title: "Foliage Opacity",
        bank: "foliage",
        ref: "foliage_opacity"
    }, null, 512), ve(l, {
        onSelect: e[26] || (e[26] = c => n.$emit("setOption", "resources.foliageNormal", c)),
        title: "Foliage Normal",
        bank: "foliage",
        ref: "foliage_normal"
    }, null, 512), ve(l, {
        onSelect: e[27] || (e[27] = c => n.$emit("setOption", "resources.foliageRoughness", c)),
        title: "Foliage Roughness",
        bank: "foliage",
        ref: "foliage_roughness"
    }, null, 512), ve(l, {
        onSelect: e[28] || (e[28] = c => n.$emit("setOption", "resources.fruitDiffuse", c)),
        title: "Fruit Diffuse",
        bank: "fruit",
        ref: "fruit_diffuse"
    }, null, 512), ve(l, {
        onSelect: e[29] || (e[29] = c => n.$emit("setOption", "resources.fruitNormal", c)),
        title: "Fruit Normal",
        bank: "fruit",
        ref: "fruit_normal"
    }, null, 512), ve(l, {
        onSelect: e[30] || (e[30] = c => n.$emit("setOption", "resources.fruitRoughness", c)),
        title: "Fruit Roughness",
        bank: "fruit",
        ref: "fruit_roughness"
    }, null, 512)])
}
const GC = mt(IC, [
        ["render", zC],
        ["__scopeId", "data-v-b80fdbc5"]
    ]),
    VC = /^[og]\s*(.+)?/,
    HC = /^mtllib /,
    WC = /^usemtl /,
    $C = /^usemap /,
    jp = /\s+/,
    Jp = new L,
    Xc = new L,
    Zp = new L,
    Qp = new L,
    wn = new L,
    Ra = new Fe;

function XC() {
    const n = {
        objects: [],
        object: {},
        vertices: [],
        normals: [],
        colors: [],
        uvs: [],
        materials: {},
        materialLibraries: [],
        startObject: function (e, t) {
            if (this.object && this.object.fromDeclaration === !1) {
                this.object.name = e, this.object.fromDeclaration = t !== !1;
                return
            }
            const i = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
            if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                    name: e || "",
                    fromDeclaration: t !== !1,
                    geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        hasUVIndices: !1
                    },
                    materials: [],
                    smooth: !0,
                    startMaterial: function (r, s) {
                        const o = this._finalize(!1);
                        o && (o.inherited || o.groupCount <= 0) && this.materials.splice(o.index, 1);
                        const a = {
                            index: this.materials.length,
                            name: r || "",
                            mtllib: Array.isArray(s) && s.length > 0 ? s[s.length - 1] : "",
                            smooth: o !== void 0 ? o.smooth : this.smooth,
                            groupStart: o !== void 0 ? o.groupEnd : 0,
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: !1,
                            clone: function (l) {
                                const c = {
                                    index: typeof l == "number" ? l : this.index,
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1
                                };
                                return c.clone = this.clone.bind(c), c
                            }
                        };
                        return this.materials.push(a), a
                    },
                    currentMaterial: function () {
                        if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                    },
                    _finalize: function (r) {
                        const s = this.currentMaterial();
                        if (s && s.groupEnd === -1 && (s.groupEnd = this.geometry.vertices.length / 3, s.groupCount = s.groupEnd - s.groupStart, s.inherited = !1), r && this.materials.length > 1)
                            for (let o = this.materials.length - 1; o >= 0; o--) this.materials[o].groupCount <= 0 && this.materials.splice(o, 1);
                        return r && this.materials.length === 0 && this.materials.push({
                            name: "",
                            smooth: this.smooth
                        }), s
                    }
                }, i && i.name && typeof i.clone == "function") {
                const r = i.clone(0);
                r.inherited = !0, this.object.materials.push(r)
            }
            this.objects.push(this.object)
        },
        finalize: function () {
            this.object && typeof this.object._finalize == "function" && this.object._finalize(!0)
        },
        parseVertexIndex: function (e, t) {
            const i = parseInt(e, 10);
            return (i >= 0 ? i - 1 : i + t / 3) * 3
        },
        parseNormalIndex: function (e, t) {
            const i = parseInt(e, 10);
            return (i >= 0 ? i - 1 : i + t / 3) * 3
        },
        parseUVIndex: function (e, t) {
            const i = parseInt(e, 10);
            return (i >= 0 ? i - 1 : i + t / 2) * 2
        },
        addVertex: function (e, t, i) {
            const r = this.vertices,
                s = this.object.geometry.vertices;
            s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[i + 0], r[i + 1], r[i + 2])
        },
        addVertexPoint: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
        },
        addVertexLine: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
        },
        addNormal: function (e, t, i) {
            const r = this.normals,
                s = this.object.geometry.normals;
            s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[i + 0], r[i + 1], r[i + 2])
        },
        addFaceNormal: function (e, t, i) {
            const r = this.vertices,
                s = this.object.geometry.normals;
            Jp.fromArray(r, e), Xc.fromArray(r, t), Zp.fromArray(r, i), wn.subVectors(Zp, Xc), Qp.subVectors(Jp, Xc), wn.cross(Qp), wn.normalize(), s.push(wn.x, wn.y, wn.z), s.push(wn.x, wn.y, wn.z), s.push(wn.x, wn.y, wn.z)
        },
        addColor: function (e, t, i) {
            const r = this.colors,
                s = this.object.geometry.colors;
            r[e] !== void 0 && s.push(r[e + 0], r[e + 1], r[e + 2]), r[t] !== void 0 && s.push(r[t + 0], r[t + 1], r[t + 2]), r[i] !== void 0 && s.push(r[i + 0], r[i + 1], r[i + 2])
        },
        addUV: function (e, t, i) {
            const r = this.uvs,
                s = this.object.geometry.uvs;
            s.push(r[e + 0], r[e + 1]), s.push(r[t + 0], r[t + 1]), s.push(r[i + 0], r[i + 1])
        },
        addDefaultUV: function () {
            const e = this.object.geometry.uvs;
            e.push(0, 0), e.push(0, 0), e.push(0, 0)
        },
        addUVLine: function (e) {
            const t = this.uvs;
            this.object.geometry.uvs.push(t[e + 0], t[e + 1])
        },
        addFace: function (e, t, i, r, s, o, a, l, c) {
            const u = this.vertices.length;
            let h = this.parseVertexIndex(e, u),
                f = this.parseVertexIndex(t, u),
                d = this.parseVertexIndex(i, u);
            if (this.addVertex(h, f, d), this.addColor(h, f, d), a !== void 0 && a !== "") {
                const p = this.normals.length;
                h = this.parseNormalIndex(a, p), f = this.parseNormalIndex(l, p), d = this.parseNormalIndex(c, p), this.addNormal(h, f, d)
            } else this.addFaceNormal(h, f, d);
            if (r !== void 0 && r !== "") {
                const p = this.uvs.length;
                h = this.parseUVIndex(r, p), f = this.parseUVIndex(s, p), d = this.parseUVIndex(o, p), this.addUV(h, f, d), this.object.geometry.hasUVIndices = !0
            } else this.addDefaultUV()
        },
        addPointGeometry: function (e) {
            this.object.geometry.type = "Points";
            const t = this.vertices.length;
            for (let i = 0, r = e.length; i < r; i++) {
                const s = this.parseVertexIndex(e[i], t);
                this.addVertexPoint(s), this.addColor(s)
            }
        },
        addLineGeometry: function (e, t) {
            this.object.geometry.type = "Line";
            const i = this.vertices.length,
                r = this.uvs.length;
            for (let s = 0, o = e.length; s < o; s++) this.addVertexLine(this.parseVertexIndex(e[s], i));
            for (let s = 0, o = t.length; s < o; s++) this.addUVLine(this.parseUVIndex(t[s], r))
        }
    };
    return n.startObject("", !1), n
}
class qC extends Gi {
    constructor(e) {
        super(e), this.materials = null
    }
    load(e, t, i, r) {
        const s = this,
            o = new Mo(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) {
            try {
                t(s.parse(a))
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
    setMaterials(e) {
        return this.materials = e, this
    }
    parse(e) {
        const t = new XC;
        e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
        const i = e.split(`
`);
        let r = [];
        for (let a = 0, l = i.length; a < l; a++) {
            const c = i[a].trimStart();
            if (c.length === 0) continue;
            const u = c.charAt(0);
            if (u !== "#")
                if (u === "v") {
                    const h = c.split(jp);
                    switch (h[0]) {
                    case "v":
                        t.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), h.length >= 7 ? (Ra.setRGB(parseFloat(h[4]), parseFloat(h[5]), parseFloat(h[6])).convertSRGBToLinear(), t.colors.push(Ra.r, Ra.g, Ra.b)) : t.colors.push(void 0, void 0, void 0);
                        break;
                    case "vn":
                        t.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
                        break;
                    case "vt":
                        t.uvs.push(parseFloat(h[1]), parseFloat(h[2]));
                        break
                    }
                } else if (u === "f") {
                const f = c.slice(1).trim().split(jp),
                    d = [];
                for (let _ = 0, g = f.length; _ < g; _++) {
                    const m = f[_];
                    if (m.length > 0) {
                        const y = m.split("/");
                        d.push(y)
                    }
                }
                const p = d[0];
                for (let _ = 1, g = d.length - 1; _ < g; _++) {
                    const m = d[_],
                        y = d[_ + 1];
                    t.addFace(p[0], m[0], y[0], p[1], m[1], y[1], p[2], m[2], y[2])
                }
            } else if (u === "l") {
                const h = c.substring(1).trim().split(" ");
                let f = [];
                const d = [];
                if (c.indexOf("/") === -1) f = h;
                else
                    for (let p = 0, _ = h.length; p < _; p++) {
                        const g = h[p].split("/");
                        g[0] !== "" && f.push(g[0]), g[1] !== "" && d.push(g[1])
                    }
                t.addLineGeometry(f, d)
            } else if (u === "p") {
                const f = c.slice(1).trim().split(" ");
                t.addPointGeometry(f)
            } else if ((r = VC.exec(c)) !== null) {
                const h = (" " + r[0].slice(1).trim()).slice(1);
                t.startObject(h)
            } else if (WC.test(c)) t.object.startMaterial(c.substring(7).trim(), t.materialLibraries);
            else if (HC.test(c)) t.materialLibraries.push(c.substring(7).trim());
            else if ($C.test(c)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
            else if (u === "s") {
                if (r = c.split(" "), r.length > 1) {
                    const f = r[1].trim().toLowerCase();
                    t.object.smooth = f !== "0" && f !== "off"
                } else t.object.smooth = !0;
                const h = t.object.currentMaterial();
                h && (h.smooth = t.object.smooth)
            } else {
                if (c === "\0") continue;
                console.warn('THREE.OBJLoader: Unexpected line: "' + c + '"')
            }
        }
        t.finalize();
        const s = new es;
        if (s.materialLibraries = [].concat(t.materialLibraries), !(t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) === !0)
            for (let a = 0, l = t.objects.length; a < l; a++) {
                const c = t.objects[a],
                    u = c.geometry,
                    h = c.materials,
                    f = u.type === "Line",
                    d = u.type === "Points";
                let p = !1;
                if (u.vertices.length === 0) continue;
                const _ = new ht;
                _.setAttribute("position", new Ge(u.vertices, 3)), u.normals.length > 0 && _.setAttribute("normal", new Ge(u.normals, 3)), u.colors.length > 0 && (p = !0, _.setAttribute("color", new Ge(u.colors, 3))), u.hasUVIndices === !0 && _.setAttribute("uv", new Ge(u.uvs, 2));
                const g = [];
                for (let y = 0, v = h.length; y < v; y++) {
                    const x = h[y],
                        C = x.name + "_" + x.smooth + "_" + p;
                    let S = t.materials[C];
                    if (this.materials !== null) {
                        if (S = this.materials.create(x.name), f && S && !(S instanceof us)) {
                            const R = new us;
                            Vt.prototype.copy.call(R, S), R.color.copy(S.color), S = R
                        } else if (d && S && !(S instanceof ts)) {
                            const R = new ts({
                                size: 10,
                                sizeAttenuation: !1
                            });
                            Vt.prototype.copy.call(R, S), R.color.copy(S.color), R.map = S.map, S = R
                        }
                    }
                    S === void 0 && (f ? S = new us : d ? S = new ts({
                        size: 1,
                        sizeAttenuation: !1
                    }) : S = new a_, S.name = x.name, S.flatShading = !x.smooth, S.vertexColors = p, t.materials[C] = S), g.push(S)
                }
                let m;
                if (g.length > 1) {
                    for (let y = 0, v = h.length; y < v; y++) {
                        const x = h[y];
                        _.addGroup(x.groupStart, x.groupCount, y)
                    }
                    f ? m = new pu(_, g) : d ? m = new Ua(_, g) : m = new xt(_, g)
                } else f ? m = new pu(_, g[0]) : d ? m = new Ua(_, g[0]) : m = new xt(_, g[0]);
                m.name = c.name, s.add(m)
            } else if (t.vertices.length > 0) {
                const a = new ts({
                        size: 1,
                        sizeAttenuation: !1
                    }),
                    l = new ht;
                l.setAttribute("position", new Ge(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (l.setAttribute("color", new Ge(t.colors, 3)), a.vertexColors = !0);
                const c = new Ua(l, a);
                s.add(c)
            } return s
    }
}
const fi = class fi {
    static async loadModel(e) {
        if (fi.loaded_models.has(e)) return fi.loaded_models.get(e);
        let t = await fi.OBJ_LOADER.loadAsync(e);
        return t = t.children[0], t.geometry = g1(t.geometry), this.loaded_models.set(e, t), t
    }
    static getModel(e) {
        return fi.loaded_models.get(e)
    }
    static copyModel(e) {
        const t = e.clone();
        return t.geometry = e.geometry.clone(), t
    }
    static getPreview(e) {
        if (!e) return "/textures/previews/none.png";
        for (const [t] of Object.entries(this.banks))
            for (let i = 0; i < this.banks[t].length; i++) {
                const r = this.banks[t][i];
                if (r.path == e) return r.preview
            }
    }
    static getName(e) {
        if (!e) return "None";
        for (const [t] of Object.entries(this.banks))
            for (let i = 0; i < this.banks[t].length; i++) {
                const r = this.banks[t][i];
                if (r.path == e) return r.name
            }
    }
    static setTransforms(e, t, i, r) {
        e.position.set(t.x, t.y, t.z), e.rotation.set(i.x, i.y, i.z), e.scale.set(r.x, r.y, r.z)
    }
    static applyTransformToWorldSpace(e) {
        e.updateMatrix(), e.geometry.applyMatrix4(e.matrix)
    }
};
_t(fi, "OBJ_LOADER", new qC), _t(fi, "loaded_models", new Map), _t(fi, "banks", {
    foliage: [{
        name: "Square Plane",
        path: "/models/full_plane.obj",
        preview: "/textures/previews/full_plane.png"
    }, {
        name: "Half Plane",
        path: "/models/med_plane.obj",
        preview: "/textures/previews/half_plane.png"
    }, {
        name: "Thin Plane",
        path: "/models/thin_plane.obj",
        preview: "/textures/previews/thin_plane.png"
    }],
    fruit: [{
        name: "Apple",
        path: "/models/apple_fruit.obj",
        preview: "/textures/fruit/model_apple_preview.png"
    }, {
        name: "Mango",
        path: "/models/mango_fruit.obj",
        preview: "/textures/fruit/model_mango_preview.png"
    }, {
        name: "Lemon",
        path: "/models/lemon_fruit.obj",
        preview: "/textures/fruit/model_lemon_preview.png"
    }]
});
let So = fi;
const YC = {
        data() {
            return {
                models: null,
                isOpen: !1
            }
        },
        emits: ["select"],
        props: {
            title: String,
            bank: String
        },
        components: {
            CloseIcon: ws,
            TextureCard: Nl
        },
        mounted() {
            this.models = So.banks[this.bank]
        },
        methods: {
            async handleModelUpload(n) {
                const e = n.target.files[0],
                    t = URL.createObjectURL(e);
                So.banks[this.bank].push({
                    name: e.name,
                    path: t,
                    preview: "/textures/previews/no_preview.png"
                }), this.$forceUpdate()
            },
            open() {
                this.isOpen = !0
            },
            close() {
                this.isOpen = !1
            }
        }
    },
    KC = n => (Zt("data-v-9bfa1b55"), n = n(), Qt(), n),
    jC = {
        key: 0
    },
    JC = {
        class: "popup_centered popup_medium"
    },
    ZC = {
        class: "popup_header"
    },
    QC = KC(() => re("div", null, null, -1)),
    eP = {
        class: "vertical_flex_center"
    },
    tP = {
        style: {
            width: "100%",
            display: "flex",
            "justify-content": "center"
        }
    },
    nP = {
        key: 0,
        class: "texture_list"
    };

function iP(n, e, t, i, r, s) {
    const o = He("CloseIcon"),
        a = He("TextureCard");
    return r.isOpen ? (be(), Ie("div", jC, [re("div", {
        onClick: e[0] || (e[0] = xl(l => s.close(), ["self"])),
        class: "popup_overlay"
    }), re("div", JC, [re("div", ZC, [QC, re("h2", eP, jt(t.title), 1), re("div", null, [ve(o, {
        onClick: e[1] || (e[1] = l => s.close())
    })])]), re("div", tP, [re("input", {
        type: "file",
        id: "file_upload",
        name: "file_upload",
        accept: ".obj, model/obj",
        onChange: e[2] || (e[2] = (...l) => s.handleModelUpload && s.handleModelUpload(...l)),
        style: {
            "margin-left": "75px"
        }
    }, null, 32)]), r.models ? (be(), Ie("section", nP, [(be(!0), Ie(Et, null, jn(r.models, l => (be(), Jt(a, {
        key: l.path,
        src: l.preview,
        label: l.name,
        onClick: c => n.$emit("select", l.path)
    }, null, 8, ["src", "label", "onClick"]))), 128))])) : rt("", !0)])])) : rt("", !0)
}
const rP = mt(YC, [
        ["render", iP],
        ["__scopeId", "data-v-9bfa1b55"]
    ]),
    sP = {
        data() {
            return {
                sliderParams: Co,
                Models: So
            }
        },
        props: {
            currentTreeType: Object,
            treeTypes: Array
        },
        components: {
            Slider: Ol,
            TextureCard: Nl,
            ModelSelector: rP,
            InfoIcon: y_
        },
        emits: ["setOption"],
        methods: {
            navToDocs(n) {
                const e = this.$router.resolve({
                    path: n
                });
                window.open(e.href, "_blank")
            }
        }
    },
    Es = n => (Zt("data-v-07c435b1"), n = n(), Qt(), n),
    oP = {
        class: "sliders"
    },
    aP = {
        style: {
            display: "flex"
        }
    },
    lP = Es(() => re("h3", null, "Geometry", -1)),
    cP = {
        style: {
            display: "flex"
        }
    },
    uP = Es(() => re("h3", null, "Growth Influence", -1)),
    hP = {
        style: {
            display: "flex"
        }
    },
    fP = Es(() => re("h3", null, "Branches", -1)),
    dP = {
        style: {
            display: "flex"
        }
    },
    pP = Es(() => re("h3", null, "Foliage", -1)),
    mP = {
        style: {
            display: "flex"
        }
    },
    gP = Es(() => re("h3", null, "Fruit", -1)),
    _P = Es(() => re("div", {
        style: {
            "margin-top": "30px"
        }
    }, null, -1));

function vP(n, e, t, i, r, s) {
    const o = He("InfoIcon"),
        a = He("Slider"),
        l = He("TextureCard"),
        c = He("ModelSelector");
    return be(), Ie("section", oP, [re("div", aP, [lP, ve(o, {
        onClick: e[0] || (e[0] = u => s.navToDocs("/docs/geometry")),
        style: {
            width: "25px",
            height: "25px",
            "margin-top": "20px",
            "margin-left": "10px"
        }
    })]), ve(a, {
        params: r.sliderParams.growthIncrements,
        value: t.currentTreeType.meta.growthIncrements,
        onChanged: e[1] || (e[1] = u => {
            n.$emit("setOption", "meta.growthIncrements", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.faces,
        value: t.currentTreeType.parameters.faces,
        onChanged: e[2] || (e[2] = u => {
            n.$emit("setOption", "parameters.faces", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.thicknessGrowthFactor,
        value: t.currentTreeType.parameters.thicknessGrowthFactor,
        onChanged: e[3] || (e[3] = u => {
            n.$emit("setOption", "parameters.thicknessGrowthFactor", u)
        })
    }, null, 8, ["params", "value"]), re("div", cP, [uP, ve(o, {
        onClick: e[4] || (e[4] = u => s.navToDocs("/docs/growthInfluence")),
        style: {
            width: "25px",
            height: "25px",
            "margin-top": "20px",
            "margin-left": "10px"
        }
    })]), ve(a, {
        params: r.sliderParams.seekSun,
        value: t.currentTreeType.parameters.seekSun,
        onChanged: e[5] || (e[5] = u => {
            n.$emit("setOption", "parameters.seekSun", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.gnarl,
        value: t.currentTreeType.parameters.gnarl,
        onChanged: e[6] || (e[6] = u => {
            n.$emit("setOption", "parameters.gnarl", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.growthEvasionRange,
        value: t.currentTreeType.parameters.growthEvasionRange,
        onChanged: e[7] || (e[7] = u => {
            n.$emit("setOption", "parameters.growthEvasionRange", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.growthEvasionStrength,
        value: t.currentTreeType.parameters.growthEvasionStrength,
        onChanged: e[8] || (e[8] = u => {
            n.$emit("setOption", "parameters.growthEvasionStrength", u)
        })
    }, null, 8, ["params", "value"]), re("div", hP, [fP, ve(o, {
        onClick: e[9] || (e[9] = u => s.navToDocs("/docs/branch")),
        style: {
            width: "25px",
            height: "25px",
            "margin-top": "20px",
            "margin-left": "10px"
        }
    })]), ve(a, {
        params: r.sliderParams.branchJointAngle,
        value: t.currentTreeType.parameters.branchJointAngle,
        onChanged: e[10] || (e[10] = u => {
            n.$emit("setOption", "parameters.branchJointAngle", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.branchDensity,
        value: t.currentTreeType.parameters.branchDensity,
        onChanged: e[11] || (e[11] = u => {
            n.$emit("setOption", "parameters.branchDensity", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.branchGrowthSpeedReduction,
        value: t.currentTreeType.parameters.branchGrowthSpeedReduction,
        onChanged: e[12] || (e[12] = u => {
            n.$emit("setOption", "parameters.branchGrowthSpeedReduction", u)
        })
    }, null, 8, ["params", "value"]), re("div", dP, [pP, ve(o, {
        onClick: e[13] || (e[13] = u => s.navToDocs("/docs/foliage")),
        style: {
            width: "25px",
            height: "25px",
            "margin-top": "20px",
            "margin-left": "10px"
        }
    })]), ve(l, {
        onStrictClick: e[14] || (e[14] = u => n.$refs.foliage_model_selector.open()),
        label: r.Models.getName(t.currentTreeType.resources.foliageModel),
        src: r.Models.getPreview(t.currentTreeType.resources.foliageModel),
        style: {
            display: "block",
            "margin-bottom": "20px"
        }
    }, null, 8, ["label", "src"]), ve(a, {
        params: r.sliderParams.minFoliageSpacing,
        value: t.currentTreeType.meta.minFoliageSpacing,
        onChanged: e[15] || (e[15] = u => {
            n.$emit("setOption", "meta.minFoliageSpacing", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.foliageThreshold,
        value: t.currentTreeType.parameters.foliageThreshold,
        onChanged: e[16] || (e[16] = u => {
            n.$emit("setOption", "parameters.foliageThreshold", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.foliageSize,
        value: t.currentTreeType.parameters.foliageSize,
        onChanged: e[17] || (e[17] = u => {
            n.$emit("setOption", "parameters.foliageSize", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.foliageAngle,
        value: t.currentTreeType.parameters.foliageAngle,
        onChanged: e[18] || (e[18] = u => {
            n.$emit("setOption", "parameters.foliageAngle", u)
        })
    }, null, 8, ["params", "value"]), ve(c, {
        onSelect: e[19] || (e[19] = u => n.$emit("setOption", "resources.foliageModel", u)),
        ref: "foliage_model_selector",
        title: "Foliage Model",
        bank: "foliage"
    }, null, 512), re("div", mP, [gP, ve(o, {
        onClick: e[20] || (e[20] = u => s.navToDocs("/docs/fruit")),
        style: {
            width: "25px",
            height: "25px",
            "margin-top": "20px",
            "margin-left": "10px"
        }
    })]), ve(l, {
        onStrictClick: e[21] || (e[21] = u => n.$refs.fruit_model_selector.open()),
        label: "Fruit Model",
        src: r.Models.getPreview(t.currentTreeType.resources.fruitModel),
        style: {
            display: "block",
            "margin-bottom": "5px"
        }
    }, null, 8, ["src"]), t.currentTreeType.resources.fruitModel ? (be(), Ie("button", {
        key: 0,
        onClick: e[22] || (e[22] = u => n.$emit("setOption", "resources.fruitModel", null))
    }, " Remove ")) : rt("", !0), _P, ve(a, {
        params: r.sliderParams.minFruitSpacing,
        value: t.currentTreeType.meta.minFruitSpacing,
        onChanged: e[23] || (e[23] = u => {
            n.$emit("setOption", "meta.minFruitSpacing", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.fruitThreshold,
        value: t.currentTreeType.parameters.fruitThreshold,
        onChanged: e[24] || (e[24] = u => {
            n.$emit("setOption", "parameters.fruitThreshold", u)
        })
    }, null, 8, ["params", "value"]), ve(a, {
        params: r.sliderParams.fruitModelSize,
        value: t.currentTreeType.parameters.fruitModelSize,
        onChanged: e[25] || (e[25] = u => {
            n.$emit("setOption", "parameters.fruitModelSize", u)
        })
    }, null, 8, ["params", "value"]), ve(c, {
        onSelect: e[26] || (e[26] = u => n.$emit("setOption", "resources.fruitModel", u)),
        ref: "fruit_model_selector",
        title: "Fruit Model",
        bank: "fruit"
    }, null, 512), ve(c, {
        onSelect: e[27] || (e[27] = u => n.$emit("setOption", "resources.foliageModel", u)),
        ref: "foliage_model_selector",
        title: "Foliage Model",
        bank: "foliage"
    }, null, 512)])
}
const yP = mt(sP, [
        ["render", vP],
        ["__scopeId", "data-v-07c435b1"]
    ]),
    xP = {
        props: {
            label: String
        }
    },
    MP = {
        class: "card_container"
    },
    bP = {
        style: {
            "margin-bottom": "20px"
        }
    },
    SP = {
        class: "changes_container"
    };

function TP(n, e, t, i, r, s) {
    return be(), Ie("div", MP, [re("h3", bP, jt(t.label), 1), re("div", SP, [Bu(n.$slots, "default", {}, void 0, !0)])])
}
const M_ = mt(xP, [
        ["render", TP],
        ["__scopeId", "data-v-e699c571"]
    ]),
    wP = {},
    Ul = n => (Zt("data-v-d66b34b6"), n = n(), Qt(), n),
    EP = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "plus_circle_icon",
        viewBox: "0 0 24 24",
        "stroke-width": "1",
        stroke: "#2c3e50",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    AP = Ul(() => re("path", {
        stroke: "none",
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1)),
    RP = Ul(() => re("path", {
        d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"
    }, null, -1)),
    CP = Ul(() => re("path", {
        d: "M9 12h6"
    }, null, -1)),
    PP = Ul(() => re("path", {
        d: "M12 9v6"
    }, null, -1)),
    LP = [AP, RP, CP, PP];

function IP(n, e) {
    return be(), Ie("svg", EP, LP)
}
const DP = mt(wP, [
        ["render", IP],
        ["__scopeId", "data-v-d66b34b6"]
    ]),
    OP = {
        props: {
            message: String
        },
        components: {
            PlusCircle: DP
        },
        emits: ["create"],
        methods: {
            createChange() {
                const n = this.$refs.inp,
                    e = parseInt(n.value);
                if (Number.isNaN(e)) {
                    n.focus();
                    return
                }
                if (e < 0) {
                    n.value = 0, n.focus();
                    return
                }
                if (e > 1e3) {
                    n.value = 1e3, n.focus();
                    return
                }
                this.$emit("create", e), n.value = ""
            }
        }
    },
    b_ = n => (Zt("data-v-ade0119e"), n = n(), Qt(), n),
    NP = {
        class: "container"
    },
    UP = b_(() => re("p", {
        class: "vertical_flex_center"
    }, "After ", -1)),
    FP = {
        class: "vertical_flex_center"
    },
    BP = b_(() => re("div", {
        class: "flex_placeholder"
    }, null, -1));

function kP(n, e, t, i, r, s) {
    const o = He("PlusCircle");
    return be(), Ie("section", NP, [UP, re("input", {
        onKeyup: e[0] || (e[0] = ry(a => s.createChange(), ["enter"])),
        ref: "inp",
        type: "number",
        min: "0",
        max: "1000"
    }, null, 544), re("p", FP, jt(t.message), 1), BP, ve(o, {
        onClick: e[1] || (e[1] = a => s.createChange())
    })])
}
const S_ = mt(OP, [
        ["render", kP],
        ["__scopeId", "data-v-ade0119e"]
    ]),
    zP = {},
    GP = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "trash_icon",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "#2c3e50",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    VP = bv('<path stroke="none" d="M0 0h24v24H0z" fill="none" data-v-20c3058c></path><path d="M4 7l16 0" data-v-20c3058c></path><path d="M10 11l0 6" data-v-20c3058c></path><path d="M14 11l0 6" data-v-20c3058c></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" data-v-20c3058c></path><path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" data-v-20c3058c></path>', 6),
    HP = [VP];

function WP(n, e) {
    return be(), Ie("svg", GP, HP)
}
const T_ = mt(zP, [
        ["render", WP],
        ["__scopeId", "data-v-20c3058c"]
    ]),
    $P = {
        data() {
            return {
                sliderParams: Co
            }
        },
        props: {
            currentTreeType: Object
        },
        emits: ["createChange", "removeChange", "setOption", "createChangeSlider", "removeOption"],
        components: {
            ChangeBy: M_,
            NewChange: S_,
            TrashIcon: T_,
            Dropdown: Ih,
            Slider: Ol
        },
        methods: {
            createChangeSlider(n, e, t) {
                this.$emit("createChangeSlider", {
                    index: n,
                    option: e
                }, t)
            }
        }
    },
    XP = {
        class: "new_change_button"
    },
    qP = {
        class: "changes_by_age"
    },
    YP = {
        key: 0,
        value: "thicknessGrowthFactor"
    },
    KP = {
        key: 1,
        value: "growthEvasionRange"
    },
    jP = {
        key: 2,
        value: "growthEvasionStrength"
    },
    JP = {
        key: 3,
        value: "branchJointAngle"
    },
    ZP = {
        key: 4,
        value: "branchDensity"
    },
    QP = {
        key: 5,
        value: "branchGrowthSpeedReduction"
    },
    eL = {
        key: 6,
        value: "seekSun"
    },
    tL = {
        key: 7,
        value: "gnarl"
    },
    nL = {
        key: 8,
        value: "foliageSize"
    };

function iL(n, e, t, i, r, s) {
    const o = He("NewChange"),
        a = He("Slider"),
        l = He("Dropdown"),
        c = He("TrashIcon"),
        u = He("ChangeBy");
    return be(), Ie(Et, null, [re("div", XP, [ve(o, {
        message: ` / ${t.currentTreeType.meta.growthIncrements} Increments`,
        onCreate: e[0] || (e[0] = h => n.$emit("createChange", h, "increment")),
        style: {
            "margin-bottom": "20px"
        }
    }, null, 8, ["message"])]), re("div", qP, [(be(!0), Ie(Et, null, jn(t.currentTreeType.parameters.changesOverAge, (h, f) => (be(), Jt(u, {
        key: h.start,
        label: `After ${h.start} Increments: `
    }, {
        default: Kn(() => [(be(!0), Ie(Et, null, jn(h.changes, (d, p) => (be(), Jt(a, {
            key: p,
            params: r.sliderParams[p],
            value: t.currentTreeType.parameters.changesOverAge[f].changes[p],
            onChanged: _ => {
                n.$emit("setOption", `parameters.changesOverAge[${f}].changes.${p}`, _)
            },
            onRemove: _ => n.$emit("removeOption", `parameters.changesOverAge[${f}].changes.${p}`),
            removable: !0
        }, null, 8, ["params", "value", "onChanged", "onRemove"]))), 128)), ve(l, {
            onSelect: d => s.createChangeSlider(f, d, "increment")
        }, {
            default: Kn(() => [t.currentTreeType.parameters.changesOverAge[f].changes.thicknessGrowthFactor == null ? (be(), Ie("option", YP, " Thickness Growth Factor ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.growthEvasionRange == null ? (be(), Ie("option", KP, " Growth Evasion Range ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.growthEvasionStrength == null ? (be(), Ie("option", jP, " Growth Evasion Strength ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.branchJointAngle == null ? (be(), Ie("option", JP, " Branch Joint Angle ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.branchDensity == null ? (be(), Ie("option", ZP, " Branch Density ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.branchGrowthSpeedReduction == null ? (be(), Ie("option", QP, " Branch Growth Speed Reduction ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.seekSun == null ? (be(), Ie("option", eL, " Seek Sun ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.gnarl == null ? (be(), Ie("option", tL, " Gnarl ")) : rt("", !0), t.currentTreeType.parameters.changesOverAge[f].changes.foliageSize == null ? (be(), Ie("option", nL, " Foliage Size ")) : rt("", !0)]),
            _: 2
        }, 1032, ["onSelect"]), ve(c, {
            onClick: d => n.$emit("removeChange", f, "increment")
        }, null, 8, ["onClick"])]),
        _: 2
    }, 1032, ["label"]))), 128))])], 64)
}
const rL = mt($P, [
        ["render", iL],
        ["__scopeId", "data-v-ddbc06a2"]
    ]),
    sL = {
        data() {
            return {
                sliderParams: Co
            }
        },
        props: {
            currentTreeType: Object
        },
        emits: ["createChange", "removeChange", "setOption", "createChangeSlider", "removeOption"],
        components: {
            ChangeBy: M_,
            NewChange: S_,
            TrashIcon: T_,
            Dropdown: Ih,
            Slider: Ol
        },
        methods: {
            createChangeSlider(n, e, t) {
                this.$emit("createChangeSlider", {
                    index: n,
                    option: e
                }, t)
            }
        }
    },
    oL = {
        class: "new_change_button"
    },
    aL = {
        class: "changes_by_age"
    },
    lL = {
        key: 0,
        value: "thicknessGrowthFactor"
    },
    cL = {
        key: 1,
        value: "growthEvasionRange"
    },
    uL = {
        key: 2,
        value: "growthEvasionStrength"
    },
    hL = {
        key: 3,
        value: "branchJointAngle"
    },
    fL = {
        key: 4,
        value: "branchDensity"
    },
    dL = {
        key: 5,
        value: "seekSun"
    },
    pL = {
        key: 6,
        value: "gnarl"
    },
    mL = {
        key: 7,
        value: "foliageSize"
    };

function gL(n, e, t, i, r, s) {
    const o = He("NewChange"),
        a = He("Slider"),
        l = He("Dropdown"),
        c = He("TrashIcon"),
        u = He("ChangeBy");
    return be(), Ie("div", null, [re("div", oL, [ve(o, {
        message: " Iterations",
        onCreate: e[0] || (e[0] = h => n.$emit("createChange", h, "iteration")),
        style: {
            "margin-bottom": "20px"
        }
    })]), re("div", aL, [(be(!0), Ie(Et, null, jn(t.currentTreeType.parameters.changesOverIteration, (h, f) => (be(), Jt(u, {
        key: h.start,
        label: `After ${h.start} Iteration(s): `
    }, {
        default: Kn(() => [(be(!0), Ie(Et, null, jn(h.changes, (d, p) => (be(), Jt(a, {
            key: p,
            params: r.sliderParams[p],
            value: t.currentTreeType.parameters.changesOverIteration[f].changes[p],
            onChanged: _ => {
                n.$emit("setOption", `parameters.changesOverIteration[${f}].changes.${p}`, _)
            },
            onRemove: _ => n.$emit("removeOption", `parameters.changesOverIteration[${f}].changes.${p}`),
            removable: !0
        }, null, 8, ["params", "value", "onChanged", "onRemove"]))), 128)), ve(l, {
            onSelect: d => s.createChangeSlider(f, d, "iteration")
        }, {
            default: Kn(() => [t.currentTreeType.parameters.changesOverIteration[f].changes.thicknessGrowthFactor == null ? (be(), Ie("option", lL, " Thickness Growth Factor ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.growthEvasionRange == null ? (be(), Ie("option", cL, " Growth Evasion Range ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.growthEvasionStrength == null ? (be(), Ie("option", uL, " Growth Evasion Strength ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.branchJointAngle == null ? (be(), Ie("option", hL, " Branch Joint Angle ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.branchDensity == null ? (be(), Ie("option", fL, " Branch Density ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.seekSun == null ? (be(), Ie("option", dL, " Seek Sun ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.gnarl == null ? (be(), Ie("option", pL, " Gnarl ")) : rt("", !0), t.currentTreeType.parameters.changesOverIteration[f].changes.foliageSize == null ? (be(), Ie("option", mL, " Foliage Size ")) : rt("", !0)]),
            _: 2
        }, 1032, ["onSelect"]), ve(c, {
            onClick: d => n.$emit("removeChange", f, "iteration")
        }, null, 8, ["onClick"])]),
        _: 2
    }, 1032, ["label"]))), 128))])])
}
const _L = mt(sL, [
        ["render", gL],
        ["__scopeId", "data-v-8272a223"]
    ]),
    vL = {
        data() {
            return {
                sliderParams: Co,
                activeTab: "parameters",
                changesOverAge: !0
            }
        },
        props: {
            currentTreeType: Object,
            treeTypes: Array
        },
        components: {
            PreviewSelectorPU: XR,
            TreeCard: Lh,
            InfoIcon: y_,
            ButtonWrapper: m_,
            TexturingOptions: GC,
            ParameterOptions: yP,
            ChangesOverAgeOptions: rL,
            ChangesOverIterationOptions: _L
        },
        emits: ["setTreeType", "setOption", "removeOption", "createChange", "createChangeSlider", "removeChange"],
        created() {
            window.addEventListener("keydown", this.handleKeyDown)
        },
        beforeUnmount() {
            window.removeEventListener("keydown", this.handleKeyDown)
        },
        methods: {
            handleKeyDown(n) {
                if (n.code === "Space") return n.preventDefault(), !1
            },
            navToDocs(n) {
                const e = this.$router.resolve({
                    path: n
                });
                window.open(e.href, "_blank")
            }
        }
    },
    Fl = n => (Zt("data-v-8804d104"), n = n(), Qt(), n),
    yL = {
        style: {
            "overflow-y": "scroll",
            "overflow-x": "visible"
        }
    },
    xL = Fl(() => re("h2", null, "FloraSynth", -1)),
    ML = {
        class: "nav_buttons"
    },
    bL = {
        class: "options_body"
    },
    SL = {
        style: {
            display: "flex"
        }
    },
    TL = Fl(() => re("h3", null, "Geometry", -1)),
    wL = {
        class: "vertical_tab_switcher",
        style: {
            "margin-top": "20px"
        }
    },
    EL = Fl(() => re("hr", {
        style: {
            "margin-top": "20px"
        }
    }, null, -1)),
    AL = {
        key: 1
    },
    RL = {
        style: {
            display: "flex",
            "margin-bottom": "20px"
        }
    },
    CL = Fl(() => re("h3", null, "Changes Over", -1)),
    PL = {
        class: "switch",
        style: {
            "margin-left": "20px",
            "margin-top": "12px"
        }
    };

function LL(n, e, t, i, r, s) {
    const o = He("ButtonWrapper"),
        a = He("PreviewSelectorPU"),
        l = He("InfoIcon"),
        c = He("TreeCard"),
        u = He("TexturingOptions"),
        h = He("ParameterOptions"),
        f = He("ChangesOverAgeOptions"),
        d = He("ChangesOverIterationOptions");
    return be(), Ie("nav", yL, [xL, re("nav", ML, [ve(o, {
        onStrictClick: e[0] || (e[0] = p => s.navToDocs("/docs/introduction"))
    }, {
        default: Kn(() => [ar("About")]),
        _: 1
    }), ve(o, {
        onStrictClick: e[1] || (e[1] = p => s.navToDocs("/docs/tutorial"))
    }, {
        default: Kn(() => [ar("Tutorial")]),
        _: 1
    }), ve(o, {
        onStrictClick: e[2] || (e[2] = p => s.navToDocs("/docs/geometry"))
    }, {
        default: Kn(() => [ar("Reference")]),
        _: 1
    })]), ve(a, {
        onSelect: e[3] || (e[3] = p => n.$emit("setTreeType", p)),
        selectableItems: t.treeTypes,
        currentSelected: t.currentTreeType,
        ref: "tree_type_selector"
    }, null, 8, ["selectableItems", "currentSelected"]), re("section", bL, [re("div", SL, [TL, ve(l, {
        onClick: e[4] || (e[4] = p => s.navToDocs("/docs/tutorial")),
        style: {
            width: "25px",
            height: "25px",
            "margin-top": "20px",
            "margin-left": "10px"
        }
    })]), ve(c, {
        name: t.currentTreeType.meta.name,
        previewSrc: t.currentTreeType.meta.preview,
        class: "preset_selector",
        onStrictClick: e[5] || (e[5] = p => n.$refs.tree_type_selector.open())
    }, null, 8, ["name", "previewSrc"]), re("nav", wL, [re("button", {
        onMousedown: e[6] || (e[6] = p => r.activeTab = "parameters"),
        class: Un({
            active_tab: r.activeTab == "parameters"
        })
    }, " Parameters ", 34), re("button", {
        onMousedown: e[7] || (e[7] = p => r.activeTab = "textures"),
        class: Un({
            active_tab: r.activeTab == "textures"
        })
    }, " Textures ", 34)]), EL, r.activeTab == "textures" ? (be(), Jt(u, {
        key: 0,
        currentTreeType: t.currentTreeType,
        onSetOption: e[8] || (e[8] = (p, _) => {
            n.$emit("setOption", p, _)
        })
    }, null, 8, ["currentTreeType"])) : rt("", !0), r.activeTab == "parameters" ? (be(), Ie("section", AL, [ve(h, {
        currentTreeType: t.currentTreeType,
        onSetOption: e[9] || (e[9] = (p, _) => {
            n.$emit("setOption", p, _)
        })
    }, null, 8, ["currentTreeType"]), re("div", RL, [CL, re("nav", PL, [re("button", {
        onClick: e[10] || (e[10] = p => r.changesOverAge = !0),
        class: Un({
            active_switch: r.changesOverAge
        })
    }, "Age", 2), re("button", {
        onClick: e[11] || (e[11] = p => r.changesOverAge = !1),
        class: Un({
            active_switch: !r.changesOverAge
        })
    }, "Iteration", 2)])]), r.changesOverAge ? (be(), Jt(f, {
        key: 0,
        currentTreeType: t.currentTreeType,
        onSetOption: e[12] || (e[12] = (p, _) => {
            n.$emit("setOption", p, _)
        }),
        onRemoveOption: e[13] || (e[13] = p => {
            n.$emit("removeOption", p)
        }),
        onCreateChange: e[14] || (e[14] = (p, _) => {
            n.$emit("createChange", p, _)
        }),
        onRemoveChange: e[15] || (e[15] = (p, _) => {
            n.$emit("removeChange", p, _)
        }),
        onCreateChangeSlider: e[16] || (e[16] = (p, _) => {
            n.$emit("createChangeSlider", p, _)
        })
    }, null, 8, ["currentTreeType"])) : (be(), Jt(d, {
        key: 1,
        currentTreeType: t.currentTreeType,
        onSetOption: e[17] || (e[17] = (p, _) => {
            n.$emit("setOption", p, _)
        }),
        onRemoveOption: e[18] || (e[18] = p => {
            n.$emit("removeOption", p)
        }),
        onCreateChange: e[19] || (e[19] = (p, _) => {
            n.$emit("createChange", p, _)
        }),
        onRemoveChange: e[20] || (e[20] = (p, _) => {
            n.$emit("removeChange", p, _)
        }),
        onCreateChangeSlider: e[21] || (e[21] = (p, _) => {
            n.$emit("createChangeSlider", p, _)
        })
    }, null, 8, ["currentTreeType"]))])) : rt("", !0)])])
}
const IL = mt(vL, [
        ["render", LL],
        ["__scopeId", "data-v-8804d104"]
    ]),
    em = {
        meta: {
            name: "Ash",
            preview: "/textures/previews/Ash.png",
            growthIncrements: 70,
            minFoliageSpacing: 1,
            minFruitSpacing: 20
        },
        parameters: {
            faces: 6,
            segmentLength: 1,
            thicknessGrowthFactor: .03,
            radiusGrowthRateModifier: .991,
            growthSpeed: 1,
            growthEvasionRange: 8,
            growthEvasionStrength: .7,
            gnarl: .02,
            seekSun: .07,
            branchJointAngle: 45,
            branchGrowthSpeedReduction: .1,
            branchDensity: 15,
            foliageThreshold: .25,
            foliageSize: 8,
            foliageAngle: 300,
            fruitThreshold: .25,
            fruitModelSize: 15,
            changesOverAge: [{
                start: 50,
                changes: {
                    branchDensity: 30,
                    seekSun: .02,
                    growthEvasionRange: 4,
                    growthEvasionStrength: .15,
                    gnarl: .11
                }
            }],
            changesOverIteration: [],
            foliageAngleRotationAxis: "z"
        },
        resources: {
            barkDiffuse: "/textures/bark/bark_color3.png",
            barkNormal: "/textures/bark/bark_normal3.png",
            foliageModel: "/models/full_plane.obj",
            foliageDiffuse: "/textures/foliage/peachleaf_foliage_color.png",
            foliageOpacity: "/textures/foliage/peachleaf_foliage_opacity.png"
        },
        texturing: {
            textureStretch: 8,
            packToAtlas: !1
        }
    },
    DL = {
        meta: {
            name: "Elm",
            preview: "/textures/previews/Elm.png",
            growthIncrements: 70,
            minFoliageSpacing: .25,
            minFruitSpacing: 20
        },
        parameters: {
            faces: 6,
            segmentLength: 1,
            thicknessGrowthFactor: .015,
            radiusGrowthRateModifier: 1,
            growthSpeed: 1,
            growthEvasionRange: 8,
            growthEvasionStrength: .9,
            gnarl: .03,
            seekSun: .02,
            branchJointAngle: 20,
            branchGrowthSpeedReduction: 0,
            branchDensity: 3,
            foliageThreshold: .3,
            foliageSize: 3,
            foliageAngle: 300,
            fruitThreshold: .25,
            fruitModelSize: 15,
            changesOverAge: [{
                start: 45,
                changes: {
                    branchDensity: 30,
                    branchJointAngle: 45,
                    growthEvasionRange: 5,
                    growthEvasionStrength: .9,
                    gnarl: .1
                }
            }],
            changesOverIteration: [],
            foliageAngleRotationAxis: "z"
        },
        resources: {
            barkDiffuse: "/textures/bark/bark_color3.png",
            barkNormal: "/textures/bark/bark_normal3.png",
            foliageModel: "/models/med_plane.obj",
            foliageDiffuse: "/textures/foliage/elm_branch_color.png",
            foliageOpacity: "/textures/foliage/elm_branch_opacity.png"
        },
        texturing: {
            textureStretch: 5,
            packToAtlas: !0
        }
    },
    OL = {
        meta: {
            name: "Oak",
            preview: "/textures/previews/Oak.png",
            growthIncrements: 150,
            minFoliageSpacing: 2,
            minFruitSpacing: 20
        },
        parameters: {
            faces: 6,
            segmentLength: 1,
            thicknessGrowthFactor: .035,
            radiusGrowthRateModifier: .993,
            growthSpeed: 1,
            growthEvasionRange: 8,
            growthEvasionStrength: .7,
            gnarl: .02,
            seekSun: .05,
            branchJointAngle: 45,
            branchGrowthSpeedReduction: .1,
            branchDensity: 7,
            foliageThreshold: .3,
            foliageSize: 13,
            foliageAngle: 300,
            fruitThreshold: .25,
            fruitModelSize: 1,
            changesOverAge: [{
                start: 135,
                changes: {
                    branchDensity: 50,
                    seekSun: -.05
                }
            }],
            changesOverIteration: [],
            foliageAngleRotationAxis: "z"
        },
        resources: {
            barkDiffuse: "/textures/bark/bark_color3.png",
            barkNormal: "/textures/bark/bark_normal3.png",
            foliageModel: "/models/med_plane.obj",
            foliageDiffuse: "/textures/foliage/oak_foliage_color.png",
            foliageOpacity: "/textures/foliage/oak_foliage_opacity.png"
        },
        texturing: {
            textureStretch: 20,
            packToAtlas: !0
        }
    },
    NL = {
        data() {
            return {
                currentTreeType: em,
                treeTypes: [em, DL, OL]
            }
        },
        components: {
            OptionsPanel: IL,
            ThreeRender: IR
        },
        methods: {
            setCurrentTreeType(n) {
                this.currentTreeType = n
            },
            setOption(n, e, t = !1) {
                const i = n.split(".");
                let r = this.currentTreeType;
                for (let s = 0; s < i.length - 1; s++)
                    if (i[s].indexOf("[") != -1) {
                        const o = parseInt(i[s].substring(i[s].indexOf("[") + 1, i[s].indexOf("]")));
                        r = r[i[s].substring(0, i[s].indexOf("["))][o]
                    } else r = r[i[s]];
                t ? delete r[i[i.length - 1]] : r[i[i.length - 1]] = e
            },
            createChange(n, e) {
                const t = e == "increment" ? this.currentTreeType.parameters.changesOverAge : this.currentTreeType.parameters.changesOverIteration,
                    i = {
                        start: n,
                        changes: {}
                    };
                let r = !1;
                for (let s = 0; s < t.length; s++)
                    if (n < t[s].start) {
                        t.splice(s, 0, i), r = !0;
                        break
                    } else if (n == t[s].start) return;
                r || t.push(i)
            },
            createChangeSlider(n, e) {
                const t = e == "increment" ? this.currentTreeType.parameters.changesOverAge : this.currentTreeType.parameters.changesOverIteration;
                t[n.index].changes[n.option] == null && (t[n.index].changes[n.option] = this.currentTreeType.parameters[n.option])
            },
            removeChange(n, e) {
                (e == "increment" ? this.currentTreeType.parameters.changesOverAge : this.currentTreeType.parameters.changesOverIteration).splice(n, 1)
            }
        }
    },
    UL = {
        class: "home_container"
    };

function FL(n, e, t, i, r, s) {
    const o = He("OptionsPanel"),
        a = He("ThreeRender");
    return be(), Ie("main", UL, [ve(o, {
        class: "opt_panel",
        currentTreeType: r.currentTreeType,
        treeTypes: r.treeTypes,
        onSetTreeType: s.setCurrentTreeType,
        onSetOption: s.setOption,
        onRemoveOption: e[0] || (e[0] = l => {
            s.setOption(l, null, !0)
        }),
        onCreateChange: s.createChange,
        onCreateChangeSlider: s.createChangeSlider,
        onRemoveChange: s.removeChange
    }, null, 8, ["currentTreeType", "treeTypes", "onSetTreeType", "onSetOption", "onCreateChange", "onCreateChangeSlider", "onRemoveChange"]), ve(a, {
        class: "three_render",
        ref: "three_render",
        currentTreeType: r.currentTreeType
    }, null, 8, ["currentTreeType"])])
}
const BL = mt(NL, [
        ["render", FL],
        ["__scopeId", "data-v-88ca47fc"]
    ]),
    kL = {},
    zL = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "search_icon",
        viewBox: "0 0 24 24",
        "stroke-width": "1",
        stroke: "#1f1f1f",
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    },
    GL = re("path", {
        stroke: "none",
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1),
    VL = re("path", {
        d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"
    }, null, -1),
    HL = re("path", {
        d: "M21 21l-6 -6"
    }, null, -1),
    WL = [GL, VL, HL];

function $L(n, e) {
    return be(), Ie("svg", zL, WL)
}
const XL = mt(kL, [
        ["render", $L]
    ]),
    qL = [{
        header: "Tutorial",
        sections: [{
            subheader: "Introduction",
            link: "/docs/introduction"
        }, {
            subheader: "Tutorial",
            link: "/docs/tutorial"
        }]
    }, {
        header: "Reference",
        sections: [{
            subheader: "Geometry",
            link: "/docs/geometry"
        }, {
            subheader: "Growth Influence",
            link: "/docs/growthInfluence"
        }, {
            subheader: "Branch",
            link: "/docs/branch"
        }, {
            subheader: "Foliage",
            link: "/docs/foliage"
        }, {
            subheader: "Fruit",
            link: "/docs/fruit"
        }, {
            subheader: "Changes over age",
            link: "/docs/changesOverAge"
        }, {
            subheader: "Texturing",
            link: "/docs/texturing"
        }]
    }],
    YL = {
        data() {
            return {
                burgerMenuOpen: !1,
                sections: qL,
                searchedSections: []
            }
        },
        components: {
            SearchIcon: XL,
            BurgerIcon: p_,
            CloseIcon: ws
        },
        methods: {
            search(n) {
                this.searchedSections = [];
                const e = n.target.value.toLowerCase();
                if (!(e.length < 3))
                    for (let t = 0; t < this.sections.length; t++)
                        for (let i = 0; i < this.sections[t].sections.length; i++) this.sections[t].sections[i].subheader.toLowerCase().indexOf(e) != -1 && this.searchedSections.push(this.sections[t].sections[i])
            },
            navToSection(n) {
                this.$router.push(n), this.burgerMenuOpen = !1
            },
            navToFlorasynth() {
                const n = this.$router.resolve({
                    name: "home"
                });
                window.open(n.href, "_blank")
            }
        }
    },
    KL = n => (Zt("data-v-937c1544"), n = n(), Qt(), n),
    jL = {
        class: "page_container"
    },
    JL = {
        style: {
            display: "flex",
            "background-color": "#a3b18a",
            "box-sizing": "border-box"
        }
    },
    ZL = {
        key: 0,
        style: {
            width: "40px"
        }
    },
    QL = KL(() => re("h2", {
        style: {
            "flex-grow": "1"
        }
    }, "Florasynth Docs", -1)),
    eI = {
        key: 1,
        style: {
            display: "flex",
            "flex-direction": "column",
            "justify-content": "center"
        }
    },
    tI = {
        class: "searchbar"
    },
    nI = {
        class: "sections"
    },
    iI = {
        key: 0
    },
    rI = ["onClick"],
    sI = {
        key: 1
    },
    oI = ["onClick"],
    aI = {
        class: "right_panel"
    };

function lI(n, e, t, i, r, s) {
    const o = He("BurgerIcon"),
        a = He("CloseIcon"),
        l = He("SearchIcon"),
        c = He("router-view");
    return be(), Ie("div", jL, [ve(o, {
        onClick: e[0] || (e[0] = u => r.burgerMenuOpen = !0),
        class: "burger_icon"
    }), r.burgerMenuOpen ? (be(), Ie("div", {
        key: 0,
        onClick: e[1] || (e[1] = xl(u => r.burgerMenuOpen = !1, ["self"])),
        class: "overlay"
    })) : rt("", !0), re("nav", {
        class: Un(["left_panel", {
            burger_menu_open: r.burgerMenuOpen
        }])
    }, [re("div", JL, [r.burgerMenuOpen ? (be(), Ie("div", ZL)) : rt("", !0), QL, r.burgerMenuOpen ? (be(), Ie("div", eI, [ve(a, {
        onClick: e[2] || (e[2] = u => r.burgerMenuOpen = !1),
        style: {
            width: "30px",
            height: "100%",
            "padding-right": "10px"
        }
    })])) : rt("", !0)]), re("div", tI, [ve(l, {
        style: {
            display: "block",
            width: "35px"
        }
    }), re("input", {
        onInput: e[3] || (e[3] = (...u) => s.search && s.search(...u)),
        placeholder: "Search...",
        ref: "searchbar"
    }, null, 544)]), re("nav", nI, [r.searchedSections.length == 0 ? (be(), Ie("section", iI, [(be(!0), Ie(Et, null, jn(r.sections, u => (be(), Ie("div", {
        key: u.header
    }, [re("h3", null, jt(u.header), 1), (be(!0), Ie(Et, null, jn(u.sections, h => (be(), Ie("h4", {
        key: h.subheader,
        class: Un({
            selected: n.$route.path == h.link
        }),
        onClick: f => s.navToSection(h.link)
    }, jt(h.subheader), 11, rI))), 128))]))), 128))])) : (be(), Ie("section", sI, [(be(!0), Ie(Et, null, jn(r.searchedSections, u => (be(), Ie("h4", {
        key: u.subheader,
        class: Un({
            selected: n.$route.path == u.link
        }),
        onClick: h => s.navToSection(u.link)
    }, jt(u.subheader), 11, oI))), 128))])), re("button", {
        class: "general_btn",
        onClick: e[4] || (e[4] = (...u) => s.navToFlorasynth && s.navToFlorasynth(...u)),
        style: {
            "margin-top": "20px"
        }
    }, " Go to Florasynth ")])], 2), re("section", aI, [re("div", null, [ve(c)])])])
}
const cI = mt(YL, [
        ["render", lI],
        ["__scopeId", "data-v-937c1544"]
    ]),
    w_ = ux({
        history: Ay("/"),
        routes: [{
            path: "/",
            name: "home",
            component: BL,
            meta: {
                title: "Florasynth Tree Generator",
                metaTags: [{
                    name: "keywords",
                    content: "procedural, generation, trees, 3D tree models, tree creator"
                }, {
                    name: "description",
                    content: "An online procedural tree model generator called Florasynth"
                }]
            }
        }, {
            path: "/docs",
            component: cI,
            children: [{
                path: "",
                name: "empty",
                redirect: {
                    name: "Introduction"
                }
            }, {
                path: "introduction",
                name: "Introduction",
                component: () => ri(() => import("./Introduction-CZHuZ-rG.js"), __vite__mapDeps([0, 1])),
                meta: {
                    title: "Introduction - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, introduction"
                    }, {
                        name: "description",
                        content: "Introduction to the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "tutorial",
                name: "Tutorial",
                component: () => ri(() => import("./Tutorial-DmabWX4a.js"), __vite__mapDeps([2, 3, 4])),
                meta: {
                    title: "Tutorial - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, tutorial, documentation"
                    }, {
                        name: "description",
                        content: "Brief tutorial for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "geometry",
                name: "Geometry",
                component: () => ri(() => import("./Geometry-DBfkJt5W.js"), __vite__mapDeps([5, 6])),
                meta: {
                    title: "Geometry - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "growthInfluence",
                name: "GrowthInfluence",
                component: () => ri(() => import("./GrowthInfluence-pOi3bAVv.js"), __vite__mapDeps([7, 8])),
                meta: {
                    title: "Growth Influence - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "branch",
                name: "Branch",
                component: () => ri(() => import("./Branch-vZEzLl-k.js"), __vite__mapDeps([9, 10])),
                meta: {
                    title: "Branches - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "foliage",
                name: "Foliage",
                component: () => ri(() => import("./Foliage-CWqnDO8c.js"), __vite__mapDeps([11, 12])),
                meta: {
                    title: "Foliage - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "fruit",
                name: "Fruit",
                component: () => ri(() => import("./Fruit-D9AFu9Ov.js"), __vite__mapDeps([13, 14])),
                meta: {
                    title: "Fruit - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "changesOverAge",
                name: "ChangesOverAge",
                component: () => ri(() => import("./ChangesOverAge-B8pQzDq4.js"), __vite__mapDeps([15, 16])),
                meta: {
                    title: "Changes Over Age - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }, {
                path: "texturing",
                name: "Texturing",
                component: () => ri(() => import("./Texturing-DD_9CI-z.js"), __vite__mapDeps([17, 3, 18])),
                meta: {
                    title: "Texturing - Florasynth Docs",
                    metaTags: [{
                        name: "keywords",
                        content: "procedural, generation, trees, 3D tree models, tree creator, documentation"
                    }, {
                        name: "description",
                        content: "Documentation for the Florasynth online procedural tree generator"
                    }]
                }
            }]
        }]
    });
w_.beforeEach((n, e, t) => {
    const i = n.matched.slice().reverse().find(o => o.meta && o.meta.title),
        r = n.matched.slice().reverse().find(o => o.meta && o.meta.metaTags),
        s = e.matched.slice().reverse().find(o => o.meta && o.meta.metaTags);
    if (i ? document.title = i.meta.title : s && (document.title = s.meta.title), Array.from(document.querySelectorAll("[data-vue-router-controlled]")).map(o => o.parentNode.removeChild(o)), !r) return t();
    r.meta.metaTags.map(o => {
        const a = document.createElement("meta");
        return Object.keys(o).forEach(l => {
            a.setAttribute(l, o[l])
        }), a.setAttribute("data-vue-router-controlled", ""), a
    }).forEach(o => document.head.appendChild(o)), t()
});

function bu(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t, n
}

function tm(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function (r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })), t.push.apply(t, i)
    }
    return t
}

function Su(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? tm(Object(t), !0).forEach(function (i) {
            bu(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : tm(Object(t)).forEach(function (i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
var uI = function (e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return new Promise(function (i, r) {
            if (!(typeof document > "u")) {
                var s = document.head || document.getElementsByTagName("head")[0],
                    o = document.createElement("script");
                if (o.async = !0, o.src = e, o.defer = t.defer, t.preconnectOrigin) {
                    var a = document.createElement("link");
                    a.href = t.preconnectOrigin, a.rel = "preconnect", s.appendChild(a)
                }
                s.appendChild(o), o.onload = i, o.onerror = r
            }
        })
    },
    hI = function n(e) {
        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
        if (!i.length) return e;
        var s = i.shift();
        if (!(!$s(e) || !$s(s))) {
            for (var o in s) $s(s[o]) ? (e[o] || Object.assign(e, bu({}, o, {})), n(e[o], s[o])) : Object.assign(e, bu({}, o, s[o]));
            return n.apply(void 0, [e].concat(i))
        }
    },
    Po = function () {
        return !(typeof window > "u" || typeof document > "u")
    },
    nm = function (e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        Po()
    },
    fI = function () {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return nm('Missing "appName" property inside the plugin options.', e.app_name == null), nm('Missing "name" property in the route.', e.screen_name == null), e
    };

function dI() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
        e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
        t = n.split("/"),
        i = e.split("/");
    return t[0] === "" && e[e.length - 1] === "/" && t.shift(), i.join("/") + t.join("/")
}
var pI = function () {
        return {
            bootstrap: !0,
            onReady: null,
            onError: null,
            onBeforeTrack: null,
            onAfterTrack: null,
            pageTrackerTemplate: null,
            customResourceURL: "https://www.googletagmanager.com/gtag/js",
            customPreconnectOrigin: "https://www.googletagmanager.com",
            deferScriptLoad: !1,
            pageTrackerExcludedRoutes: [],
            pageTrackerEnabled: !0,
            enabled: !0,
            disableScriptLoad: !1,
            pageTrackerScreenviewEnabled: !1,
            appName: null,
            pageTrackerUseFullPath: !1,
            pageTrackerPrependBase: !0,
            pageTrackerSkipSamePath: !0,
            globalDataLayerName: "dataLayer",
            globalObjectName: "gtag",
            defaultGroupName: "default",
            includes: null,
            config: {
                id: null,
                params: {
                    send_page_view: !1
                }
            }
        }
    },
    E_ = {},
    mI = function () {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            t = pI();
        E_ = hI(t, e)
    },
    bn = function () {
        return E_
    },
    gr = function () {
        var n, e = bn(),
            t = e.globalObjectName;
        !Po() || typeof window[t] > "u" || (n = window)[t].apply(n, arguments)
    },
    Oh = function () {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
        var i = bn(),
            r = i.config,
            s = i.includes;
        gr.apply(void 0, ["config", r.id].concat(e)), Array.isArray(s) && s.forEach(function (o) {
            gr.apply(void 0, ["config", o.id].concat(e))
        })
    },
    im = function (e, t) {
        Po() && (window["ga-disable-".concat(e)] = t)
    },
    A_ = function () {
        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0,
            e = bn(),
            t = e.config,
            i = e.includes;
        im(t.id, n), Array.isArray(i) && i.forEach(function (r) {
            return im(r.id, n)
        })
    },
    R_ = function () {
        A_(!0)
    },
    gI = function () {
        A_(!1)
    },
    C_, _I = function (e) {
        C_ = e
    },
    Nh = function () {
        return C_
    },
    Tr = function (n) {
        var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            t = bn(),
            i = t.includes,
            r = t.defaultGroupName;
        e.send_to == null && Array.isArray(i) && i.length && (e.send_to = i.map(function (s) {
            return s.id
        }).concat(r)), gr("event", n, e)
    },
    P_ = function (n) {
        if (Po()) {
            var e;
            if (typeof n == "string") e = {
                page_path: n
            };
            else if (n.path || n.fullPath) {
                var t = bn(),
                    i = t.pageTrackerUseFullPath,
                    r = t.pageTrackerPrependBase,
                    s = Nh(),
                    o = s && s.options.base,
                    a = i ? n.fullPath : n.path;
                e = Su(Su({}, n.name && {
                    page_title: n.name
                }), {}, {
                    page_path: r ? dI(a, o) : a
                })
            } else e = n;
            e.page_location == null && (e.page_location = window.location.href), e.send_page_view == null && (e.send_page_view = !0), Tr("page_view", e)
        }
    },
    L_ = function (n) {
        var e = bn(),
            t = e.appName;
        if (n) {
            var i;
            typeof n == "string" ? i = {
                screen_name: n
            } : i = n, i.app_name = i.app_name || t, Tr("screen_view", i)
        }
    },
    vI = function () {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
        Tr.apply(void 0, ["exception"].concat(e))
    },
    yI = function (n) {
        Oh("linker", n)
    },
    xI = function (n) {
        Tr("timing_complete", n)
    },
    MI = function () {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
        gr.apply(void 0, ["set"].concat(e))
    },
    bI = function () {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
        Tr.apply(void 0, ["refund"].concat(e))
    },
    SI = function (n) {
        Tr("purchase", n)
    },
    TI = function (n) {
        Oh({
            custom_map: n
        })
    },
    wI = Object.freeze({
        __proto__: null,
        query: gr,
        config: Oh,
        optOut: R_,
        optIn: gI,
        pageview: P_,
        screenview: L_,
        exception: vI,
        linker: yI,
        time: xI,
        set: MI,
        refund: bI,
        purchase: SI,
        customMap: TI,
        event: Tr
    }),
    EI = function (e) {
        e.config.globalProperties.$gtag = wI
    },
    AI = function () {
        if (Po()) {
            var n = bn(),
                e = n.enabled,
                t = n.globalObjectName,
                i = n.globalDataLayerName;
            return window[t] == null && (window[i] = window[i] || [], window[t] = function () {
                window[i].push(arguments)
            }), window[t]("js", new Date), e || R_(), window[t]
        }
    },
    rm = function (e) {
        return Su({
            send_page_view: !1
        }, e)
    },
    I_ = function () {
        var n = bn(),
            e = n.config,
            t = n.includes;
        gr("config", e.id, rm(e.params)), Array.isArray(t) && t.forEach(function (i) {
            gr("config", i.id, rm(i.params))
        })
    },
    sm = function () {
        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            t = bn(),
            i = t.appName,
            r = t.pageTrackerTemplate,
            s = t.pageTrackerScreenviewEnabled,
            o = t.pageTrackerSkipSamePath;
        if (!(o && n.path === e.path)) {
            var a = n;
            if ($e(r) ? a = r(n, e) : s && (a = fI({
                    app_name: i,
                    screen_name: n.name
                })), s) {
                L_(a);
                return
            }
            P_(a)
        }
    },
    om = function (e) {
        var t = bn(),
            i = t.pageTrackerExcludedRoutes;
        return i.includes(e.path) || i.includes(e.name)
    },
    RI = function () {
        var n = bn(),
            e = n.onBeforeTrack,
            t = n.onAfterTrack,
            i = Nh();
        i.isReady().then(function () {
            za().then(function () {
                var r = i.currentRoute;
                I_(), !om(r.value) && sm(r.value)
            }), i.afterEach(function (r, s) {
                za().then(function () {
                    om(r) || ($e(e) && e(r, s), sm(r, s), $e(t) && t(r, s))
                })
            })
        })
    },
    CI = function () {
        var n = bn(),
            e = n.onReady,
            t = n.onError,
            i = n.globalObjectName,
            r = n.globalDataLayerName,
            s = n.config,
            o = n.customResourceURL,
            a = n.customPreconnectOrigin,
            l = n.deferScriptLoad,
            c = n.pageTrackerEnabled,
            u = n.disableScriptLoad,
            h = !!(c && Nh());
        if (AI(), h ? RI() : I_(), !u) return uI("".concat(o, "?id=").concat(s.id, "&l=").concat(r), {
            preconnectOrigin: a,
            defer: l
        }).then(function () {
            e && e(window[i])
        }).catch(function (f) {
            return t && t(f), f
        })
    },
    PI = function (e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            i = arguments.length > 2 ? arguments[2] : void 0;
        EI(e), mI(t), _I(i), bn().bootstrap && CI()
    };
const Uh = ay(fx);
Uh.use(w_);
Uh.use(PI, {
    config: {
        id: "G-L5Q0X7LK4J",
        params: {
            send_page_view: !0
        }
    }
});
Uh.mount("#app");
export {
    mt as _, re as a, bv as b, Ie as c, be as o
};