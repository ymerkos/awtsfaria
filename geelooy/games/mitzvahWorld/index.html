<div id="BH">B"H</div>
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Awtsmoos c-kids Mitzvah World</title>
		<meta charset=utf-8 />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			Awtsmoos - C-Kids Mitzvah World. Do a Mitzvah, draw light into the world.<br />
			MOUSE to look around, drag with left mouse button and scroll in and out.<br/>
			WASD / arrow keys to move and SPACE to jump. E and Q to move side to side.
		</div>
		<div id="container"></div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
                "imports": {
                    "three": "/games/scripts/build/three.module.js",
                    "three/addons/": "/games/scripts/jsm/"
                }
            }
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Octree } from 'three/addons/math/Octree.js';
	
			import { Capsule } from 'three/addons/math/Capsule.js';

	
			const clock = new THREE.Clock();

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x88ccee );
			scene.fog = new THREE.Fog( 0x88ccee, 0, 50 );

			const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.rotation.order = 'YXZ';

			const fillLight1 = new THREE.HemisphereLight( 0x8dc1de, 0x00668d, 0.5 );
			fillLight1.position.set( 2, 1, 1 );
			scene.add( fillLight1 );

			const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
			directionalLight.position.set( - 5, 25, - 1 );
            /*
			directionalLight.castShadow = true;
			directionalLight.shadow.camera.near = 0.01;
			directionalLight.shadow.camera.far = 500;
			directionalLight.shadow.camera.right = 30;
			directionalLight.shadow.camera.left = - 30;
			directionalLight.shadow.camera.top	= 30;
			directionalLight.shadow.camera.bottom = - 30;
			directionalLight.shadow.mapSize.width = 1024;
			directionalLight.shadow.mapSize.height = 1024;
			directionalLight.shadow.radius = 4;
			directionalLight.shadow.bias = - 0.00006;*/
			scene.add( directionalLight );

			const container = document.getElementById( 'container' );

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.VSMShadowMap;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			container.appendChild( renderer.domElement );

            const GRAVITY = 0;

            const MIN_CAMERA_DISTANCE = 3;
const MAX_CAMERA_DISTANCE = 10;
let radius = 5; // distance from player to camera

const STEPS_PER_FRAME = 5;
const worldOctree = new Octree();
const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
const playerVelocity = new THREE.Vector3();
const playerDirection = new THREE.Vector3();
let playerOnFloor = false;

const keyStates = {};

const raycaster = new THREE.Raycaster();

document.addEventListener( 'keydown', ( event ) => {
    keyStates[ event.code ] = true;
});

document.addEventListener( 'keyup', ( event ) => {
    keyStates[ event.code ] = false;
});

let mouseDown = false;
let angle = 0;

addEventListener('mousedown', (event) => {
    if (event.button === THREE.MOUSE.LEFT) {
        document.body.requestPointerLock();
        mouseDown = true;
    }
});

addEventListener('mouseup', (event) => {

    document.exitPointerLock();
    mouseDown = false;
    
});
// Variables to handle spherical coordinates
let theta = 0; // azimuthal angle
let phi = Math.PI / 2; // polar angle

document.body.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === document.body && mouseDown) {
        theta -= event.movementX / 500;
        phi -= event.movementY / 500;

        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi)); // prevent camera flip at zenith
    }
});

document.addEventListener('wheel', (event) => {
    // Adjust the speed of zooming here. The '- event.deltaY * 0.01' part can be changed as needed
    radius -= event.deltaY * 0.01;
    // Clamp the radius between the minimum and maximum camera distance
    radius = Math.max(MIN_CAMERA_DISTANCE, Math.min(MAX_CAMERA_DISTANCE, radius));
});

function teleportPlayerIfOob() {

if ( camera.position.y <= - 25 ) {

    playerCollider.start.set( 0, 0.35, 0 );
    playerCollider.end.set( 0, 1, 0 );
    playerCollider.radius = 0.35;
    camera.position.copy( playerCollider.end );
    camera.rotation.set( 0, 0, 0 );

}

}

let playerRotation = 0;
let jumping = false;
function controls( deltaTime ) {
    const speedDelta = deltaTime * ( playerOnFloor ? 25 : 8 );
    const backwardsSpeedDelta = speedDelta * 0.7;
    const rotationSpeed = 2.0 * deltaTime; // Adjust as needed

    // Forward and Backward controls
    if ( keyStates[ 'KeyW' ] || keyStates[ 'ArrowUp' ] ) {
        playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
    }

    if ( keyStates[ 'KeyS' ] || keyStates[ 'ArrowDown' ] ) {
        playerVelocity.add( getForwardVector().multiplyScalar( -backwardsSpeedDelta ) );
    }

    // Rotation controls
    if ( keyStates[ 'KeyA' ] ) {
        playerRotation += rotationSpeed; // Rotate player left
    }

    if ( keyStates[ 'KeyD' ] ) {
        playerRotation -= rotationSpeed; // Rotate player right
    }

    // Striding controls
    if ( keyStates[ 'KeyQ' ] ) {
        playerVelocity.add( getSideVector().multiplyScalar( -speedDelta ) );
    }

    if ( keyStates[ 'KeyE' ] ) {
        playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
    }

    // Jump control
    if ( playerOnFloor && keyStates[ 'Space' ]) {
        playerVelocity.y = 15;
        jumping = true;
    } else {
        jumping = false;
    }
}

function playerCollisions() {

    const result = worldOctree.capsuleIntersect( playerCollider );
    playerOnFloor = false;
    if ( result ) {
        playerOnFloor = result.normal.y > 0;
        if ( ! playerOnFloor ) {
            playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
        }
        playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
    }
}

playerCollider.isAwduhm = true;
let objectsInScene = [];


function adjustCameraPositionBasedOnIntersections(intersections) {
    let closestIntersection = null;
    let intersectionDistance = null;

    intersections.forEach(intersection => {
        let distance = playerCollider.end.distanceTo(intersection.point);
        
        if (closestIntersection === null || distance < intersectionDistance) {
            closestIntersection = intersection;
            intersectionDistance = distance;
        }
    });

    if (closestIntersection !== null) {
        let newPosition = closestIntersection.point.clone();

        // Nudge camera out of the object, include a buffer
        let buffer = 1; // Increase this as necessary
        let offset = closestIntersection.face.normal.clone().multiplyScalar(0.5 + buffer);
        newPosition.add(offset);

        // Smoothly transition camera to newPosition
        if (camera.position.distanceToSquared(newPosition) > 0.01) {
            camera.position.lerp(newPosition, 0.1); // Increase the lerp value
        }
    } else {
        if (camera.position.distanceToSquared(desiredCameraPosition) > 0.01) {
            camera.position.lerp(desiredCameraPosition, 0.1); // Increase the lerp value
        }
    }

    if (jumping) {
        if (camera.position.distanceToSquared(playerCollider.end) > 0.01) {
            let newPosition = playerCollider.end.clone().add(new THREE.Vector3(0, 2, -5));
            camera.position.lerp(newPosition, 0.1); // Adjust as necessary
        }
    }
}

function cameraCollisions() {
    playerDirection.copy(desiredCameraPosition).sub(playerCollider.end).normalize();
    raycaster.set(playerCollider.end, playerDirection);
    
    // Raycast from player to camera
    const playerToCameraIntersections = raycaster.intersectObjects(objectsInScene, true);
    adjustCameraPositionBasedOnIntersections(playerToCameraIntersections);
}





const playerGeometry = new THREE.CylinderGeometry( 0.35, 0.35, 0.65, 8 );
const playerMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00} );
const playerMesh = new THREE.Mesh( playerGeometry, playerMaterial );

scene.add( playerMesh );
function updatePlayer( deltaTime ) {

let damping = Math.exp( - 4 * deltaTime ) - 1;

if ( ! playerOnFloor ) {

    playerVelocity.y -= GRAVITY * deltaTime;

    // small air resistance
    damping *= 0.1;

}

playerVelocity.addScaledVector( playerVelocity, damping );

const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
playerCollider.translate( deltaPosition );

playerCollisions();

playerMesh.position.copy( playerCollider.end );
playerMesh.rotation.y = playerRotation;

// Update camera position based on spherical coordinates

let totalRotation = theta + playerRotation; // Combine mouse and player rotation
desiredCameraPosition.x = playerCollider.end.x + radius * Math.sin(phi) * Math.sin(totalRotation);
desiredCameraPosition.y = playerCollider.end.y + radius * Math.cos(phi);
desiredCameraPosition.z = playerCollider.end.z + radius * Math.sin(phi) * Math.cos(totalRotation);

camera.lookAt(playerCollider.end);
}

let desiredCameraPosition = new THREE.Vector3();
function animate() {
    console.time('animate');

    const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

    console.time('loop');
    for (let i = 0; i < STEPS_PER_FRAME; i++) {
        console.time('controls');
        controls(deltaTime);
        console.timeEnd('controls');

        console.time('updatePlayer');
        updatePlayer(deltaTime);
        console.timeEnd('updatePlayer');

        console.time('teleportPlayerIfOob');
        teleportPlayerIfOob();
        console.timeEnd('teleportPlayerIfOob');

        if (!jumping) {
            console.time('cameraCollisions');
            cameraCollisions();
            console.timeEnd('cameraCollisions');
        }
    }
    console.timeEnd('loop');

    // Lerp camera position
    if (!jumping && camera.position.distanceToSquared(desiredCameraPosition) > 0.01) {
        console.time('cameraLerp');
        camera.position.lerp(desiredCameraPosition, 0.1);
        console.timeEnd('cameraLerp');
    }

    // Always look at player
    console.time('cameraLookAt');
    camera.lookAt(playerCollider.end);
    console.timeEnd('cameraLookAt');

    console.time('render');
    renderer.render(scene, camera);
    console.timeEnd('render');

    console.time('requestAnimationFrame');
    requestAnimationFrame(animate);
    console.timeEnd('requestAnimationFrame');

    console.timeEnd('animate');
}

const loader = new GLTFLoader().setPath( './models/gltf/' );

loader.load( 'collision-world.glb', ( gltf ) => {
    replaceMaterialWithLambert(gltf);
    window.sett = gltf;
    scene.add( gltf.scene );
    gltf.scene.traverse( child => {
        if (child.isMesh && !child.isAwduhm) {
            objectsInScene.push(child);
        }
    });
    worldOctree.fromGraphNode( gltf.scene );

    gltf.scene.traverse( child => {

        if ( child.isMesh ) {

           // child.castShadow = true;
            child.receiveShadow = true;

            if ( child.material.map ) {

                child.material.map.anisotropy = 4;

            }

        }

    } );

   
    animate();

} );



function getForwardVector() {

camera.getWorldDirection( playerDirection );
playerDirection.y = 0;
playerDirection.normalize();

return playerDirection;

}

function getSideVector() {

camera.getWorldDirection( playerDirection );
playerDirection.y = 0;
playerDirection.normalize();
playerDirection.cross( camera.up );

return playerDirection;

}

function replaceMaterialWithLambert(gltf) {
    gltf.scene.traverse( (child) => {
        if (child.isMesh && child.material instanceof THREE.MeshStandardMaterial) {
            let oldMat = child.material;
            let newMat = new THREE.MeshLambertMaterial();

            // Copy properties
            newMat.color.copy(oldMat.color);
            //newMat.map = oldMat.map;
            newMat.lightMap = oldMat.lightMap;
            newMat.lightMapIntensity = oldMat.lightMapIntensity;
            newMat.aoMap = oldMat.aoMap;
            newMat.aoMapIntensity = oldMat.aoMapIntensity;
            newMat.emissive.copy(oldMat.emissive);
            newMat.emissiveMap = oldMat.emissiveMap;
            newMat.emissiveIntensity = oldMat.emissiveIntensity;
            newMat.specularMap = oldMat.specularMap;
            newMat.alphaMap = oldMat.alphaMap;
            newMat.envMap = oldMat.envMap;
            newMat.combine = oldMat.combine;
            newMat.reflectivity = oldMat.reflectivity;
            newMat.refractionRatio = oldMat.refractionRatio;
            newMat.wireframe = oldMat.wireframe;

            // Replace material
            child.material = newMat;
        }
    });
}

		</script>
	</body>
</html>